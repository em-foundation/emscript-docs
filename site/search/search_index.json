{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"shelf-index/","title":"Shelf index","text":""},{"location":"shelf-index/#zigem-packages","title":"Zig\u2022EM packages","text":""},{"location":"articles/","title":"Deep-dives into EM\u2022Script","text":"<p>under development \u2013 check back soon</p>"},{"location":"blog/","title":"Blogging about EM\u2022Script","text":""},{"location":"blog/post-001/","title":"(Re-)Introducing EM\u2009!!","text":"<p>The journey continues....\u2009 Going \"back to the drawing-board\", we've reworked the original EM Programming Language into a novel  environment \u2013 which quantitatively\u2009 improves embedded code performance as well as qualitatively\u2009 elevates your embedded coding experience. </p>"},{"location":"blog/post-001/#from-em-to-emscript","title":"From EM to EM\u2022Script","text":"<p>We've followed a very simple recipe in our latest flagship effort:</p> <p> \u00a0 start with TypeScript \u2013 a widely-used (\"top-five\") modern programming language;  \u00a0 add VS Code to the mix \u2013 the popular IDE in fact written in TypeScript; and then  \u00a0 fold in some \"secret-sauce\" found in EM \u2013 which finally takes us to EM\u2022Script</p> <p>Operating within the confines of TypeScript \u2013 and leveraging its world-class language support within VS Code \u2013 we've morphed a standalone EM language (used by just a handful of developers since 2010) into an EM\u2022Script environment accessible to the broader community.</p> <p>Following our inaugural  EM\u2022Script SDK release [<code>v26.1.0</code>], watch for revamped tutorials and articles coming available at this site \u2013 including updated EM\u2022Mark scores which measure program size, execution time, and overall energy efficiency of embedded applications.</p> <p>But ultimately, you'll have to evaluate EM\u2022Script on your own terms \u2013 so let's get started\u2009!!</p>"},{"location":"blog/post-001/#call-to-action","title":"Call to action","text":"<p>visit this site's Home page and read more about the what\u2009|\u2009why\u2009|\u2009how of EM\u2022Script </p> <p>download the latest version of the EM\u2022Script SDK and even blink some LEDs [see Setup]  </p> <p>follow The EM Foundation on GitHub and LinkedIn \u2013 and pass this information on to others</p> <p>Happy coding\u2009!!! \u2002  </p>"},{"location":"home/","title":"EM\u2022Script \u2014 EM\u2122 Reimagined","text":"<p>Welcome (back) to EM [\u02c8\u025bm\u2009] \u2013 a programming environment which targets resource-constrained embedded systems.\u2009 To flatten its learning curve and drive broader use, we've now reimagined EM within the boundaries of the TypeScript language \u2013 leading us to EM\u2022Script.</p>"},{"location":"home/#what-and-why","title":"What and why","text":"<p>1 \u2014 Refresh my memory of EM\u2009...</p> <p>Since its inception in 2010, the focus of the EM Programming Language has remained constant \u2013 producing \"tiny code for tiny chips\" where every byte of memory and \u03bcJoule of energy matters when deploying low-cost, low-power embedded systems.</p> <p>Having supported more than twenty 8/16/32-bit MCUs from a dozen silicon vendors, the EM language promises a higher-level\u2009 programming paradigm coupled with a higher-level\u2009 of runtime performance when compared with legacy C/C++ code targeting these MCUs.</p> <p>As important, just a handful of EM programmers have developed thousands of EM modules re-used across a broad range of high-volume (yet proprietary) IoT applications.\u2009  In late 2023, The EM Foundation \u2013 a 501(c)(3) non-profit \u2013 announced an openly available EM-SDK. </p> <p>2 \u2014 So why did you create EM\u2022Script</p> <p>Promoting the EM SDK through blog posts in early 2024 elicited a mixed bag of reactions \u2013 from \"cool, good luck\"\u2009 to \"sorry, try again\"\u2009.\u2009  Despite evidence quantifying EM's performance advantage over C/C++, a new (and unknown\u2009!!) language does raise the acceptance bar.</p> <p>Needless to say, the effort required to support a handful of developers pales in comparison to promoting, sustaining, and evolving an open-source EM language for the broad community of embedded programmers.\u2009 This realization then led to a radical change of course.</p> <p>Zig\u2022EM \u2013 announced here in 3Q24 \u2013 attacked the issue head-on by nominally grafting the novel concepts and constructs of EM onto another\u2009 programming language.\u2009</p> <p>A hidden gem</p> <p>First released in early 2016, Zig also offers a \"higher-level programming with higher-levels of performance\" value proposition when compared with C/C++.\u2009 Zig regularly earns high-marks when held up against other modern system programming languages like Go and Rust \u2013 both already targeting embedded MCUs.</p> <p>But unlike the competition, Zig offers an inherent simplicity and transparency reminiscent of classic C \u2013 the incumbant system programming language which some argue Zig could supplant.\u2009 At the same time, Zig challenges many entrenched programming practices and demands that we \"think differently\" from the outset.</p> <p>Speaking now from personal experience:\u2002  While not the easiest language to master, the Ziggit forum stands apart for how it welcomes, nutures, and encourages new members of the Zig programming community.</p> <p>Compared with other system programming languages, however, Zig very much remains a work in progress:\u2002 a stable 1.0 release still lies years away; and language server support within popular development environments like VS Code remains skeletal.</p> <p>Some lessons learned from the Zig\u2022EM experience:</p> <p>\u25cf\u2002 embedding EM within another programming language can afford re-use of the latter's infrastructure</p> <p>\u25cf\u2002 a language combo need not compromise runtime performance [time, space, power] versus legacy EM</p> <p>\u25cf\u2002 while code performance remains a top priority, the quality\u2009 of the coding experience can't lag far behind</p> <p>which then brings us then to EM\u2022Script \u2013 same approach, different language\u2009....</p> <p>3 \u2014 What makes TypeScript an ideal host</p> <p>TypeScript \u2013 younger than EM, in fact \u2013 now claims a perennial spot amongst the five most widely used programming languages.(1) The language also enjoys first-class support within VS Code \u2013 an environment written in TypeScript and used by a vast majority of developers.</p> <ol> <li>see the Stack Overflow Developer Survey</li> </ol> <p>EM\u2022Script does in fact leverage many of the language services and compiler APIs delivered as part of TypeScript.\u2009 As important, the later's robust type-system enables us to capture \"the essence of EM\" without leaving the confines of the TypeScript language.</p> <p>But perhaps the strongest reason for choosing TypeScript comes down to this insight:</p> <p>*NOBODY* regards TypeScript as a suitable language for programming resource-constrained MCUs\u2009!!</p> <p>Opportunities abound.... Unlike other modern programming languages that have \"branched out\" to target embedded MCUs [MicroPython, TinyGo, and others], TypeScript has never had a bridge into the domain of low-cost, low-power embedded systems \u2013 until now, of course\u2009!!</p>"},{"location":"home/#show-and-tell","title":"Show and tell","text":"<p>4 \u2014 Show me some EM\u2022Script source code</p> <p>Well, you can't call yourself a programming language if you can't do this:\u2002  </p> <p></p> em.examples.basic/Ex01_HelloP<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nexport function em$run() {\n    printf`hello world\\n`()\n}\n</code></pre> <p>And to dispel any doubts, let's view the corresponding\u2009<code>.em.ts</code> source file inside VS Code using our special EM\u2022Script extension \u2013 which will flatten your learning curve by using core Type\u00adScript language services such as syntax highlighting, hover help, and intellisense.</p> <p></p> VS Code Workspace   <p>For a more realistic and compelling example, consider this \"low-level\" EM\u2022Script module which implements a bit-banged UART transmitter using a GPIO pin and a hardware counter:</p> <p>em.utils/SoftUart<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Common from '@em.mcu/Common.em'\nimport * as GpioI from '@em.hal/GpioI.em'\n\nexport const baud_rate = $config&lt;u32&gt;(9_600)\nexport const TxPin = $proxy&lt;GpioI.$I&gt;()\n\nconst bit_time = $config&lt;u16&gt;()\n\nexport namespace em$meta {\n    export function em$construct() {\n        bit_time.$$ = Math.floor(1_000_000 / baud_rate.$$)\n    }\n}\n\nexport function em$startup(): void {\n    TxPin.$$.makeOutput()\n    TxPin.$$.set()\n}\n\nexport function put(data: u8): void {\n    const bit_cnt = 10\n    var tx_byte: u16 = (data &lt;&lt; 1) | 0x600\n    const key = Common.GlobalInterrupts.$$.disable()\n    for (let i = 0; i &lt; bit_cnt; i++) {\n        Common.UsCounter.$$.set(bit_time.$$)\n        if (tx_byte &amp; 0x1) {\n            TxPin.$$.set()\n        } else {\n            TxPin.$$.clear()\n        }\n        tx_byte &gt;&gt;= 1\n        Common.UsCounter.$$.spin()\n    }\n    TxPin.$$.set()\n    Common.GlobalInterrupts.$$.restore(key)\n}\n</code></pre> While this module clearly interacts with typical MCU hardware \u2013 controlling interrupts, toggling pins, awaiting \u03bcs counters \u2013 the\u2009<code>em.utils/SoftUart</code>\u2009code shown here in fact remains 100% portable\u2009 across any MCU offering these sorts of hardware capabilities.</p> <p>5 \u2014 How does EM\u2022Script optimize target firmware</p> <p>While sourced as TypeScript, an efficient implementation of the <code>put</code> function defined at line 23 of <code>em.utils/SoftUart</code> ultimately requires object code\u2009 targeting the MCU instruction-set.\u2009 To that end, EM\u2022Script could simply translate <code>.em.ts</code> files into corresponding C++ sources.</p> <p></p> Compilation Phase   <p>Bear with us \u2013 we've purposely omitted the most critical phase of the EM\u2022Script program build-flow\u2009!!</p> <p>Starting with a \"top-level\" program source file (eg, <code>Ex01_HelloP.em.ts</code>), the translator follows its <code>import</code> chain and generates a <code>main.cpp</code> program \u2013 adding other translated files through <code>#include</code> directives and implementing the special <code>em$run</code> function seen here within <code>main</code>.</p> <p>Like EM before it, the EM\u2022Script build flow can leverage any compiler suite which supports the C++14 standard.\u2009 And who knows, maybe EM\u2022Script will someday support other target programming languages as well \u2013 including Zig. </p> <p>With a self-contained <code>main.cpp</code> as its sole input, the downstream compiler can aggressively apply stock optimization techniques(1)\u2009to the whole program\u2009 \u2013 yielding a smaller, more efficient <code>main.out</code> image.\u2009 But the real power of EM\u2022Script lies in what happens upstream:</p> <ol> <li>constant folding, function inlining, dead-code elimination, etc</li> </ol> <p></p> Configuration Phase   <p>The EM\u2022Script program build-flow inserts a novel configuration\u2009 step between initial translation and downstream compilation \u2013 enabling a world of application-centric optimizations often missed when building legacy C/C++ programs.</p> <p>Besides generating C++ code for each <code>.em.ts</code> source file, EM\u2022Script invokes an extended TypeScript\u2192JavaScript transpiler which yields corresponding <code>.em.js</code> modules \u2013 all combined into a single <code>main.js</code> program executed at build-time\u2009 on your host PC.</p> <p>Our configuration phase in fact serves as a staging area\u2009 where the whole program comes together for a \"dry-run\", so to speak.\u2009 By implementing special  functions(1)inside <code>namespace</code> <code>em$meta</code>, each module can actively participate in the configuration process at build-time:</p> <ol> <li><code>em$configure</code>, <code>em$construct</code>, <code>em$generate</code>, etc</li> </ol> <p>\u25cf\u2002 by binding values to EM\u2022Script <code>$config</code> parameters published by other modules</p> <p>\u25cf\u2002 by pre-initializing static constants and variables used internally by the module</p> <p>\u25cf\u2002 by wiring one module to another via the <code>$proxy</code>\u2009\u2013\u2009<code>$delegate</code> design pattern</p> <p>\u25cf\u2002 by forcibly including\u2009/\u2009excluding individual modules from downstream compilation</p> <p>\u25cf\u2002 by generating fragments of specialized C/C++ code which <code>main.cpp</code> will incorporate</p> <p>As such, EM\u2022Script serves as its own meta-language\u2009 used for build-time meta-programming\u2009.</p> <p>With boundless resources on your host PC \u2013 and with all of Node.js available to the <code>main.js</code> meta-program \u2013 opportunities abound for individual modules to encapsulate application-centric logic that ultimately shapes program images targeting resource-constrained MCUs.</p>"},{"location":"home/#next-steps","title":"Next steps","text":"<p>6 \u2014 Can I start exploring the EM\u2022Script environment</p> <p>Absolutely \u2013 the Setup section of this site will help you get started with our EM\u2022Script SDK.\u2009 Once you've provisioned a compatible(1)host PC, you can cross-compile target applications using EM\u2022Script \u2013 either from the command-line or else within the VS Code environment.</p> <ol> <li>Windows, Linux, or MacOS</li> </ol> <p>While not required, we strongly encourage you to purchase a low-cost MCU development board currently supported by the SDK.\u2009  Nothing beats the joy of blinking those LEDs\u2009!!\u2009 </p> <p>If you'd prefer to just \"look around\", check out the other sections of this site \u2013 which we'll continue to populate going forward.\u2009 You can also browse the set of target Packages delivered with the latest EM\u2022Script SDK.\u2009 And for those wanting OSS, endulge yourself at GitHub.</p> <p>7 \u2014 Tell me more about the longer-term roadmap for EM\u2022Script</p> <p>After a one-year detour \u2013 which led us to EM\u2022Script via Zig\u2022EM \u2013 we can finally continue down the path originally charted by the EM programming language:</p> <p>support a broad(er) range of embedded MCUs and document how to create an <code>em$distro</code></p> <p>offer lightweight connectivity frameworks built upon standard\u2009/\u2009proprietary wireless protocols</p> <p>explore the impact of 10\u2009X code-size reductions on novel MCU architectures based on RISC-V</p> <p>showcase EM\u2022Script through application development projects sponsored by The EM Foundation</p> <p>EM\u2022Script \u2013 The embedded language for embedded programming</p> <p>Happy coding\u2009!!! \u2002  </p>"},{"location":"setup/","title":"Getting started with EM\u2022Script","text":"<p>EM\u2022Script requires a cross-development environment comprising hosted\u2009 software tools will compile and load executable programs onto target\u2009 MCU hardware.\u2009 For the host, you'll use a PC running Windows, Linux, or MacOS; for the target, you can choose any MCU board for which a corresponding <code>em$distro</code> support package already exists.</p> <p>Before turning to the EM\u2022Script SDK (described next), you should first install or upgrade the following tooling environments on your host PC:</p> Node.js version 18.0.0 or later execute <code>node</code> <code>--version</code> to verify VS Code version 1.90.0 or later execute <code>code</code> <code>--version</code> to verify Windows <p>If you don't already have a recent version of the Git Bash shell, you should also install Git for Windows.\u00a0  To verify your setup, ensure that the <code>node</code> and <code>code</code> commands from the previous table operate correctly under Git Bash. </p> <p>Do not proceed forward if these verification checks should fail\u2009!!!</p>"},{"location":"setup/#software-development-kit","title":"Software development kit","text":"<p>You can provision the latest EM\u2022Script SDK onto your host PC in three simple steps:</p> <p> \u00a0 download a workspace pre-populated with packages of EM\u2022Script target-content  \u00a0 install EM\u2022Script host-tooling along with some 3<sup>rd</sup> party compilers and loaders  \u00a0 verify that you can build (and optionally run) a sample EM\u2022Script program</p> <p>Step  relies upon the <code>git</code> command to initially populate (and subsequently update) a special <code>emscript-sdk</code> folder on your host PC:</p> <p><pre><code>[~]\n$ git clone https://github.com/em-foundation/emscript-sdk.git\n$ cd emscript-sdk\n[~/emscript-sdk]\n$ \u25ae</code></pre></p> <p>In general, you can maintain multiple <code>emscript-sdk</code> installations located anywhere on your PC \u2013 though we recommend starting with your <code>$HOME</code> folder <code>[~]</code> as illustrated above.\u2009  Once inside <code>~/emscript-sdk</code>, you can use other <code>git</code> sub-commands to upgrade your EM\u2022Script installation [<code>git</code> <code>pull</code>] as well as switch to particular tagged releases [<code>git</code> <code>checkout</code> <code>v26.1.0</code>].</p> <p>Step  uses the Node Package Manager <code>npm</code> command to install tooling artifacts into your current <code>emscript-sdk</code> folder:</p> <p><pre><code>[~/emscript-sdk]\n$ npm clean-install</code></pre></p> <p>Initial execution of this command will create the special <code>node_modules</code> sub-folder used by Node.js as well as a <code>tools</code> sub-folder used by EM\u2022Script.\u2009 Use the <code>npm</code> <code>list</code> command to show the current set of installed packages, which should track the dependencies called out within the top-level <code>emscript-sdk/package.json</code> file.</p> <p>Step  finally verifies your EM\u2022Script installation by building a small program: </p> <p><pre><code>[~/emscript-sdk]\n$ npm run verify-build\n&gt; emscript-cli@26.0.1 verify-build\n&gt; sh -c '(cd workspace; npx emscript-cli build --unit em.core/em.examples.basic/Ex02_BlinkerP.em.ts)'\nbuilding \u2018em.examples.basic/Ex02_BlinkerP\u2019 ...\n    using setup \u2018ti.cc23xx://default\u2019 with board \u2018LP_EM_CC2340R5\u2019\n    executed \u2018em$meta\u2019 program, generated \u2018main.cpp\u2019 using [31/62] units in 0.90 seconds\ncompiling \u2018main.cpp\u2019 ...\n    image sha32: 1dc95979\n    image size: text (1212) + const (12) + data (0) + bss (16)\ndone in 1.80 seconds\n[~/emscript-sdk]\n$ \u25ae</code></pre></p>"},{"location":"setup/#target-mcu-hardware","title":"Target MCU hardware","text":"<p>The SDK contains all tooling needed to compile and load EM\u2022Script programs targeting different MCU development boards.\u2009  While we encourage you to purchase one of these boards, you can still learn about EM\u2022Script by building (but not running) some sample programs.</p> LP-EM-CC2340R5 <p>The Texas Instruments CC2340R5 wireless MCU features an Arm Cortex-M0+ CPU together with a familiar suite of peripherals \u2013 including a generic 2.4\u2009GHz radio with BLE 5.x support.  Texas Instruments also offers an inexpensive LP-EM-CC2340R5 evaluation board in their familiar LaunchPad format \u2013 available from TI as well as their distributors.</p> <p>You should also purchase this emulator board from TI \u2013 unless you already own a \"classic\" TI LaunchPad with on-board XDS110 support.  In that case, you can easily connect a legacy LP to your new LP-EM-CC2340R5 board using a cable supplied by TI.\u2009  If you haven't used an XDS110 before, run the <code>emscript-sdk/tools/ti-uniflash/one_time_setup</code> script.</p> <p>We'll soon verify that your LP-EM-CC2340R5 hardware works in concert with the SDK by building and loading a sample EM\u2022Script program.</p>"},{"location":"setup/#vs-code-extension","title":"VS Code extension","text":"<p>To flatten your learning curve, we strongly encourage use of our EM\u2022Script Extension, which you can install from the command-line prior to launching VS Code:</p> <p><pre><code>[~/emscript-sdk]\n$ code --install-extension emscript*.vsixInstalling extensions...\nExtension \u2018emscript-26.0.1.202502091752.vsix\u2019 was successfully installed.\n[~/emscript-sdk]\n$ code .</code></pre></p> <p>If all goes well, you should see a top-level listing of the <code>~/emscript-sdk</code> folder together with a short notification that the EM\u2022Script Extension has activated.</p> <p></p> Launching VS Code  <p>You can learn more by navigating to the EXTENSIONS &gt; INSTALLED side-panel or else by visiting the EM\u2022Script page at the VS Code Marketplace.</p> <p></p> Installed Extensions  <p>From here, you should drill-down into the <code>~/emscript-sdk/workspace</code> sub-folder and explore the software content which EM\u2022Script can build and load onto your target MCU hardware.</p> <p></p> Target Content  <p>Our Zig\u2022EM extension supports features already familiar to VS Code users \u2013 syntax highlighting, code navigation, outline views, hover help, intellisense completion, and many more.</p>"},{"location":"setup/#command-line","title":"Command line","text":"<p>The SDK contains an <code>emscript</code> command-line tool which compiles and loads programs for your target MCU hardware.\u2009 Used internally by <code>npm</code> <code>run</code> <code>verify-build</code> as part of installation step , you can access the <code>emscript</code> command directly from your PC's shell.</p> <p>You'll find the <code>emscript</code> executable at <code>emscript-sdk/node_modules/.bin/emscript</code>;\u2009 for convenience, amend your shell's <code>$PATH</code> or else reference <code>emscript</code> with a named link or alias:</p> <p><pre><code>$ alias emscript='~/emscript-sdk/node_modules/.bin/emscript'\n$ emscript --version\n26.0.1.202502071929</code></pre></p> <p>The <code>emscript</code> <code>build</code> sub-command will serve as your primary entry-point when working with EM\u2022Script.\u2009 Typically invoked inside the <code>emscript-sdk/workspace</code> sub-folder, let's now build the same\u2009 target program used to verify SDK installation:</p> <p><pre><code>[~/emscript-sdk/workspace]\nemscript build --unit em.core/em.examples.basic/Ex02_BlinkerP.em.ts\nbuilding \u2018em.examples.basic/Ex02_BlinkerP\u2019 ...\n    using setup \u2018ti.cc23xx://default\u2019 with board \u2018LP_EM_CC2340R5\u2019\n    executed \u2018em$meta\u2019 program, generated \u2018main.cpp\u2019 using [31/62] units in 0.90 seconds\ncompiling \u2018main.cpp\u2019 ...\n    image sha32: 1dc95979\n    image size: text (1212) + const (12) + data (0) + bss (16)\ndone in 1.80 seconds</code></pre></p> <p>To confirm operation of your target MCU hardware, simply append the <code>--load</code> option to the same command:</p> <p><pre><code>[~/emscript-sdk/workspace]\nemscript build --unit em.core/em.examples.basic/Ex02_BlinkerP.em.ts --load\nbuilding \u2018em.examples.basic/Ex02_BlinkerP\u2019 ...\n    ...\ndone in 1.80 seconds\nloading \u2018em.examples.basic/Ex02_BlinkerP\u2019 ...\ndone</code></pre></p> <p>If you now see an on-board (green) LED blink five times, go out and celebrate.... </p> <p>Happy coding\u2009!!! \u2002  </p>"},{"location":"shelf/","title":"Index","text":""},{"location":"shelf/#latest-emscript-sdk-packages","title":"Latest EM\u2022Script SDK packages","text":""},{"location":"shelf/em.core/","title":"Index","text":""},{"location":"shelf/em.core/#packageemcore","title":"<code>package</code> <code>em.core</code>","text":""},{"location":"shelf/em.core/em.arch.arm/","title":"Index","text":""},{"location":"shelf/em.core/em.arch.arm/#bundleemarcharm","title":"<code>bundle</code> <code>em.arch.arm</code>","text":""},{"location":"shelf/em.core/em.arch.arm/GlobalInterrupts/","title":"GlobalInterrupts","text":"em.arch.arm/GlobalInterrupts.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as GlobalInterruptsI from '@em.hal/GlobalInterruptsI.em'\nimport * as IntrVec from '@em.arch.arm/IntrVec.em'\n\nexport function disable(): GlobalInterruptsI.Key {\n    const key = IntrVec.PRIMASK_get()\n    e$`asm volatile (\"cpsid i\" ::: \"memory\")`\n    return &lt;GlobalInterruptsI.Key&gt;key\n}\n\nexport function enable() {\n    e$`asm volatile (\"cpsie i\" ::: \"memory\")`\n}\n\nexport function isEnabled(): bool_t {\n    return IntrVec.PRIMASK_get() == 0\n}\n\nexport function restore(key: GlobalInterruptsI.Key) {\n    if (key == 0) enable()\n}\n</code></pre>"},{"location":"shelf/em.core/em.arch.arm/IntrVec/","title":"IntrVec","text":"em.arch.arm/IntrVec.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nexport namespace em$meta {\n\n    const NO_VEC = '&lt;NA&gt;'\n\n    const core_intrs = [\n        'NMI',\n        'HardFault',\n        NO_VEC,\n        NO_VEC,\n        NO_VEC,\n        NO_VEC,\n        NO_VEC,\n        NO_VEC,\n        NO_VEC,\n        'SVCall',\n        NO_VEC,\n        NO_VEC,\n        'PendSV',\n        'SysTick',\n    ]\n\n    const intr_list = new Array&lt;string&gt;()\n    const used_list = new Array&lt;string&gt;()\n    const used_set = new Set&lt;string&gt;()\n\n    export function em$init() {\n        $U.used()\n        for (let name of core_intrs) addIntr(name)\n    }\n\n    export function em$generate() {\n        let out = $outfile('em.arch.arm/intr.cpp')\n        out.addFrag(`\n                        |-&gt; //\n                        |-&gt; #include &lt;stdbool.h&gt;\n                        |-&gt; #include &lt;stdint.h&gt;\n                        |-&gt; \n                        |-&gt; typedef void( *intfunc )( void );\n                        |-&gt; typedef union { intfunc fxn; void* ptr; } intvec_elem;\n                        |-&gt; \n                        |-&gt; extern uint32_t __stack_top__;\n                        |-&gt; extern \"C\" void em__start( void );\n                        |-&gt; \n                        |-&gt; extern \"C\" void DEFAULT_isr$$( void );\n                        |-&gt; \n                        |-&gt; extern \"C\" const intvec_elem  __attribute__((section(\".intvec\"))) __vector_table[35] = {\n                        |-&gt;     { .ptr = (void*)&amp;__stack_top__ },\n                        |-&gt;     { .fxn = em__start },\n        `)\n        for (let n of intr_list) {\n            const s = n == NO_VEC ? '0' : used_set.has(n) ? `${n}_isr$$` : 'DEFAULT_isr$$'\n            out.addFrag(`\n                        |-&gt; /**/${s},\n            `)\n        }\n        out.addFrag(`\n                        |-&gt; };\n        `)\n        out.close()\n    }\n\n    export function addIntr(name: string) {\n        intr_list.push(name)\n    }\n\n    export function useIntr(name: string) {\n        used_list.push(name)\n        used_set.add(name)\n    }\n}\n\nexport function em$startup() {\n    e$`SCB-&gt;VTOR = (uint32_t)(&amp;__vector_table)`\n}\n\nexport function NVIC_clear(irqN: u8) {\n    e$`NVIC_ClearPendingIRQ((IRQn_Type)irqN)`\n}\n\nexport function NVIC_disable(irqN: u8) {\n    e$`NVIC_DisableIRQ((IRQn_Type)irqN)`\n}\n\nexport function NVIC_enable(irqN: u8) {\n    e$`NVIC_EnableIRQ((IRQn_Type)irqN)`\n}\n\nexport function PRIMASK_get(): u32 {\n    return e$`__get_PRIMASK()`\n}\n\nexport function PRIMASK_set(m: u32) {\n    e$`__set_PRIMASK(m)`\n}\n\nexport function DEFAULT_isr$$() {\n    em.$['%%b:'](3)\n    let vnum = &lt;u32&gt;e$`__get_IPSR()`\n    em.$['%%&gt;'](vnum)\n    let fp = &lt;ptr_t&lt;u32&gt;&gt;(e$`__get_MSP()`)\n    em.$['%%&gt;'](fp.$cur())\n    for (let i = 0; i &lt; 8; i++) {\n        em.$['%%b']\n        em.$['%%&gt;'](fp.$$)\n        fp.$inc()\n    }\n    em.fail#f()\n}\n</code></pre>"},{"location":"shelf/em.core/em.arch.arm/StartupC/","title":"StartupC","text":"em.arch.arm/StartupC.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('COMPOSITE')\n\nexport function em$generate() {\n    let out = $outfile('em.arch.arm/startup.cpp')\n    let bf = $property('em.build.BootFlash', false) ? '1' : '0'\n    out.addFrag(`\n        |-&gt; #define __EM_BOOT_FLASH__ ${bf}\n        |-&gt; \n        |-&gt; #include &lt;stdbool.h&gt;\n        |-&gt; #include &lt;stdint.h&gt;\n        |-&gt; \n        |-&gt; extern uint32_t __bss_addr__;\n        |-&gt; extern uint32_t __bss_size__;\n        |-&gt; extern uint32_t __code_addr__;\n        |-&gt; extern uint32_t __code_load__;\n        |-&gt; extern uint32_t __code_size__;\n        |-&gt; extern uint32_t __data_addr__;\n        |-&gt; extern uint32_t __data_load__;\n        |-&gt; extern uint32_t __data_size__;\n        |-&gt; extern uint32_t __global_pointer__;\n        |-&gt; extern uint32_t __stack_top__;\n        |-&gt; \n        |-&gt; extern \"C\" int main();\n        |-&gt; extern \"C\" bool __is_warm();\n        |-&gt; \n        |-&gt; typedef struct {\n        |-&gt;     unsigned int* codeLoad;\n        |-&gt;     unsigned int* codeAddr;\n        |-&gt;     unsigned int* bssAddr;\n        |-&gt;     unsigned int bssSize;\n        |-&gt; } __em_desc_t;\n        |-&gt; \n        |-&gt; extern \"C\" void __attribute__((section(\".start\"), noreturn)) em__start() {\n        |-&gt; \n        |-&gt;     if (!__is_warm()) {\n        |-&gt;         uint32_t *src;\n        |-&gt;         uint32_t *dst;\n        |-&gt;         volatile uint32_t sz;\n        |-&gt;         sz = (uint32_t)&amp;__bss_size__;\n        |-&gt;         dst = &amp;__bss_addr__;\n        |-&gt;         asm(\"nop\");\n        |-&gt;         asm(\"nop\");\n        |-&gt;         asm(\"nop\");\n        |-&gt;         for (uint32_t i = 0; i &lt; sz; i++) {     // TODO -- while (sz--) not working\n        |-&gt;             dst[i] = 0;\n        |-&gt;         }\n        |-&gt;         sz = (uint32_t)&amp;__data_size__;\n        |-&gt;         src = &amp;__data_load__;\n        |-&gt;         dst = &amp;__data_addr__;\n        |-&gt;         for (uint32_t i = 0; i &lt; sz; i++) {\n        |-&gt;             dst[i] = src[i];\n        |-&gt;         }\n        |-&gt; #if __EM_BOOT_FLASH__ == 1\n        |-&gt;         sz = (uint32_t)&amp;__code_size__;\n        |-&gt;         src = &amp;__code_load__;\n        |-&gt;         dst = &amp;__code_addr__;\n        |-&gt;         for (uint32_t i = 0; i &lt; sz; i++) {\n        |-&gt;             dst[i] = src[i];\n        |-&gt;         }\n        |-&gt; #endif\n        |-&gt;     }\n        |-&gt; \n        |-&gt;     main();\n        |-&gt;     __builtin_unreachable();\n        |-&gt; }\n        |-&gt; \n        |-&gt; #if __EM_BOOT_FLASH__ == 1\n        |-&gt; extern \"C\" const void* __attribute__((section(\".start_vec\"))) __em_start_vec[] = {\n        |-&gt;     (void*)&amp;__stack_top__ ,\n        |-&gt;     (void*)em__start,\n        |-&gt; };\n        |-&gt; #endif\n    `)\n    out.close()\n}\n</code></pre>"},{"location":"shelf/em.core/em.arch.arm/UsCounterSystick/","title":"UsCounterSystick","text":"em.arch.arm/UsCounterSystick.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nexport const MHZ = $config&lt;u16&gt;(48)\n\nconst MAX = &lt;u32&gt;0x00FF_FFFF\n\nvar cur_thresh = &lt;u32&gt;0\n\nexport function set(time_us: u32) {\n    cur_thresh = MAX - (time_us * MHZ.$$)\n    start()\n}\n\nexport function spin() {\n    let val: volatile_t&lt;u32&gt; = MAX\n    while (val &gt; cur_thresh) val = e$`SysTick-&gt;VAL`\n    e$`SysTick-&gt;CTRL = 0`\n}\n\nexport function start() {\n    e$`SysTick-&gt;CTRL = (1 &lt;&lt; SysTick_CTRL_CLKSOURCE_Pos) | (1 &lt;&lt; SysTick_CTRL_ENABLE_Pos)`\n    e$`SysTick-&gt;LOAD = 0xFFFFFF`\n    e$`SysTick-&gt;VAL = 0`\n}\n\nexport function stop(): u32 {\n    let lr = &lt;u32&gt;e$`SysTick-&gt;LOAD`\n    let vr = &lt;u32&gt;e$`SysTick-&gt;VAL`\n    let dt = (((lr - vr) &lt;&lt; 1) / MHZ.$$) &gt;&gt; 1\n    e$`SysTick-&gt;CTRL = 0`\n    return dt\n}\n</code></pre>"},{"location":"shelf/em.core/em.bench.coremark/","title":"Index","text":""},{"location":"shelf/em.core/em.bench.coremark/#bundleembenchcoremark","title":"<code>bundle</code> <code>em.bench.coremark</code>","text":""},{"location":"shelf/em.core/em.bench.coremark/ActiveRunnerP/","title":"ActiveRunnerP","text":"em.bench.coremark/ActiveRunnerP.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\nimport * as CoreBench from '@em.bench.coremark/CoreBench.em'\nimport * as Utils from '@em.bench.coremark/Utils.em'\n\nconst AppLed = $delegate(BoardC.AppLed)\n\nlet ITERATIONS = $config&lt;u16&gt;(10)\n\nexport function em$startup() {\n    CoreBench.setup()\n}\n\nexport function em$run() {\n    AppLed.$$.on()\n    Common.BusyWait.$$.wait(250_000)\n    AppLed.$$.off()\n    Common.UsCounter.$$.start()\n    em.$['%%d+']\n    for (let i = 0; i &lt; ITERATIONS.$$; i++) {\n        CoreBench.run(0)\n    }\n    em.$['%%d-']\n    let usecs = Common.UsCounter.$$.stop()\n    AppLed.$$.on()\n    Common.BusyWait.$$.wait(250_000)\n    AppLed.$$.off()\n    printf`usecs = %d\\n`(usecs)\n    printf`list crc = %04x\\n`(Utils.getCrc(Utils.Kind.LIST))\n    printf`matrix crc = %04x\\n`(Utils.getCrc(Utils.Kind.MATRIX))\n    printf`state crc = %04x\\n`(Utils.getCrc(Utils.Kind.STATE))\n    printf`final crc = %04x\\n`(Utils.getCrc(Utils.Kind.FINAL))\n}\n</code></pre>"},{"location":"shelf/em.core/em.bench.coremark/BenchAlgI/","title":"BenchAlgI","text":"em.bench.coremark/BenchAlgI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nimport * as Utils from '@em.bench.coremark/Utils.em'\n\nexport interface $I {\n    kind(): Utils.Kind\n    print(): void\n    run(arg: i16): Utils.sum_t\n    setup(): void\n}\n</code></pre>"},{"location":"shelf/em.core/em.bench.coremark/CoreBench/","title":"CoreBench","text":"em.bench.coremark/CoreBench.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Crc from '@em.bench.coremark/Crc.em'\nimport * as ListBench from '@em.bench.coremark/ListBench.em'\nimport * as MatrixBench from '@em.bench.coremark/MatrixBench.em'\nimport * as StateBench from '@em.bench.coremark/StateBench.em'\nimport * as Utils from '@em.bench.coremark/Utils.em'\n\nconst TOTAL_DATA_SIZE = $config&lt;u16&gt;(2000)\nconst NUM_ALGS = $config&lt;u8&gt;(3)\n\nexport namespace em$meta {\n\n    export function em$configure() {\n        let memsize = Math.floor(TOTAL_DATA_SIZE.$$ / NUM_ALGS.$$)\n        ListBench.memsize.$$ = memsize\n        MatrixBench.memsize.$$ = memsize\n        StateBench.memsize.$$ = memsize\n    }\n\n    export function em$construct() {\n        Utils.em$meta.bindSeed(1, 0x0)\n        Utils.em$meta.bindSeed(2, 0x0)\n        Utils.em$meta.bindSeed(3, 0x66)\n    }\n}\n\nexport function kind(): Utils.Kind {\n    return Utils.Kind.FINAL\n}\n\nexport function print() {\n    ListBench.print()\n    MatrixBench.print()\n    StateBench.print()\n}\n\nexport function run(arg: i16): Utils.sum_t {\n    let crc = ListBench.run(1)\n    Utils.setCrc(Utils.Kind.FINAL, Crc.add16(&lt;i16&gt;crc, Utils.getCrc(Utils.Kind.FINAL)))\n    crc = ListBench.run(-1)\n    Utils.setCrc(Utils.Kind.FINAL, Crc.add16(&lt;i16&gt;crc, Utils.getCrc(Utils.Kind.FINAL)))\n    Utils.bindCrc(Utils.Kind.LIST, Utils.getCrc(Utils.Kind.FINAL))\n    return Utils.getCrc(Utils.Kind.FINAL)\n}\n\nexport function setup() {\n    ListBench.setup()\n    MatrixBench.setup()\n    StateBench.setup()\n}\n</code></pre>"},{"location":"shelf/em.core/em.bench.coremark/Crc/","title":"Crc","text":"em.bench.coremark/Crc.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Utils from '@em.bench.coremark/Utils.em'\n\nexport type sum_t = Utils.sum_t\n\nexport function add16(val: i16, crc: sum_t): sum_t {\n    const v = val\n    crc = update(v, crc)\n    crc = update((v &gt;&gt; 8), crc)\n    return crc\n}\n\nexport function addU32(val: u32, crc: sum_t): sum_t {\n    crc = add16(&lt;i16&gt;val, crc)\n    crc = add16(&lt;i16&gt;(val &gt;&gt; 16), crc)\n    return crc\n}\n\nfunction update(data: u8, crc: sum_t): sum_t {\n    let x16 = &lt;u8&gt;0\n    let carry = &lt;u8&gt;0\n    for (let i = 0; i &lt; 8; i++) {\n        x16 = &lt;u8&gt;((data &amp; 1) ^ (&lt;u8&gt;crc &amp; 1))\n        data &gt;&gt;= 1\n        if (x16 == 1) {\n            crc ^= 0x4002\n            carry = 1\n        }\n        else {\n            carry = 0\n        }\n        crc &gt;&gt;= 1\n        if (carry) {\n            crc |= 0x8000\n        }\n        else {\n            crc &amp;= 0x7fff\n        }\n    }\n    return crc\n}\n\nexport function em$run() {\n    let sum = 0\n    for (let i = 0; i &lt; 5; i++) {\n        sum = add16(i, sum)\n    }\n    printf`sum = %04x\\n`(sum)\n}\n</code></pre>"},{"location":"shelf/em.core/em.bench.coremark/ListBench/","title":"ListBench","text":"em.bench.coremark/ListBench.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Crc from '@em.bench.coremark/Crc.em'\nimport * as Utils from '@em.bench.coremark/Utils.em'\n\nexport const memsize = $config&lt;u16&gt;(666)\n\nexport class Data extends $struct {\n    val: i16\n    idx: i16\n}\nlet DataFac = $factory(Data.$make())\n\nclass Elem extends $struct {\n    next: ref_t&lt;Elem&gt;\n    data: ref_t&lt;Data&gt;\n}\nlet ElemFac = $factory(Elem.$make())\n\ntype Comparator = (a: ref_t&lt;Data&gt;, b: ref_t&lt;Data&gt;) =&gt; i32\n\nconst maxElems = $config&lt;u16&gt;(0)\n\nlet curHead_c = $config&lt;ref_t&lt;Elem&gt;&gt;()\nvar curHead: ref_t&lt;Elem&gt;\n\nexport namespace em$meta {\n\n    export function em$construct() {\n        let itemSize = 16 + $sizeof&lt;Data&gt;()\n        maxElems.$$ = Math.round(memsize.$$ / itemSize) - 3\n        curHead = ElemFac.$create()\n        curHead.$$.data = DataFac.$create()\n        let p = curHead\n        for (let i = 0; i &lt; maxElems.$$ - 1; i++) {\n            let q = p.$$.next = ElemFac.$create()\n            q.$$.data = DataFac.$create()\n            p = q\n        }\n        p.$$.data = DataFac.$create()\n        p.$$.next = ElemFac.$null()\n        curHead_c.$$ = curHead\n    }\n\n}\n\nfunction find(list: ref_t&lt;Elem&gt;, data: ref_t&lt;Data&gt;): ref_t&lt;Elem&gt; {\n    let elem = list\n    if (data.$$.idx &gt;= 0) {\n        while (elem &amp;&amp; elem.$$.data.$$.idx != data.$$.idx) {\n            elem = elem.$$.next\n        }\n    }\n    else {\n        while (elem &amp;&amp; &lt;i16&gt;(&lt;u16&gt;elem.$$.data.$$.val &amp; 0xff) != data.$$.val) {\n            elem = elem.$$.next\n        }\n    }\n    return elem\n}\n\nfunction idxCompare(a: ref_t&lt;Data&gt;, b: ref_t&lt;Data&gt;): i32 {\n    a.$$.val = &lt;i16&gt;((&lt;u16&gt;a.$$.val &amp; 0xff00) | (0x00ff &amp; &lt;u16&gt;(a.$$.val &gt;&gt; 8)))\n    b.$$.val = &lt;i16&gt;((&lt;u16&gt;b.$$.val &amp; 0xff00) | (0x00ff &amp; &lt;u16&gt;(b.$$.val &gt;&gt; 8)))\n    return a.$$.idx - b.$$.idx\n}\n\nexport function kind(): Utils.Kind {\n    return Utils.Kind.LIST\n}\n\nfunction pr(list: ref_t&lt;Elem&gt;, name: text_t) {\n    let sz = 0\n    printf`%s\\n[`(name)\n    for (let e = list; e != null; e = e.$$.next) {\n        let pre = (sz++ % 8) == 0 ? t$`\\n    ` : t$``\n        printf`%s(%04x,%04x)`(pre, e.$$.data.$$.idx, &lt;u16&gt;e.$$.data.$$.val)\n    }\n    printf`\\n], size = %d\\n`(sz)\n}\n\nexport function print() {\n    pr(curHead, t$`current`)\n}\n\nfunction remove(item: ref_t&lt;Elem&gt;): ref_t&lt;Elem&gt; {\n    let ret = item.$$.next\n    let tmp = item.$$.data\n    item.$$.data = ret.$$.data\n    ret.$$.data = tmp\n    item.$$.next = item.$$.next.$$.next\n    ret.$$.next = ElemFac.$null()\n    return ret\n}\n\nfunction reverse(list: ref_t&lt;Elem&gt;): ref_t&lt;Elem&gt; {\n    let next = ElemFac.$null()\n    while (list) {\n        let tmp = list.$$.next\n        list.$$.next = next\n        next = list\n        list = tmp\n    }\n    return next\n}\n\n\nexport function run(arg: i16): Utils.sum_t {\n    let list = curHead\n    let finderIdx = &lt;i16&gt;arg\n    let findCnt = Utils.getSeed(3)\n    let found = &lt;u16&gt;0\n    let missed = &lt;u16&gt;0\n    let retval = &lt;Crc.sum_t&gt;0\n    let data = Data.$make()\n    data.idx = finderIdx\n    for (let i = 0; i &lt; findCnt; i++) {\n        data.val = &lt;i16&gt;(i &amp; 0xff)\n        let elem = find(list, $ref(data))\n        list = reverse(list)\n        if (!elem) {\n            missed += 1\n            retval += &lt;u16&gt;(list.$$.next.$$.data.$$.val &gt;&gt; 8) &amp; 0x1\n        }\n        else {\n            found += 1\n            if (&lt;u16&gt;elem.$$.data.$$.val &amp; 0x1) {\n                retval += (&lt;u16&gt;(elem.$$.data.$$.val &gt;&gt; 9)) &amp; 0x1\n            }\n            if (elem.$$.next) {\n                let tmp = elem.$$.next\n                elem.$$.next = tmp.$$.next\n                tmp.$$.next = list.$$.next\n                list.$$.next = tmp\n            }\n        }\n        if (data.idx &gt;= 0) data.idx += 1\n    }\n    retval += found * 4 - missed\n    if (finderIdx &gt; 0) list = sort(list, valCompare)\n    let remover = remove(list.$$.next)\n    let finder = find(list, $ref(data))\n    if (!finder) finder = list.$$.next\n    while (finder) {\n        retval = Crc.add16(list.$$.data.$$.val, retval)\n        finder = finder.$$.next\n    }\n    unremove(remover, list.$$.next)\n    list = sort(list, idxCompare)\n    for (let e = list.$$.next; e; e = e.$$.next) {\n        retval = Crc.add16(list.$$.data.$$.val, retval)\n    }\n    return retval\n}\n\nexport function setup() {\n    curHead = curHead_c.$$\n    let seed = Utils.getSeed(1)\n    let ki = 1\n    let kd = maxElems.$$ - 3\n    let e = curHead\n    e.$$.data.$$.idx = 0\n    e.$$.data.$$.val = 0x8080\n    for (e = e.$$.next; e.$$.next != null; e = e.$$.next) {\n        let pat = &lt;u16&gt;(seed ^ kd) &amp; 0xf\n        let dat = (pat &lt;&lt; 3) | (kd &amp; 0x7)\n        e.$$.data.$$.val = &lt;i16&gt;((dat &lt;&lt; 8) | dat)\n        kd -= 1\n        if (ki &lt; (maxElems.$$ / 5)) {\n            e.$$.data.$$.idx = ki++\n        }\n        else {\n            pat = &lt;u16&gt;(seed ^ ki++)\n            e.$$.data.$$.idx = &lt;i16&gt;(0x3fff &amp; (((ki &amp; 0x7) &lt;&lt; 8) | pat))\n        }\n    }\n    e.$$.data.$$.idx = 0x7fff\n    e.$$.data.$$.val = 0xffff\n    curHead = sort(curHead, idxCompare)\n}\n\nfunction sort(list: ref_t&lt;Elem&gt;, cmp: Comparator): ref_t&lt;Elem&gt; {\n    let insize = &lt;i32&gt;1\n    let q: ref_t&lt;Elem&gt;\n    let e: ref_t&lt;Elem&gt;\n    for (; ;) {\n        let p = list\n        let tail = list = ElemFac.$null()\n        let nmerges = &lt;i32&gt;0  // count number of merges we do in this pass\n        while (p) {\n            nmerges++  // there exists a merge to be done\n            // step `insize` places along from p\n            q = p\n            let psize = 0\n            for (let i = 0; i &lt; insize; i++) {\n                psize++\n                q = q.$$.next\n                if (!q) break\n            }\n            // if q hasn't fallen off end, we have two lists to merge\n            let qsize = insize\n            // now we have two lists; merge them\n            while (psize &gt; 0 || (qsize &gt; 0 &amp;&amp; q)) {\n                // decide whether next element of merge comes from p or q\n                if (psize == 0) {\n                    // p is empty; e must come from q\n                    e = q\n                    q = q.$$.next\n                    qsize--\n                }\n                else if (qsize == 0 || !q) {\n                    // q is empty; e must come from p.\n                    e = p\n                    p = p.$$.next\n                    psize--\n                }\n                else if (cmp(p.$$.data, q.$$.data) &lt;= 0) {\n                    // First element of p is lower (or same); e must come from p.\n                    e = p\n                    p = p.$$.next\n                    psize--\n                }\n                else {\n                    // First element of q is lower; e must come from q.\n                    e = q\n                    q = q.$$.next\n                    qsize--\n                }\n                // add the next element to the merged list\n                if (tail) {\n                    tail.$$.next = e\n                }\n                else {\n                    list = e\n                }\n                tail = e\n            }\n            // now p has stepped `insize` places along, and q has too\n            p = q\n        }\n        tail.$$.next = ElemFac.$null()\n        // If we have done only one merge, we're finished\n        if (nmerges &lt;= 1) break  // allow for nmerges==0, the empty list case\n        // Otherwise repeat, merging lists twice the size\n        insize *= 2\n    }\n    return list\n}\n\nfunction unremove(removed: ref_t&lt;Elem&gt;, modified: ref_t&lt;Elem&gt;) {\n    let tmp = removed.$$.data\n    removed.$$.data = modified.$$.data\n    modified.$$.data = tmp\n    removed.$$.next = modified.$$.next\n    modified.$$.next = removed\n}\n\n// ---- ValComparator ----\n\nimport * as Bench0 from '@em.bench.coremark/StateBench.em'\nimport * as Bench1 from '@em.bench.coremark/MatrixBench.em'\n\nfunction valCalc(pval: ref_t&lt;i16&gt;): i16 {\n    let val = &lt;u16&gt;pval.$$\n    let optype = &lt;u8&gt;(val &gt;&gt; 7) &amp; 1\n    if (optype) return &lt;i16&gt;(val &amp; 0x007f)\n    let flag = val &amp; 0x7\n    let vtype = (val &gt;&gt; 3) &amp; 0xf\n    vtype |= vtype &lt;&lt; 4\n    var ret: u16\n    switch (flag) {\n        case 0:\n            ret = Bench0.run(&lt;i16&gt;vtype)\n            Utils.bindCrc(Bench0.kind(), ret)\n            break\n        case 1:\n            ret = Bench1.run(&lt;i16&gt;vtype)\n            Utils.bindCrc(Bench1.kind(), ret)\n            break\n        default:\n            ret = val\n            break\n    }\n    let newcrc = Crc.add16(&lt;i16&gt;ret, Utils.getCrc(Utils.Kind.FINAL))\n    Utils.setCrc(Utils.Kind.FINAL, Crc.add16(&lt;i16&gt;ret, Utils.getCrc(Utils.Kind.FINAL)))\n    ret &amp;= 0x007f\n    pval.$$ = &lt;i16&gt;((val &amp; 0xff00) | 0x0080 | ret)   // cache the result\n    return &lt;i16&gt;ret\n}\n\nfunction valCompare(a: ref_t&lt;Data&gt;, b: ref_t&lt;Data&gt;): i32 {\n    let val1 = valCalc($ref(a.$$.val))\n    let val2 = valCalc($ref(b.$$.val))\n    return val1 - val2\n}\n</code></pre>"},{"location":"shelf/em.core/em.bench.coremark/MatrixBench/","title":"MatrixBench","text":"em.bench.coremark/MatrixBench.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Crc from '@em.bench.coremark/Crc.em'\nimport * as Utils from '@em.bench.coremark/Utils.em'\n\nexport const memsize = $config&lt;u16&gt;(0)\n\ntype matdat_t = i16\ntype matres_t = i32\n\nconst dimN = $config&lt;u8&gt;(0)\n\nvar matA = $table&lt;matdat_t&gt;('rw')\nvar matB = $table&lt;matdat_t&gt;('rw')\nvar matC = $table&lt;matres_t&gt;('rw')\n\nexport namespace em$meta {\n\n    export function em$construct() {\n        let i = 0\n        let j = 0\n        while (j &lt; memsize.$$) {\n            i += 1\n            j = i * i * 2 * 4\n        }\n        dimN.$$ = i - 1\n        for (let i = 0; i &lt; dimN.$$ * dimN.$$; i++) {\n            matA.$add(0)\n            matB.$add(0)\n            matC.$add(0)\n        }\n    }\n}\n\nexport function kind(): Utils.Kind {\n    return Utils.Kind.MATRIX\n}\n\nexport function print() {\n    prDat(t$`A`, matA.$frame(0))\n    prDat(t$`B`, matB.$frame(0))\n    prRes(t$`C`)\n}\n\nexport function run(arg: arg_t): Utils.sum_t {\n    let crc = &lt;Crc.sum_t&gt;0\n    let val = &lt;matdat_t&gt;arg\n    let clipval = enlarge(val)\n    //\n    addVal(val)\n    mulVal(val)\n    crc = Crc.add16(sumDat(clipval), crc)\n    //\n    mulVec()\n    crc = Crc.add16(sumDat(clipval), crc)\n    //\n    mulMat()\n    crc = Crc.add16(sumDat(clipval), crc)\n    //\n    mulMatBix()\n    crc = Crc.add16(sumDat(clipval), crc)\n    //\n    addVal(-val)\n    return Crc.add16(&lt;i16&gt;crc, Utils.getCrc(Utils.Kind.FINAL))\n}\n\nexport function setup() {\n    let s32 = &lt;u32&gt;Utils.getSeed(1) | (&lt;u32&gt;Utils.getSeed(2) &lt;&lt; 16)\n    let sd = &lt;matdat_t&gt;s32\n    if (sd == 0) sd = 1\n    let order = &lt;matdat_t&gt;1\n    for (let i = 0; i &lt; dimN.$$; i++) {\n        for (let j = 0; j &lt; dimN.$$; j++) {\n            sd = &lt;matdat_t&gt;((order * sd) % 65536)\n            let val = &lt;matdat_t&gt;(sd + order)\n            val = clip(val, false)\n            matB[i * dimN.$$ + j] = val\n            val += order\n            val = clip(val, true)\n            matA[i * dimN.$$ + j] = val\n            order += 1\n        }\n    }\n}\n\n// private\n\nfunction addVal(val: matdat_t) {\n    for (let i = 0; i &lt; dimN.$$; i++) {\n        for (let j = 0; j &lt; dimN.$$; j++) {\n            matA[i * dimN.$$ + j] += val\n        }\n    }\n}\n\nfunction bix(res: matres_t, lower: u8, upper: u8): matres_t {\n    let r = &lt;u32&gt;res\n    let l = &lt;u32&gt;lower\n    let u = &lt;u32&gt;upper\n    return &lt;matres_t&gt;((r &gt;&gt; l) &amp; (~(0xffffffff &lt;&lt; u)))\n}\n\nfunction clip(d: matdat_t, b: bool_t): matdat_t {\n    let x = &lt;u16&gt;d\n    return &lt;matdat_t&gt;(x &amp; (b ? 0x0ff : 0x0ffff))\n}\n\nfunction enlarge(val: matdat_t): matdat_t {\n    let v = &lt;u16&gt;val\n    return &lt;matdat_t&gt;(0xf000 | v)\n}\n\nfunction mulVal(val: matdat_t) {\n    for (let i = 0; i &lt; dimN.$$; i++) {\n        for (let j = 0; j &lt; dimN.$$; j++) {\n            matC[i * dimN.$$ + j] = &lt;matres_t&gt;(matA[i * dimN.$$ + j]) * &lt;matres_t&gt;val\n        }\n    }\n}\n\nfunction mulMat() {\n    for (let i = 0; i &lt; dimN.$$; i++) {\n        for (let j = 0; j &lt; dimN.$$; j++) {\n            matC[i * dimN.$$ + j] = 0\n            for (let k = 0; k &lt; dimN.$$; k++) {\n                matC[i * dimN.$$ + j] += &lt;matres_t&gt;matA[i * dimN.$$ + k] * &lt;matres_t&gt;matB[k * dimN.$$ + j]\n            }\n        }\n    }\n}\n\nfunction mulMatBix() {\n    for (let i = 0; i &lt; dimN.$$; i++) {\n        for (let j = 0; j &lt; dimN.$$; j++) {\n            matC[i * dimN.$$ + j] = 0\n            for (let k = 0; k &lt; dimN.$$; k++) {\n                let tmp = &lt;matres_t&gt;matA[i * dimN.$$ + k] * &lt;matres_t&gt;matB[k * dimN.$$ + j]\n                matC[i * dimN.$$ + j] += bix(tmp, 2, 4) * bix(tmp, 5, 7)\n            }\n        }\n    }\n}\n\nfunction mulVec() {\n    for (let i = 0; i &lt; dimN.$$; i++) {\n        matC[i] = 0\n        for (let j = 0; j &lt; dimN.$$; j++) {\n            matC[i] += &lt;matres_t&gt;matA[i * dimN.$$ + j] * &lt;matres_t&gt;matB[j]\n        }\n    }\n}\n\nfunction prDat(lab: text_t, mat: frame_t&lt;matdat_t&gt;) {\n    printf`\\n%s:\\n    `(lab)\n    for (let i = 0; i &lt; dimN.$$; i++) {\n        let sep = t$``\n        for (let j = 0; j &lt; dimN.$$; j++) {\n            printf`%s%d`(sep, mat[i * dimN.$$ + j])\n            sep = t$`,`\n        }\n        printf`\\n    `()\n    }\n}\n\nfunction prRes(lab: text_t) {\n    printf`\\n%s:\\n    `(lab)\n    for (let i = 0; i &lt; dimN.$$; i++) {\n        let sep = t$``\n        for (let j = 0; j &lt; dimN.$$; j++) {\n            printf`%s%d`(sep, matC[i * dimN.$$ + j])\n            sep = t$`,`\n        }\n        printf`\\n    `()\n    }\n}\n\n\nfunction sumDat(clipval: matdat_t): matdat_t {\n    let cur = &lt;matres_t&gt;0\n    let prev = &lt;matres_t&gt;0\n    let tmp = &lt;matres_t&gt;0\n    let ret = &lt;matdat_t&gt;0\n    for (let i = 0; i &lt; dimN.$$; i++) {\n        for (let j = 0; j &lt; dimN.$$; j++) {\n            cur = matC[i * dimN.$$ + j]\n            tmp += cur\n            if (tmp &gt; clipval) {\n                ret += 10\n                tmp = 0\n            }\n            else {\n                ret += (cur &gt; prev) ? 1 : 0\n            }\n            prev = cur\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"shelf/em.core/em.bench.coremark/SleepyRunnerP/","title":"SleepyRunnerP","text":"em.bench.coremark/SleepyRunnerP.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as CoreBench from '@em.bench.coremark/CoreBench.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\nimport * as TickerMgr from '@em.utils/TickerMgr.em'\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\n\nconst ticker = $config&lt;TickerMgr.Obj&gt;()\n\nexport namespace em$meta {\n\n    export function em$construct() {\n        ticker.$$ = TickerMgr.em$meta.create()\n    }\n}\n\nvar count = 10\n\nexport function em$startup() {\n    CoreBench.setup()\n}\n\nexport function em$run() {\n    ticker.$$.$$.start(TimeTypes.Secs24p8_initMsecs(1_000), $cb(tickCB))\n    FiberMgr.run()\n}\n\nfunction tickCB() {\n    em.$['%%d+']\n    const crc = CoreBench.run(0)\n    em.$['%%d-']\n    printf`crc = %04x\\n`(crc)\n    count -= 1\n    if (count &gt; 0) return\n    ticker.$$.$$.stop()\n    em.halt#f()\n}\n</code></pre>"},{"location":"shelf/em.core/em.bench.coremark/StateBench/","title":"StateBench","text":"em.bench.coremark/StateBench.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Crc from '@em.bench.coremark/Crc.em'\nimport * as Utils from '@em.bench.coremark/Utils.em'\n\nexport const memsize = $config&lt;u16&gt;(0)\n\nconst NUM_STATES = 8\n\nenum State {\n    START, INVALID, S1, S2, INT, FLOAT, EXPONENT, SCIENTIFIC\n}\n\nconst intPat = $table&lt;text_t&gt;('ro')\nconst fltPat = $table&lt;text_t&gt;('ro')\nconst sciPat = $table&lt;text_t&gt;('ro')\nconst errPat = $table&lt;text_t&gt;('ro')\n\nconst intPatLen = $config&lt;u16&gt;(0)\nconst fltPatLen = $config&lt;u16&gt;(0)\nconst sciPatLen = $config&lt;u16&gt;(0)\nconst errPatLen = $config&lt;u16&gt;(0)\n\nconst StateCnt = $array($u32(), NUM_STATES)\n\nvar membuf = $table&lt;u8&gt;('rw')\n\nexport namespace em$meta {\n\n    export function em$init() {\n        intPat.$add(t$`5012`)\n        intPat.$add(t$`1234`)\n        intPat.$add(t$`-874`)\n        intPat.$add(t$`+122`)\n        intPatLen.$$ = intPat[0].$len\n        //\n        fltPat.$add(t$`35.54400`)\n        fltPat.$add(t$`.1234500`)\n        fltPat.$add(t$`-110.700`)\n        fltPat.$add(t$`+0.64400`)\n        fltPatLen.$$ = fltPat[0].$len\n        //\n        sciPat.$add(t$`5.500e+3`)\n        sciPat.$add(t$`-.123e-2`)\n        sciPat.$add(t$`-87e+832`)\n        sciPat.$add(t$`+0.6e-12`)\n        sciPatLen.$$ = sciPat[0].$len\n        //\n        errPat.$add(t$`T0.3e-1F`)\n        errPat.$add(t$`-T.T++Tq`)\n        errPat.$add(t$`1T3.4e4z`)\n        errPat.$add(t$`34.0e-T^`)\n        errPatLen.$$ = errPat[0].$len\n    }\n\n    export function em$construct() {\n        for (let i = 0; i &lt; memsize.$$; i++) membuf.$add(0)\n    }\n}\n\nfunction isDigit(ch: u8): bool_t {\n    return ch &gt;= c$`0` &amp;&amp; ch &lt;= c$`9`\n}\n\nexport function kind(): Utils.Kind {\n    return Utils.Kind.STATE\n}\n\nfunction nextState(pStr: ref_t&lt;ptr_t&lt;u8&gt;&gt;, transCnt: index_t&lt;u32&gt;): State {\n    let str = pStr.$$\n    let state = &lt;State&gt;State.START\n    for (; str.$$ &amp;&amp; state != State.INVALID; str.$inc()) {\n        let ch = str.$$\n        if (ch == c$`,`) {\n            str.$inc()\n            break\n        }\n        switch (state) {\n            case State.START:\n                if (isDigit(ch)) {\n                    state = State.INT\n                }\n                else if (ch == c$`+` || ch == c$`-`) {\n                    state = State.S1\n                }\n                else if (ch == c$`.`) {\n                    state = State.FLOAT\n                }\n                else {\n                    state = State.INVALID\n                    transCnt[ord(State.INVALID)] += 1\n                }\n                transCnt[ord(State.START)] += 1\n                break\n            case State.S1:\n                if (isDigit(ch)) {\n                    state = State.INT\n                    transCnt[ord(State.S1)] += 1\n                }\n                else if (ch == c$`.`) {\n                    state = State.FLOAT\n                    transCnt[ord(State.S1)] += 1\n                }\n                else {\n                    state = State.INVALID\n                    transCnt[ord(State.S1)] += 1\n                }\n                break\n            case State.INT:\n                if (ch == c$`.`) {\n                    state = State.FLOAT\n                    transCnt[ord(State.INT)] += 1\n                }\n                else if (!isDigit(ch)) {\n                    state = State.INVALID\n                    transCnt[ord(State.INT)] += 1\n                }\n                break\n            case State.FLOAT:\n                if (ch == c$`E` || ch == c$`e`) {\n                    state = State.S2\n                    transCnt[ord(State.FLOAT)] += 1\n                }\n                else if (!isDigit(ch)) {\n                    state = State.INVALID\n                    transCnt[ord(State.FLOAT)] += 1\n                }\n                break\n            case State.S2:\n                if (ch == c$`+` || ch == c$`-`) {\n                    state = State.EXPONENT\n                    transCnt[ord(State.S2)] += 1\n                }\n                else {\n                    state = State.INVALID\n                    transCnt[ord(State.S2)] += 1\n                }\n                break\n            case State.EXPONENT:\n                if (isDigit(ch)) {\n                    state = State.SCIENTIFIC\n                    transCnt[ord(State.EXPONENT)] += 1\n                }\n                else {\n                    state = State.INVALID\n                    transCnt[ord(State.EXPONENT)] += 1\n                }\n                break\n            case State.SCIENTIFIC:\n                if (!isDigit(ch)) {\n                    state = State.INVALID\n                    transCnt[ord(State.INVALID)] += 1\n                }\n                break\n        }\n    }\n    pStr.$$ = str\n    return state\n}\n\n\nfunction ord(state: State): u8 {\n    return &lt;u8&gt;state\n}\n\nexport function print() {\n    let p = membuf.$ptr()\n    let cnt = 0\n    printf`\\n%c`(c$`\"`)\n    while (p.$$) {\n        if ((cnt++ % 8) == 0) {\n            printf`\\n    `()\n        }\n        for (; ;) {\n            let c = p.$$\n            p.$inc()\n            if (c == c$`,`) break\n            printf`%c`(c)\n        }\n        printf`, `()\n    }\n    printf`\\n%c, count = %d\\n`(c$`\"`, cnt)\n}\n\nexport function run(arg: i16): Utils.sum_t {\n    if (arg &lt; 0x22) arg = 0x22\n    let finalCnt = StateCnt.$make()\n    let transCnt = StateCnt.$make()\n    for (let i = 0; i &lt; NUM_STATES; i++) finalCnt[i] = transCnt[i] = 0\n    scan(finalCnt, transCnt)\n    scramble(Utils.getSeed(1), arg)\n    scan(finalCnt, transCnt)\n    scramble(Utils.getSeed(2), arg)\n    let crc = Utils.getCrc(Utils.Kind.FINAL)\n    for (let i = 0; i &lt; NUM_STATES; i++) {\n        crc = Crc.addU32(finalCnt[i], crc)\n        crc = Crc.addU32(transCnt[i], crc)\n    }\n    return crc\n}\n\nfunction scan(finalCnt: index_t&lt;u32&gt;, transCnt: index_t&lt;u32&gt;) {\n    let str = membuf.$ptr()\n    let cnt = &lt;u32&gt;0\n    while (str.$$) {\n        let state = nextState($ref(str), transCnt)\n        cnt += 1\n        finalCnt[ord(state)] += 1\n    }\n}\n\nfunction scramble(seed: Utils.seed_t, step: u32) {\n    for (let idx = 0; idx &lt; memsize.$$; idx += step) {\n        if (membuf[idx] != c$`,`) membuf[idx] ^= &lt;u8&gt;seed\n    }\n}\n\nexport function setup() {\n    let seed = Utils.getSeed(1)\n    let p = membuf.$ptr()\n    let total = 0\n    let pat = t$``\n    let plen = 0\n    while ((total + plen + 1) &lt; (memsize.$$ - 1)) {\n        if (plen) {\n            for (let i = 0; i &lt; plen; i++) {\n                p.$$ = pat[i]\n                p.$inc()\n            }\n            p.$$ = c$`,`\n            p.$inc()\n            total += plen + 1\n        }\n        switch (++seed &amp; 0x7) {\n            case 0:\n            case 1:\n            case 2:\n                pat = intPat[(seed &gt;&gt; 3) &amp; 0x3]\n                plen = intPatLen.$$\n                break\n            case 3:\n            case 4:\n                pat = fltPat[(seed &gt;&gt; 3) &amp; 0x3]\n                plen = fltPatLen.$$\n                break\n            case 5:\n            case 6:\n                pat = sciPat[(seed &gt;&gt; 3) &amp; 0x3]\n                plen = sciPatLen.$$\n                break\n            case 7:\n                pat = errPat[(seed &gt;&gt; 3) &amp; 0x3]\n                plen = errPatLen.$$\n                break\n        }\n    }\n}\n</code></pre>"},{"location":"shelf/em.core/em.bench.coremark/Utils/","title":"Utils","text":"em.bench.coremark/Utils.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nexport const NUM_SEEDS = 5\n\nexport enum Kind {\n    FINAL, LIST, MATRIX, STATE, ZZZ_\n}\n\nexport type seed_t = em.u16\nexport type sum_t = em.u16\n\nvar crc_tab = $table&lt;sum_t&gt;('rw')\nconst seed_tab = $table&lt;seed_t&gt;('ro')\n\nexport namespace em$meta {\n\n    export function em$init() {\n        for (let i = Kind.FINAL; i &lt; Kind.ZZZ_; i++) crc_tab.$add(0)\n        for (let i = 0; i &lt; NUM_SEEDS; i++) seed_tab.$add(0)\n    }\n\n    export function bindSeed(idx: u8, val: seed_t) {\n        seed_tab[idx - 1] = val\n    }\n}\n\nexport function bindCrc(kind: Kind, crc: sum_t) {\n    if (crc_tab[kind] == 0) crc_tab[kind] = crc\n}\n\nexport function getCrc(kind: Kind): sum_t {\n    return crc_tab[kind]\n}\n\nexport function getSeed(idx: u8): seed_t {\n    let seed: volatile_t&lt;seed_t&gt; = seed_tab[idx - 1]\n    return seed\n}\n\nexport function setCrc(kind: Kind, crc: sum_t) {\n    crc_tab[kind] = crc\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/","title":"Index","text":""},{"location":"shelf/em.core/em.examples.basic/#bundleemexamplesbasic","title":"<code>bundle</code> <code>em.examples.basic</code>","text":""},{"location":"shelf/em.core/em.examples.basic/Ex00_EmptyP/","title":"Ex00_EmptyP","text":"em.examples.basic/Ex00_EmptyP.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nexport function em$run() {\n    em.halt#f()\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex01_HelloP/","title":"Ex01_HelloP","text":"em.examples.basic/Ex01_HelloP.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nexport function em$run() {\n    printf`hello world\\n`()\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex02_BlinkerP/","title":"Ex02_BlinkerP","text":"em.examples.basic/Ex02_BlinkerP.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\n\nexport const AppLed = $delegate(BoardC.AppLed)\n\nexport function em$run() {\n    AppLed.$$.on()\n    for (let i = 0; i &lt; 10; i++) {\n        Common.BusyWait.$$.wait(500_000)\n        AppLed.$$.toggle()\n    }\n    AppLed.$$.off()\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex03_DebugP/","title":"Ex03_DebugP","text":"em.examples.basic/Ex03_DebugP.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\n\nexport const AppLed = $delegate(BoardC.AppLed)\n\nconst dbg_flag = $config&lt;bool_t&gt;(true)\nconst min_cnt = $config&lt;u16&gt;(1000)\nconst max_cnt = $config&lt;u16&gt;(1020)\n\nexport function em$run() {\n    AppLed.$$.on()\n    for (let cnt = min_cnt.$$; cnt &lt; max_cnt.$$; cnt++) {\n        em.$['%%d+']\n        Common.BusyWait.$$.wait(500_000)\n        em.$['%%d-']\n        AppLed.$$.toggle()\n        if (!dbg_flag.$$) continue\n        if (cnt &gt; (min_cnt.$$ + max_cnt.$$) / 2) em.halt#f()\n        let bits11 = &lt;u8&gt;(cnt &amp; 0x3)\n        em.$['%%c:'](bits11)\n        em.$['%%&gt;'](bits11)\n        printf`cnt = %d (0x%04x), bits11 = %d\\n`(cnt, cnt, bits11)\n    }\n    AppLed.$$.off()\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex04_FiberP/","title":"Ex04_FiberP","text":"em.examples.basic/Ex04_FiberP.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\n\nexport const AppLed = $delegate(BoardC.AppLed)\n\nlet blinkF = $config&lt;FiberMgr.Obj&gt;()\n\nexport namespace em$meta {\n    export function em$construct() {\n        blinkF.$$ = FiberMgr.em$meta.create($cb(blinkFB))\n    }\n}\n\nlet count = &lt;u8&gt;5\n\nexport function em$run() {\n    blinkF.$$.$$.post()\n    FiberMgr.run()\n}\n\nfunction blinkFB(a: arg_t) {\n    em.$['%%d']\n    if (--count == 0) em.halt#f()\n    AppLed.$$.on()\n    Common.BusyWait.$$.wait(250_000)\n    AppLed.$$.off()\n    Common.BusyWait.$$.wait(250_000)\n    blinkF.$$.$$.post()\n\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex05_Button1P/","title":"Ex05_Button1P","text":"em.examples.basic/Ex05_Button1P.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\n\nexport const AppButEdge = $delegate(BoardC.AppButEdge)\nexport const AppLed = $delegate(BoardC.AppLed)\n\nexport namespace em$meta {\n    export function em$construct() {\n        AppButEdge.$$.em$meta.setDetectHandler($cb(handler))\n    }\n}\n\nexport function em$startup() {\n    AppButEdge.$$.init(true)\n    AppButEdge.$$.setDetectFalling()\n}\n\nexport function em$run() {\n    Common.GlobalInterrupts.$$.enable()\n    while (true) {\n        AppButEdge.$$.enableDetect()\n        Common.Idle.$$.exec()\n    }\n}\n\nfunction handler() {\n    em.$['%%c']\n    AppButEdge.$$.clearDetect()\n    AppLed.$$.on()\n    Common.BusyWait.$$.wait(5_000)\n    AppLed.$$.off()\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex06_Button2P/","title":"Ex06_Button2P","text":"em.examples.basic/Ex06_Button2P.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\n\nexport const AppButEdge = $delegate(BoardC.AppButEdge)\nexport const AppLed = $delegate(BoardC.AppLed)\n\nlet blinkF = $config&lt;FiberMgr.Obj&gt;()\n\nexport namespace em$meta {\n    export function em$construct() {\n        AppButEdge.$$.em$meta.setDetectHandler($cb(handler))\n        blinkF.$$ = FiberMgr.em$meta.create($cb(blinkFB))\n    }\n}\n\nexport function em$startup() {\n    AppButEdge.$$.init(true)\n    AppButEdge.$$.setDetectFalling()\n}\n\nexport function em$run() {\n    AppButEdge.$$.enableDetect()\n    FiberMgr.run()\n}\n\nfunction blinkFB(a: arg_t) {\n    em.$['%%d']\n    AppLed.$$.on()\n    Common.BusyWait.$$.wait(5_000)\n    AppLed.$$.off()\n    AppButEdge.$$.enableDetect()\n}\n\n\nfunction handler() {\n    em.$['%%c']\n    AppButEdge.$$.clearDetect()\n    blinkF.$$.$$.post()\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex07_Button3P/","title":"Ex07_Button3P","text":"em.examples.basic/Ex07_Button3P.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\n\nexport const AppBut = $delegate(BoardC.AppBut)\nexport const AppLed = $delegate(BoardC.AppLed)\nexport const SysLed = $delegate(BoardC.SysLed)\n\nexport function em$run() {\n    AppBut.$$.onPressed($cb(onPressedH), 100, 4000)\n    FiberMgr.run()\n}\n\nfunction onPressedH() {\n    em.$['%%c']\n    if (AppBut.$$.isPressed()) {\n        SysLed.$$.on()\n        Common.BusyWait.$$.wait(40_000)\n        SysLed.$$.off()\n    }\n    else {\n        AppLed.$$.on()\n        Common.BusyWait.$$.wait(5_000)\n        AppLed.$$.off()\n    }\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex08_OneShot1P/","title":"Ex08_OneShot1P","text":"em.examples.basic/Ex08_OneShot1P.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\n\nexport const AppLed = $delegate(BoardC.AppLed)\nexport const OneShot = $delegate(BoardC.OneShot)\n\nvar active_flag = false\n\nexport function em$run() {\n    Common.GlobalInterrupts.$$.enable()\n    for (let i = 0; i &lt; 5; i++) {\n        em.$['%%d']\n        AppLed.$$.on()\n        Common.BusyWait.$$.wait(5_000)\n        AppLed.$$.off()\n        active_flag = true\n        OneShot.$$.enable(100, $cb(handler), 0)\n        while (active_flag) Common.Idle.$$.exec()\n    }\n}\n\nfunction handler(arg: arg_t) {\n    em.$['%%c']\n    active_flag = false\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex09_OneShot2P/","title":"Ex09_OneShot2P","text":"em.examples.basic/Ex09_OneShot2P.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\n\nexport const AppLed = $delegate(BoardC.AppLed)\nexport const OneShot = $delegate(BoardC.OneShot)\n\nlet blinkF = $config&lt;FiberMgr.Obj&gt;()\n\nexport namespace em$meta {\n    export function em$construct() {\n        blinkF.$$ = FiberMgr.em$meta.create($cb(blinkFB))\n    }\n}\n\nvar count = 5\n\nexport function em$run() {\n    blinkF.$$.$$.post()\n    FiberMgr.run()\n}\n\nfunction blinkFB(a: arg_t) {\n    em.$['%%d']\n    if (--count == 0) em.halt#f()\n    AppLed.$$.on()\n    Common.BusyWait.$$.wait(5_000)\n    AppLed.$$.off()\n    OneShot.$$.enable(100, $cb(handler), 0)\n}\n\nfunction handler(arg: arg_t) {\n    em.$['%%c']\n    blinkF.$$.$$.post()\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex10_PollerP/","title":"Ex10_PollerP","text":"em.examples.basic/Ex10_PollerP.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\nimport * as Poller from '@em.mcu/Poller.em'\n\nexport const AppLed = $delegate(BoardC.AppLed)\n\nexport function em$run() {\n    Common.GlobalInterrupts.$$.enable()\n    for (let i = 0; i &lt; 5; i++) {\n        Poller.upause(100_000) // 100ms\n        AppLed.$$.wink(5) // 5ms\n    }\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex11_Alarm1P/","title":"Ex11_Alarm1P","text":"em.examples.basic/Ex11_Alarm1P.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as AlarmMgr from '@em.utils/AlarmMgr.em'\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\n\nexport const AppLed = $delegate(BoardC.AppLed)\n\nlet alarm = $config&lt;AlarmMgr.Obj&gt;()\nlet blinkF = $config&lt;FiberMgr.Obj&gt;()\n\nexport namespace em$meta {\n    export function em$construct() {\n        blinkF.$$ = FiberMgr.em$meta.create($cb(blinkFB))\n        alarm.$$ = AlarmMgr.em$meta.create(blinkF.$$)\n    }\n}\n\nvar counter = &lt;u32&gt;0\n\nexport function em$run() {\n    blinkF.$$.$$.post()\n    FiberMgr.run()\n}\n\nfunction blinkFB(a: arg_t) {\n    em.$['%%c']\n    AppLed.$$.wink(100)  // 100 ms\n    counter += 1\n    let msecs = (counter &amp; 0x1) != 0 ? 2_000 : 750\n    alarm.$$.$$.wakeup(TimeTypes.Secs24p8_initMsecs(msecs))\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex12_Alarm2P/","title":"Ex12_Alarm2P","text":"em.examples.basic/Ex12_Alarm2P.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as AlarmMgr from '@em.utils/AlarmMgr.em'\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\n\nexport const AppLed = $delegate(BoardC.AppLed)\n\nlet alarm = $config&lt;AlarmMgr.Obj&gt;()\nlet blinkF = $config&lt;FiberMgr.Obj&gt;()\n\nexport namespace em$meta {\n    export function em$construct() {\n        blinkF.$$ = FiberMgr.em$meta.create($cb(blinkFB))\n        alarm.$$ = AlarmMgr.em$meta.create(blinkF.$$)\n    }\n}\n\nvar counter = &lt;u32&gt;0\n\nexport function em$run() {\n    blinkF.$$.$$.post()\n    FiberMgr.run()\n}\n\nfunction blinkFB(a: arg_t) {\n    em.$['%%c']\n    counter += 1\n    let msecs = (counter &amp; 0x1) != 0 ? 100 : 5\n    AppLed.$$.wink(msecs)\n    alarm.$$.$$.wakeupAligned(TimeTypes.Secs24p8_initMsecs(1_500))\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.basic/Ex13_TickerP/","title":"Ex13_TickerP","text":"em.examples.basic/Ex13_TickerP.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\nimport * as TickerMgr from '@em.utils/TickerMgr.em'\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\n\nexport const AppLed = $delegate(BoardC.AppLed)\nexport const SysLed = $delegate(BoardC.SysLed)\n\nlet app_ticker = $config&lt;TickerMgr.Obj&gt;()\nlet sys_ticker = $config&lt;TickerMgr.Obj&gt;()\n\nexport namespace em$meta {\n    export function em$construct() {\n        app_ticker.$$ = TickerMgr.em$meta.create()\n        sys_ticker.$$ = TickerMgr.em$meta.create()\n    }\n}\n\nexport function em$run() {\n    app_ticker.$$.$$.start(TimeTypes.Secs24p8_initMsecs(1_000), $cb(appTickCb))\n    sys_ticker.$$.$$.start(TimeTypes.Secs24p8_initMsecs(1_500), $cb(sysTickCb))\n    FiberMgr.run()\n}\n\nfunction appTickCb() {\n    em.$['%%c']\n    AppLed.$$.wink(100)\n}\n\nfunction sysTickCb() {\n    em.$['%%d']\n    SysLed.$$.wink(100)\n}\n</code></pre>"},{"location":"shelf/em.core/em.examples.combo/","title":"Index","text":""},{"location":"shelf/em.core/em.examples.combo/#bundleemexamplescombo","title":"<code>bundle</code> <code>em.examples.combo</code>","text":""},{"location":"shelf/em.core/em.examples.combo/Ex01_TickerP/","title":"Ex01_TickerP","text":"em.examples.combo/Ex01_TickerP.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BoardC from '@$distro/BoardC.em'\nimport * as Common from '@em.mcu/Common.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\nimport * as TickerMgr from '@em.utils/TickerMgr.em'\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\n\n// app settings\nconst sysLedPeriodMs = 1500\nconst appLedPeriodMs = 2000\nconst printPeriodMs = 5000\nconst minPressTimeMs = 10\nconst maxPressTimeMs = 2000\nconst maxDividedBy = 8\n\n// app resources\nconst AppLed = $delegate(BoardC.AppLed)\nconst AppBut = $delegate(BoardC.AppBut)\nconst SysLed = $delegate(BoardC.SysLed)\nconst AppTicker = $config&lt;TickerMgr.Obj&gt;()\nconst SysTicker = $config&lt;TickerMgr.Obj&gt;()\nconst PrintTicker = $config&lt;TickerMgr.Obj&gt;()\n\n// initial state vector\nlet dividedBy: u32 = 1\nlet sysCount: u32 = 0\nlet appCount: u32 = 0\nlet lastAppCount: u32 = 0\nlet lastSysCount: u32 = 0\nlet printCount: u32 = 0\nlet expectedAppCount: u32\nlet expectedSysCount: u32\nlet totalErrors: u32 = 0\nlet printsAfterRateChange: u32 = 0\n\nexport namespace em$meta {\n    export function em$construct() {\n        AppTicker.$$ = TickerMgr.em$meta.create()\n        SysTicker.$$ = TickerMgr.em$meta.create()\n        PrintTicker.$$ = TickerMgr.em$meta.create()\n    }\n}\n\nexport function em$run() {\n    printf`\\nEx01_TickerP program startup\\n\\n`()\n    startLedTickers()\n    startPrintTicker()\n    startButton()\n    printStatus()\n    FiberMgr.run()\n}\n\nfunction appTickCb() {\n    appCount += 1\n    em.$['%%c']\n    AppLed.$$.wink(10)\n}\n\nfunction countError(count: u32, expectedCount: u32): bool_t {\n    return (count &lt; expectedCount || count &gt; expectedCount + 1)\n}\n\nfunction onButtonPressed() {\n    if (AppBut.$$.isPressed()) {\n        // a long press (press time &gt; maxPressTimeMs)\n        printf`Long button press: Stopping app/sys tickers\\n`()\n        dividedBy = 0\n        stopLedTickers()\n        lastAppCount = 0\n        lastSysCount = 0\n    } else {\n        // a short press (minPressTimeMs &lt; press time &lt; maxPressTimeMs)\n        dividedBy = (dividedBy &gt;= maxDividedBy || dividedBy &lt; 1) ? 1 : dividedBy * 2\n        printf`Short button press: Setting rate to %dx\\n`(dividedBy)\n        startLedTickers()\n        printStatus()\n    }\n    printsAfterRateChange = 0\n}\n\nfunction printStatus() {\n    printf`Button effects:\\n... short press (&gt;%d ms): cycle through rates (1,2,4,8x)\\n... long press (&gt;%d s): stop led tickers\\n`(\n        minPressTimeMs,\n        maxPressTimeMs/TimeTypes.millisecondsPerSecond\n    )\n    printf`Current rate %dx\\n`(dividedBy)\n    printf`... should print every ~%ds\\n`(printPeriodMs / TimeTypes.millisecondsPerSecond)\n    printf`... app ticks should be %d..%d\\n`(expectedAppCount, expectedAppCount + 1)\n    printf`... sys ticks should be %d..%d\\n`(expectedSysCount, expectedSysCount + 1)\n}\n\nfunction printTickCb() {\n    printCount += 1\n    printsAfterRateChange++\n    const thisAppCount = appCount - lastAppCount\n    const thisSysCount = sysCount - lastSysCount\n    const thisAppError = countError(thisAppCount, expectedAppCount)\n    const thisSysError = countError(thisSysCount, expectedSysCount)\n    if (printsAfterRateChange &gt; 2 &amp;&amp; (thisAppError || thisSysError)) {\n        thisAppError &amp;&amp; totalErrors++\n        thisSysError &amp;&amp; totalErrors++\n    }\n    printTime(Common.Uptimer.$$.read())\n    printf` Print tick {rate: %dx, ticks: {app: %d%s, sys: %d%s}, errors: %d}\\n`(\n        dividedBy,\n        thisAppCount,\n        thisAppError ? t$`*` : t$``,\n        thisSysCount,\n        thisSysError ? t$`*` : t$``,\n        totalErrors\n    )\n    if (dividedBy &gt; 0 &amp;&amp; lastSysCount &gt; 0 &amp;&amp; lastSysCount == sysCount) {\n        printf`No sys ticks detected since last print\\n`()\n        em.halt#f()\n    }\n    if (dividedBy &gt; 0 &amp;&amp; lastAppCount &gt; 0 &amp;&amp; lastAppCount == appCount) {\n        printf`No app ticks detected since last print\\n`()\n        em.halt#f()\n    }\n    lastAppCount = appCount\n    lastSysCount = sysCount\n}\n\nfunction printTime(rawTime: TimeTypes.RawTime) {\n    const timeParts = TimeTypes.RawTimeToTimeParts(rawTime)\n    printf`%dT%02d:%02d:%02d.%03d`(\n        timeParts.days,\n        timeParts.hours,\n        timeParts.minutes,\n        timeParts.seconds,\n        timeParts.milliseconds\n    )\n}\n\nfunction startButton() {\n    AppBut.$$.onPressed($cb(onButtonPressed), minPressTimeMs, maxPressTimeMs)\n}\n\nfunction startLedTickers() {\n    AppTicker.$$.$$.start(TimeTypes.Secs24p8_initMsecs(appLedPeriodMs) / dividedBy, $cb(appTickCb))\n    SysTicker.$$.$$.start(TimeTypes.Secs24p8_initMsecs(sysLedPeriodMs) / dividedBy, $cb(sysTickCb))\n    expectedAppCount = dividedBy * printPeriodMs / appLedPeriodMs\n    expectedSysCount = dividedBy * printPeriodMs / sysLedPeriodMs\n}\n\nfunction startPrintTicker() {\n    PrintTicker.$$.$$.start(TimeTypes.Secs24p8_initMsecs(printPeriodMs), $cb(printTickCb))\n}\n\nfunction stopLedTickers() {\n    AppTicker.$$.$$.stop()\n    SysTicker.$$.$$.stop()\n    expectedAppCount = 0\n    expectedSysCount = 0\n}\n\nfunction sysTickCb() {\n    sysCount += 1\n    em.$['%%d']\n    SysLed.$$.wink(10)\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/","title":"Index","text":""},{"location":"shelf/em.core/em.hal/#bundleemhal","title":"<code>bundle</code> <code>em.hal</code>","text":""},{"location":"shelf/em.core/em.hal/BusyWaitI/","title":"BusyWaitI","text":"em.hal/BusyWaitI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport interface $I {\n    wait(usecs: u32): void\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/ButtonI/","title":"ButtonI","text":"em.hal/ButtonI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport type Handler = cb_t&lt;[]&gt;\n\nexport interface $I {\n    isPressed(): bool_t\n    onPressed(handler: Handler, min_dur_ms: u16, max_dur_ms: u16): void\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/ConsoleUartI/","title":"ConsoleUartI","text":"em.hal/ConsoleUartI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport interface $I {\n    flush(): void\n    put(data: u8): void\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/EdgeI/","title":"EdgeI","text":"em.hal/EdgeI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport type Handler = cb_t&lt;[]&gt;\n\nexport interface em$meta {\n    setDetectHandler(h: Handler): void\n}\n\nexport interface $I {\n    em$meta: em$meta\n    clearDetect(): void\n    disableDetect(): void\n    enableDetect(): void\n    getState(): bool_t\n    init(pullup: bool_t): void\n    setDetectFalling(): void\n    setDetectRising(): void\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/GlobalInterruptsI/","title":"GlobalInterruptsI","text":"em.hal/GlobalInterruptsI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport type Key = u32\n\nexport interface $I {\n    disable(): Key\n    enable(): void\n    isEnabled(): bool_t\n    restore(key: Key): void\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/GpioI/","title":"GpioI","text":"em.hal/GpioI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport namespace em$meta {\n    export declare function pinId(): i16\n}\n\nexport interface $I {\n    clear(): void\n    functionSelect(select: u8): void\n    get(): bool_t\n    isInput(): bool_t\n    isOutput(): bool_t\n    makeInput(): void\n    makeOutput(): void\n    pinId(): i16\n    reset(): void\n    set(): void\n    setInternalPulldown(enable: bool_t): void\n    setInternalPullup(enable: bool_t): void\n    toggle(): void\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/IdleI/","title":"IdleI","text":"em.hal/IdleI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport interface $I {\n    exec: () =&gt; void\n    wakeup: () =&gt; void\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/LedI/","title":"LedI","text":"em.hal/LedI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport interface $I {\n    off(): void\n    on(): void\n    toggle(): void\n    wink(msecs: u32): void\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/McuI/","title":"McuI","text":"em.hal/McuI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport interface $I {\n    startup(): void\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/OneShotI/","title":"OneShotI","text":"em.hal/OneShotI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport type Handler = cb_t&lt;[arg_t]&gt;\n\nexport interface $I {\n    disable(): void\n    enable(msecs: u32, handler: Handler, arg: arg_t): void\n    uenable(usecs: u32, handler: Handler, arg: arg_t): void\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/UptimerI/","title":"UptimerI","text":"em.hal/UptimerI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\n\nexport interface $I {\n    read(): TimeTypes.RawTime\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/UsCounterI/","title":"UsCounterI","text":"em.hal/UsCounterI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nexport interface $I {\n    set(time_us: u32): void\n    spin(): void\n    start(): void\n    stop(): u32\n}\n</code></pre>"},{"location":"shelf/em.core/em.hal/WakeupTimerI/","title":"WakeupTimerI","text":"em.hal/WakeupTimerI.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('INTERFACE')\n\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\n\nexport type Handler = cb_t&lt;[]&gt;\nexport type Secs24p8 = TimeTypes.Secs24p8\nexport type Thresh = u32\n\nexport interface $I {\n    disable(): void\n    enable(thresh: Thresh, handler: Handler): void\n    secsAligned(secs: Secs24p8): Secs24p8\n    secsToThresh(secs: Secs24p8): Thresh\n}\n</code></pre>"},{"location":"shelf/em.core/em.lang/","title":"Index","text":""},{"location":"shelf/em.core/em.lang/#bundleemlang","title":"<code>bundle</code> <code>em.lang</code>","text":""},{"location":"shelf/em.core/em.lang/Console/","title":"Console","text":"em.lang/Console.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Common from '@em.mcu/Common.em'\n\nexport function putbuf(buf: frame_t&lt;u8&gt;) {\n    for (let p of buf) putch(p.$$)\n}\n\nexport function putch(ch: u8) {\n    Common.ConsoleUart.$$.put(ch)\n}\n\nexport function puts(sp: ptr_t&lt;u8&gt;) {\n    while (sp.$$) {\n        putch(sp.$$)\n        sp.$inc()\n    }\n}\n\nexport function wrC(data: u8) {\n    putch(data)\n}\n\nexport function wrU8(data: u8) {\n    putch(0x81)\n    putch(data)\n}\n\nexport function wrU16(data: u16) {\n    putch(0x82)\n    let b = &lt;u8&gt;((data &gt;&gt; 8) &amp; 0xFF)\n    putch(b)\n    b = &lt;u8&gt;((data &gt;&gt; 0) &amp; 0xFF)\n    putch(b)\n}\n\nexport function wrU32(data: u32) {\n    putch(0x84)\n    let b = &lt;u8&gt;((data &gt;&gt; 24) &amp; 0xFF)\n    putch(b)\n    b = &lt;u8&gt;((data &gt;&gt; 16) &amp; 0xFF)\n    putch(b)\n    b = &lt;u8&gt;((data &gt;&gt; 8) &amp; 0xFF)\n    putch(b)\n    b = &lt;u8&gt;((data &gt;&gt; 0) &amp; 0xFF)\n    putch(b)\n}\n\n// private\n\ne$`static inline void wr(em::u8 data) { wrU8(data); }`\ne$`static inline void wr(em::i8 data) { wrU8((em::u8)data); }`\ne$`static inline void wr(em::u16 data) { wrU16(data); }`\ne$`static inline void wr(em::i16 data) { wrU16((em::u16)data); }`\ne$`static inline void wr(em::u32 data) { wrU32(data); }`\ne$`static inline void wr(em::i32 data) { wrU32((em::u32)data); }`\n\nconst Args = $array($u32(), 6)\nconst NumBuf = $array($u8(), 10)\n\nfunction c2d(ch: u8): u8 { return ch - c$`0` }\n\nfunction formatNum(buf: frame_t&lt;u8&gt;, num: u32, base: u8, width: i8, pad: u8): frame_t&lt;u8&gt; {\n    let HEXDIGS = t$`0123456789ABCDEF`\n    let idx = buf.$len\n    for (; ;) {\n        width -= 1\n        idx -= 1\n        buf[idx] = HEXDIGS[(num % base)]\n        num /= base\n        if (num == 0) break\n    }\n    while (width &gt; 0) {\n        width -= 1\n        idx -= 1\n        buf[idx] = pad\n    }\n    return buf.$frame(idx, 0)\n}\n\nfunction isDigit(ch: u8): bool_t {\n    return ch &gt;= c$`0` &amp;&amp; ch &lt;= c$`9`\n}\n\nexport function print(fmt: text_t, a1: arg_t = 0, a2: arg_t = 0, a3: arg_t = 0, a4: arg_t = 0, a5: arg_t = 0, a6: arg_t = 0) {\n    let args = Args.$make()\n    let num_buf = NumBuf.$make()\n    args[0] = &lt;u32&gt;a1\n    args[1] = &lt;u32&gt;a2\n    args[2] = &lt;u32&gt;a3\n    args[3] = &lt;u32&gt;a4\n    args[4] = &lt;u32&gt;a5\n    args[5] = &lt;u32&gt;a6\n    let argp = args.$ptr()\n    let idx = 0\n    while (idx &lt; fmt.$len) {\n        let width = 0\n        let pad = c$` `\n        let ch = fmt[idx++]\n        if (ch != c$`%`) {\n            putch(ch)\n            continue\n        }\n        ch = fmt[idx++]\n        if (ch == c$`0`) {\n            pad = ch\n            ch = fmt[idx++]\n        }\n        while (isDigit(ch)) {\n            width = width * 10 + c2d(ch)\n            ch = fmt[idx++]\n        }\n        if (ch == c$`d`) {\n            let dn = &lt;i32&gt;argp.$$\n            argp.$inc()\n            if (dn &lt; 0) {\n                putch(c$`-`)\n                dn = -dn\n            }\n            let nb = formatNum(num_buf, &lt;u32&gt;dn, 10, width, pad)\n            putbuf(nb)\n        }\n        else if (ch == c$`x`) {\n            let xn = &lt;u32&gt;argp.$$\n            argp.$inc()\n            let nb = formatNum(num_buf, xn, 16, width, pad)\n            putbuf(nb)\n        }\n        else if (ch == c$`c`) {\n            let cn = argp.$$\n            argp.$inc()\n            putch(cn)\n        }\n        else if (ch == c$`s`) {\n            let sp = &lt;ptr_t&lt;u8&gt;&gt;&lt;unknown&gt;argp.$$\n            argp.$inc()\n            puts(sp)\n        }\n        else {\n            putch(ch)\n        }\n    }\n}\n</code></pre>"},{"location":"shelf/em.core/em.lang/Debug/","title":"Debug","text":"em.lang/Debug.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Common from '@em.mcu/Common.em'\nimport * as GpioI from '@em.hal/GpioI.em'\n\nexport const DbgA = $proxy&lt;GpioI.$I&gt;()\nexport const DbgB = $proxy&lt;GpioI.$I&gt;()\nexport const DbgC = $proxy&lt;GpioI.$I&gt;()\nexport const DbgD = $proxy&lt;GpioI.$I&gt;()\n\nfunction delay() {\n    Common.BusyWait.$$.wait(1)\n}\n\nexport function mark(id: u8, val: u8) {\n    for (; ;) {\n        pulse(id)\n        if (val == 0) break\n        val -= 1\n    }\n}\n\nexport function minus(id: u8) {\n    switch (id) {\n        case 0:\n            DbgA.$$.set()\n            break\n        case 1:\n            DbgB.$$.set()\n            break\n        case 2:\n            DbgC.$$.set()\n            break\n        case 3:\n            DbgD.$$.set()\n            break\n    }\n}\n\nexport function plus(id: u8) {\n    switch (id) {\n        case 0:\n            DbgA.$$.clear()\n            break\n        case 1:\n            DbgB.$$.clear()\n            break\n        case 2:\n            DbgC.$$.clear()\n            break\n        case 3:\n            DbgD.$$.clear()\n            break\n    }\n}\n\nexport function pulse(id: u8) {\n    plus(id)\n    delay()\n    minus(id)\n    delay()\n}\n\nexport function reset() {\n    DbgA.$$.reset()\n    DbgB.$$.reset()\n    DbgC.$$.reset()\n    DbgD.$$.reset()\n}\n\nexport function startup() {\n    DbgA.$$.makeOutput()\n    DbgA.$$.set()\n    DbgB.$$.makeOutput()\n    DbgB.$$.set()\n    DbgC.$$.makeOutput()\n    DbgC.$$.set()\n    DbgD.$$.makeOutput()\n    DbgD.$$.set()\n}\n</code></pre>"},{"location":"shelf/em.core/em.lang/TargC/","title":"TargC","text":"em.lang/TargC.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('COMPOSITE')\n\nexport function em$generate() {\n    let out = $outfile('emscript.hpp')\n    out.addFile('../em.core/em.lang/emscript.hpp')\n    out.close()\n}\n</code></pre>"},{"location":"shelf/em.core/em.mcu/","title":"Index","text":""},{"location":"shelf/em.core/em.mcu/#bundleemmcu","title":"<code>bundle</code> <code>em.mcu</code>","text":""},{"location":"shelf/em.core/em.mcu/Common/","title":"Common","text":"em.mcu/Common.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BusyWaitI from '@em.hal/BusyWaitI.em'\nimport * as ConsoleUartI from '@em.hal/ConsoleUartI.em'\nimport * as GlobalInterruptsI from '@em.hal/GlobalInterruptsI.em'\nimport * as IdleI from '@em.hal/IdleI.em'\nimport * as McuI from '@em.hal/McuI.em'\nimport * as UptimerI from '@em.hal/UptimerI.em'\nimport * as UsCounterI from '@em.hal/UsCounterI.em'\n\nexport const BusyWait = $proxy&lt;BusyWaitI.$I&gt;()\nexport const ConsoleUart = $proxy&lt;ConsoleUartI.$I&gt;()\nexport const GlobalInterrupts = $proxy&lt;GlobalInterruptsI.$I&gt;()\nexport const Idle = $proxy&lt;IdleI.$I&gt;()\nexport const Mcu = $proxy&lt;McuI.$I&gt;()\nexport const Uptimer = $proxy&lt;UptimerI.$I&gt;()\nexport const UsCounter = $proxy&lt;UsCounterI.$I&gt;()\n</code></pre>"},{"location":"shelf/em.core/em.mcu/Poller/","title":"Poller","text":"em.mcu/Poller.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Common from '@em.mcu/Common.em'\nimport * as OneShotI from '@em.hal/OneShotI.em'\n\nexport const OneShot = $proxy&lt;OneShotI.$I&gt;()\n\nvar active_flag = &lt;volatile_t&lt;bool_t&gt;&gt;false\n\nexport function pause(time_ms: u32) {\n    upause(time_ms * 1000)\n}\n\nexport function upause(time_us: u32) {\n    if (time_us == 0) return\n    active_flag = true\n    OneShot.$$.uenable(time_us, $cb(handler), 0)\n    while (active_flag) Common.Idle.$$.exec()\n}\n\nfunction handler(a: arg_t) {\n    active_flag = false\n}\n</code></pre>"},{"location":"shelf/em.core/em.utils/","title":"Index","text":""},{"location":"shelf/em.core/em.utils/#bundleemutils","title":"<code>bundle</code> <code>em.utils</code>","text":""},{"location":"shelf/em.core/em.utils/AlarmMgr/","title":"AlarmMgr","text":"em.utils/AlarmMgr.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\nimport * as WakeupTimerI from '@em.hal/WakeupTimerI.em'\n\nexport const WakeupTimer = $proxy&lt;WakeupTimerI.$I&gt;()\n\nexport type Obj = ref_t&lt;Alarm&gt;\n\ntype Secs24p8 = TimeTypes.Secs24p8\ntype Thresh = WakeupTimerI.Thresh\n\nclass Alarm extends $struct {\n    _fiber: FiberMgr.Obj\n    _thresh: Thresh\n    _dt_secs: Secs24p8\n    cancel: () =&gt; void\n    isActive: () =&gt; bool_t\n    wakeup: (delta: Secs24p8) =&gt; void\n    wakeupAligned: (delta: Secs24p8) =&gt; void\n}\nlet AlarmFac = $factory(Alarm.$make())\n\nexport namespace em$meta {\n\n    export function create(fiber: FiberMgr.Obj): Obj {\n        let alarm = AlarmFac.$create()\n        alarm.$$._fiber = fiber\n        return alarm\n    }\n}\n\nvar cur_alarm = &lt;Obj&gt;$null\n\nfunction dispatch(delta: Secs24p8) {\n    let max_dt_secs = ~(&lt;Secs24p8&gt;0)\n    let nxt_alarm = &lt;Obj&gt;$null\n    for (let i = 0; i &lt; AlarmFac.$len; i++) {\n        let a = $ref(AlarmFac[i])\n        if (a.$$._dt_secs == 0) continue // inactive\n        a.$$._dt_secs -= (delta &gt; a.$$._dt_secs) ? a.$$._dt_secs : delta\n        if (a.$$._dt_secs == 0) {\n            cur_alarm = $null // updated after loop\n            a.$$._fiber.$$.post() // ring the alarm\n            continue // becomes inactive\n        }\n        if (a.$$._dt_secs &lt; max_dt_secs) {\n            nxt_alarm = a\n            max_dt_secs = a.$$._dt_secs\n        }\n    }\n    if (nxt_alarm != $null) {\n        cur_alarm = nxt_alarm\n        WakeupTimer.$$.enable(cur_alarm.$$._thresh, $cb(wakeupHandler))\n    }\n    if (cur_alarm == $null) WakeupTimer.$$.disable()\n}\n\nfunction setup(alarm: Obj, delta: Secs24p8) {\n    alarm.$$._thresh = WakeupTimer.$$.secsToThresh(delta)\n    alarm.$$._dt_secs = delta\n    dispatch(0)\n}\n\nfunction wakeupHandler() {\n    dispatch(cur_alarm.$$._dt_secs)\n}\n\nfunction Alarm__cancel(self: Obj) {\n    self.$$._dt_secs = 0\n    dispatch(0)\n}\n\nfunction Alarm__isActive(self: Obj): bool_t {\n    return self.$$._dt_secs != 0\n}\n\nfunction Alarm__wakeup(self: Obj, delta: Secs24p8) {\n    setup(self, delta)\n}\n\nfunction Alarm__wakeupAligned(self: Obj, delta: Secs24p8) {\n    setup(self, WakeupTimer.$$.secsAligned(delta))\n}\n</code></pre>"},{"location":"shelf/em.core/em.utils/BoardController/","title":"BoardController","text":"em.utils/BoardController.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Common from '@em.mcu/Common.em'\nimport * as LedI from '@em.hal/LedI.em'\n\nexport const Led = $proxy&lt;LedI.$I&gt;()\n\nconst blinkRate = 50000\nconst EOT_BYTE = 0x04\nconst SOT_BYTE = 0x03\nconst SOT_COUNT = 13\n\nexport function em$reset(): void {\n    Common.Mcu.$$.startup()\n}\n\nexport function em$ready(): void {\n    Led.$$.off()\n    blink(2, blinkRate)\n    Common.ConsoleUart.$$.flush()\n    Common.ConsoleUart.$$.put(0x00)\n    Common.ConsoleUart.$$.put(0x00)\n    for (let i = 0; i &lt; SOT_COUNT; i++) {\n        Common.ConsoleUart.$$.put(SOT_BYTE)\n    }\n    Common.ConsoleUart.$$.flush()\n}\n\nexport function em$fail(): void {\n    Common.GlobalInterrupts.$$.disable()\n    while (true) blink(2, blinkRate)\n}\n\nexport function em$halt(): void {\n    Common.GlobalInterrupts.$$.disable()\n    Common.ConsoleUart.$$.put(EOT_BYTE)\n    Common.ConsoleUart.$$.flush()\n    Led.$$.on()\n}\n\nfunction blink(times: u8, usecs: u32): void {\n    for (let i = 0; i &lt; times * 2; i++) {\n        Led.$$.toggle()\n        Common.BusyWait.$$.wait(usecs)\n    }\n}\n</code></pre>"},{"location":"shelf/em.core/em.utils/ButtonT/","title":"ButtonT","text":"em.utils/ButtonT.em<pre><code>import em from '@$$emscript'\nexport const $T = em.$declare('TEMPLATE')\n\nimport * as ButtonI from '@em.hal/ButtonI.em'\nimport * as EdgeI from '@em.hal/EdgeI.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\nimport * as Poller from '@em.mcu/Poller.em'\n\nexport namespace em$template {\n\n    export const $U = em.$declare('MODULE')\n\n    export const Edge = $proxy&lt;EdgeI.$I&gt;()\n\n    export type Handler = ButtonI.Handler\n\n    const debounceF = $config&lt;FiberMgr.Obj&gt;()\n\n    export namespace em$meta {\n\n        export function em$construct() {\n            debounceF.$$ = FiberMgr.em$meta.create($cb(debounceFB))\n            Edge.$$.em$meta.setDetectHandler($cb(buttonHandler))\n        }\n    }\n\n    var cur_fxn = &lt;Handler&gt;$null\n    var cur_dur = 0\n    var cur_max = 0\n    var cur_min = 0\n\n    export function em$startup() {\n        Edge.$$.init(true)\n        Edge.$$.setDetectFalling()\n    }\n\n    function buttonHandler() {\n        Edge.$$.clearDetect()\n        if (cur_fxn != $null) debounceF.$$.$$.post()\n    }\n\n    function debounceFB(a: arg_t) {\n        cur_dur = 0\n        while (true) {\n            Poller.pause(cur_min)\n            if (!isPressed() &amp;&amp; cur_dur == 0) return\n            cur_dur += cur_min\n            if (!isPressed() || cur_dur &gt;= cur_max) break\n        }\n        cur_fxn()\n    }\n\n    export function isPressed(): bool_t {\n        return !Edge.$$.getState()\n    }\n\n    export function onPressed(handler: Handler, min_dur_ms: u16, max_dur_ms: u16) {\n        cur_fxn = handler\n        cur_max = max_dur_ms\n        cur_min = min_dur_ms\n        if (handler == $null) {\n            Edge.$$.disableDetect()\n        }\n        else {\n            Edge.$$.enableDetect()\n        }\n    }\n\n}\n\nexport function $clone() { return { $T, ...em$template } }\n</code></pre>"},{"location":"shelf/em.core/em.utils/FiberMgr/","title":"FiberMgr","text":"em.utils/FiberMgr.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Common from '@em.mcu/Common.em'\n\nexport type Body = cb_t&lt;[arg_t]&gt;\nexport type Obj = ref_t&lt;Fiber&gt;\n\nclass Fiber extends $struct {\n    link: ref_t&lt;Fiber&gt;\n    body: Body\n    arg: arg_t\n    post: () =&gt; void\n}\n\nclass List extends $struct {\n    head: ref_t&lt;Fiber&gt;\n    tail: ref_t&lt;Fiber&gt;\n    empty: () =&gt; bool_t\n    give: (elem: ref_t&lt;Fiber&gt;) =&gt; void\n    take: () =&gt; ref_t&lt;Fiber&gt;\n}\nlet FiberFac = $factory(Fiber.$make())\n\nlet ready_list = List.$make()\n\nexport namespace em$meta {\n\n    export function create(body: Body, arg: arg_t = 0): Obj {\n        let fiber = FiberFac.$create()\n        fiber.$$.body = body\n        fiber.$$.arg = arg\n        return fiber\n    }\n}\n\nfunction dispatch() {\n    while (!ready_list.empty()) {\n        let fiber = ready_list.take()\n        Common.GlobalInterrupts.$$.enable()\n        fiber.$$.body(fiber.$$.arg)\n        Common.GlobalInterrupts.$$.disable()\n    }\n}\n\nexport function run() {\n    Common.Idle.$$.wakeup()\n    Common.GlobalInterrupts.$$.enable()\n    for (; ;) {\n        Common.GlobalInterrupts.$$.disable()\n        dispatch()\n        Common.Idle.$$.exec()\n    }\n}\n\nfunction Fiber__post(self: ref_t&lt;Fiber&gt;): void {\n    let key = Common.GlobalInterrupts.$$.disable()\n    if (self.$$.link == $null) ready_list.give(self)\n    Common.GlobalInterrupts.$$.restore(key)\n}\n\nfunction List__empty(self: ref_t&lt;List&gt;): bool_t {\n    return self.$$.head == $null\n}\n\nfunction List__give(self: ref_t&lt;List&gt;, elem: ref_t&lt;Fiber&gt;): void {\n    if (self.$$.empty()) {\n        self.$$.head = elem\n    }\n    else {\n        self.$$.tail.$$.link = elem\n    }\n    self.$$.tail = elem\n    elem.$$.link = $null\n}\n\nfunction List__take(self: ref_t&lt;List&gt;): ref_t&lt;Fiber&gt; {\n    let e = self.$$.head\n    self.$$.head = e.$$.link\n    e.$$.link = $null\n    if (self.$$.head == $null) self.$$.tail = $null\n    return e\n}\n</code></pre>"},{"location":"shelf/em.core/em.utils/LedT/","title":"LedT","text":"em.utils/LedT.em<pre><code>import em from '@$$emscript'\nexport const $T = em.$declare('TEMPLATE')\n\nimport * as GpioI from '@em.hal/GpioI.em'\n\nimport * as Poller from '@em.mcu/Poller.em'\n\nexport namespace em$template {\n\n    export const $U = em.$declare('MODULE')\n\n    export const Pin = $proxy&lt;GpioI.$I&gt;()\n    export const active_low = $config&lt;bool_t&gt;(false)\n\n    export function em$startup(): void {\n        Pin.$$.makeOutput()\n        off()\n    }\n\n    export function off(): void {\n        if (active_low.$$) { Pin.$$.set() } else { Pin.$$.clear() }\n    }\n\n    export function on(): void {\n        if (active_low.$$) { Pin.$$.clear() } else { Pin.$$.set() }\n    }\n\n    export function toggle(): void {\n        Pin.$$.toggle()\n    }\n\n    export function wink(msecs: u32): void {\n        on()\n        Poller.pause(msecs)\n        off()\n    }\n}\n\nexport function $clone() { return { $T, ...em$template } }\n</code></pre>"},{"location":"shelf/em.core/em.utils/SoftUart/","title":"SoftUart","text":"em.utils/SoftUart.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Common from '@em.mcu/Common.em'\nimport * as GpioI from '@em.hal/GpioI.em'\n\nexport const baud_rate = $config&lt;u32&gt;(57_600)\nexport const TxPin = $proxy&lt;GpioI.$I&gt;()\n\nconst bit_time = $config&lt;u16&gt;()\n\nexport namespace em$meta {\n\n    export function em$construct() {\n        bit_time.$$ = Math.floor(1_000_000 / baud_rate.$$)\n    }\n}\n\nexport function em$startup(): void {\n    TxPin.$$.makeOutput()\n    TxPin.$$.set()\n}\n\nexport function flush(): void {\n}\n\nexport function put(data: u8): void {\n    const bit_cnt = 10\n    var tx_byte: u16 = (data &lt;&lt; 1) | 0x600\n    const key = Common.GlobalInterrupts.$$.disable()\n    for (let i = 0; i &lt; bit_cnt; i++) {\n        Common.UsCounter.$$.set(bit_time.$$)\n        if (tx_byte &amp; 0x1) {\n            TxPin.$$.set()\n        } else {\n            TxPin.$$.clear()\n        }\n        tx_byte &gt;&gt;= 1\n        Common.UsCounter.$$.spin()\n    }\n    TxPin.$$.set()\n    Common.GlobalInterrupts.$$.restore(key)\n}\n</code></pre>"},{"location":"shelf/em.core/em.utils/TickerMgr/","title":"TickerMgr","text":"em.utils/TickerMgr.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as AlarmMgr from '@em.utils/AlarmMgr.em'\nimport * as FiberMgr from '@em.utils/FiberMgr.em'\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\n\nexport type Callback = cb_t&lt;[]&gt;\nexport type Obj = ref_t&lt;Ticker&gt;\n\nclass Ticker extends $struct {\n    _alarm: AlarmMgr.Obj\n    _fiber: FiberMgr.Obj\n    _rate: TimeTypes.Secs24p8\n    _tick_cb: Callback\n    start: (rate: TimeTypes.Secs24p8, tick_cb: Callback) =&gt; void\n    stop: () =&gt; void\n}\nlet TickerFac = $factory(Ticker.$make())\n\nexport namespace em$meta {\n\n    export function create(): Obj {\n        let ticker = TickerFac.$create()\n        let fiber = FiberMgr.em$meta.create($cb(alarmFB), TickerFac.$len - 1)\n        let alarm = AlarmMgr.em$meta.create(fiber)\n        ticker.$$._alarm = alarm\n        ticker.$$._fiber = fiber\n        return ticker\n    }\n}\n\nfunction alarmFB(a: arg_t) {\n    let ticker = $ref(TickerFac[&lt;u16&gt;a])\n    if (ticker.$$._tick_cb == $null) return\n    ticker.$$._tick_cb()\n    ticker.$$._alarm.$$.wakeupAligned(ticker.$$._rate)\n}\n\nfunction Ticker__start(self: Obj, rate: TimeTypes.Secs24p8, tick_cb: Callback) {\n    self.$$._rate = rate\n    self.$$._tick_cb = tick_cb\n    self.$$._alarm.$$.wakeupAligned(rate)\n}\n\nfunction Ticker__stop(self: Obj) {\n    self.$$._alarm.$$.cancel()\n    self.$$._tick_cb = $null\n}\n</code></pre>"},{"location":"shelf/em.core/em.utils/TimeTypes/","title":"TimeTypes","text":"em.utils/TimeTypes.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nexport const hoursPerDay = 24\nexport const minutesPerHour = 60\nexport const secondsPerMinute = 60\nexport const secondsPerHour = minutesPerHour * secondsPerMinute\nexport const secondsPerDay = hoursPerDay * secondsPerHour\nexport const millisecondsPerSecond = 1000\n\nexport class RawTime extends $struct {\n    secs: u32\n    subs: u32\n}\n\nexport class TimeParts extends $struct {\n    days: u32\n    hours: u32\n    minutes: u32\n    seconds: u32\n    milliseconds: u32\n}\n\nexport type Secs24p8 = u32\n\nexport function RawSubsToMsecs(subs: u32): u32 {\n    return ((subs &gt;&gt; 16) * 1000) / 65536\n}\n\nexport function Secs24p8_initMsecs(msecs: u32): Secs24p8 {\n    return (msecs * 32) / 125\n}\n\nexport function Secs24p8_ZERO(): Secs24p8 {\n    return 0\n}\n\nexport function RawTimeToTimeParts(rawTime: RawTime): TimeParts {\n    let timeParts = TimeParts.$make()\n    timeParts.days = rawTime.secs / secondsPerDay\n    timeParts.hours = (rawTime.secs % secondsPerDay) / secondsPerHour\n    timeParts.minutes = (rawTime.secs % secondsPerHour) / secondsPerMinute\n    timeParts.seconds = rawTime.secs % secondsPerMinute\n    timeParts.milliseconds = RawSubsToMsecs(rawTime.subs)\n    return timeParts\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/","title":"Index","text":""},{"location":"shelf/ti.cc23xx/#packageticc23xx","title":"<code>package</code> <code>ti.cc23xx</code>","text":""},{"location":"shelf/ti.cc23xx/ti.distro.cc23xx/","title":"Index","text":""},{"location":"shelf/ti.cc23xx/ti.distro.cc23xx/#bundletidistrocc23xx","title":"<code>bundle</code> <code>ti.distro.cc23xx</code>","text":""},{"location":"shelf/ti.cc23xx/ti.distro.cc23xx/BoardC/","title":"BoardC","text":"ti.distro.cc23xx/BoardC.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('COMPOSITE')\n\nimport * as AlarmMgr from '@em.utils/AlarmMgr.em'\nimport * as BoardController from '@em.utils/BoardController.em'\nimport * as BusyWait from '@ti.mcu.cc23xx/BusyWait.em'\nimport * as ButtonT from '@em.utils/ButtonT.em'\nimport * as Console from '@em.lang/Console.em'\nimport * as Common from '@em.mcu/Common.em'\nimport * as ConsoleUart0 from '@ti.mcu.cc23xx/ConsoleUart0.em'\nimport * as Debug from '@em.lang/Debug.em'\nimport * as EdgeT from '@ti.mcu.cc23xx/EdgeT.em'\nimport * as ExtFlashDisabler from '@ti.mcu.cc23xx/ExtFlashDisabler.em'\nimport * as GlobalInterrupts from '@em.arch.arm/GlobalInterrupts.em'\nimport * as GpioT from '@ti.mcu.cc23xx/GpioT.em'\nimport * as Idle from '@ti.mcu.cc23xx/Idle.em'\nimport * as LedT from '@em.utils/LedT.em'\nimport * as Mcu from '@ti.mcu.cc23xx/Mcu.em'\nimport * as Poller from '@em.mcu/Poller.em'\nimport * as OneShot from '@ti.mcu.cc23xx/OneShotGpt3.em'\nimport * as Uptimer from '@ti.mcu.cc23xx/UptimerRtc.em'\nimport * as UsCounter from '@em.arch.arm/UsCounterSystick.em'\nimport * as WakeupTimer from '@ti.mcu.cc23xx/WakeupTimerRtc.em'\n\nexport { OneShot }\n\nexport const AppBut = $clone(ButtonT)\nexport const AppButEdge = $clone(EdgeT)\nexport const AppButPin = $clone(GpioT)\nexport const AppLed = $clone(LedT)\nexport const AppLedPin = $clone(GpioT)\nexport const AppOutPin = $clone(GpioT)\nexport const DbgA = $clone(GpioT)\nexport const DbgB = $clone(GpioT)\nexport const DbgC = $clone(GpioT)\nexport const DbgD = $clone(GpioT)\nexport const FlashCLK = $clone(GpioT)\nexport const FlashCS = $clone(GpioT)\nexport const FlashPICO = $clone(GpioT)\nexport const FlashPOCI = $clone(GpioT)\nexport const SysLed = $clone(LedT)\nexport const SysLedPin = $clone(GpioT)\n\nexport function em$configure(): void {\n    $using(BoardController)\n    $using(Console)\n    $using(ExtFlashDisabler)\n    AlarmMgr.WakeupTimer.$$ = WakeupTimer\n    AppBut.Edge.$$ = AppButEdge\n    AppButEdge.Pin.$$ = AppButPin\n    AppButEdge.pin_num.$$ = AppButPin.pin_num.$$ = 9\n    AppLed.Pin.$$ = AppLedPin\n    AppLedPin.pin_num.$$ = 15\n    AppOutPin.pin_num.$$ = 20\n    BoardController.Led.$$ = SysLed\n    Common.BusyWait.$$ = BusyWait\n    Common.ConsoleUart.$$ = ConsoleUart0\n    Common.GlobalInterrupts.$$ = GlobalInterrupts\n    Common.Idle.$$ = Idle\n    Common.Mcu.$$ = Mcu\n    Common.Uptimer.$$ = Uptimer\n    Common.UsCounter.$$ = UsCounter\n    ConsoleUart0.TxPin.$$ = AppOutPin\n    DbgA.pin_num.$$ = 23\n    DbgB.pin_num.$$ = 25\n    DbgC.pin_num.$$ = 1\n    DbgD.pin_num.$$ = 2\n    Debug.DbgA.$$ = DbgA\n    Debug.DbgB.$$ = DbgB\n    Debug.DbgC.$$ = DbgC\n    Debug.DbgD.$$ = DbgD\n    ExtFlashDisabler.CLK.$$ = FlashCLK\n    ExtFlashDisabler.CS.$$ = FlashCS\n    ExtFlashDisabler.PICO.$$ = FlashPICO\n    ExtFlashDisabler.POCI.$$ = FlashPOCI\n    FlashCLK.pin_num.$$ = 18\n    FlashCS.pin_num.$$ = 6\n    FlashPICO.pin_num.$$ = 13\n    FlashPOCI.pin_num.$$ = 12\n    Poller.OneShot.$$ = OneShot\n    SysLed.Pin.$$ = SysLedPin\n    SysLedPin.pin_num.$$ = 14\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.distro.cc23xx/BuildC/","title":"BuildC","text":"ti.distro.cc23xx/BuildC.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('COMPOSITE')\n\nimport * as ArmStartupC from '@em.arch.arm/StartupC.em'\nimport * as BoardC from '@ti.distro.cc23xx/BoardC.em'\nimport * as IntrVec from '@em.arch.arm/IntrVec.em'\nimport * as LinkerC from '@ti.distro.cc23xx/LinkerC.em'\nimport * as REGS from '@ti.distro.cc23xx/REGS.em'\nimport * as StartupC from '@ti.distro.cc23xx/StartupC.em'\nimport * as TargC from '@em.lang/TargC.em'\n\nconst nvic_intrs = [\n    'CPUIRQ0',\n    'CPUIRQ1',\n    'CPUIRQ2',\n    'CPUIRQ3',\n    'CPUIRQ4',\n    'GPIO_COMB',\n    'LRFD_IRQ0',\n    'LRFD_IRQ1',\n    'DMA_DONE_COMB',\n    'AES_COMB',\n    'SPI0_COMB',\n    'UART0_COMB',\n    'I2C0_IRQ',\n    'LGPT0_COMB',\n    'LGPT1_COMB',\n    'ADC0_COMB',\n    'CPUIRQ16',\n    'LGPT2_COMB',\n    'LGPT3_COMB',\n]\n\nexport function em$configure() {\n    $using(ArmStartupC)\n    $using(BoardC)\n    $using(IntrVec)\n    $using(LinkerC)\n    $using(REGS)\n    $using(StartupC)\n    $using(TargC)\n    for (let name of nvic_intrs) IntrVec.em$meta.addIntr(name)\n}\n\nexport function em$generate() {\n    const opt = $property('em.build.Optimize', 'Oz')\n    const tools = $property('em.build.ToolsHome', '')\n    const libflav = opt == 'Oz' ? 'small' : 'balanced'\n    let out = $outfile('build.sh', 0o755)\n    out.addFrag(`\n        |-&gt; #!/bin/sh\n        |-&gt; \n        |-&gt; TOOLS=${tools}/segger-arm\n        |-&gt; CC=$TOOLS/bin/segger-cc\n        |-&gt; LD=$TOOLS/gcc/arm-none-eabi/bin/ld\n        |-&gt; OBJCOPY=$TOOLS/gcc/arm-none-eabi/bin/objcopy\n        |-&gt; OBJDUMP=$TOOLS/gcc/arm-none-eabi/bin/objdump\n        |-&gt; \n        |-&gt; OUT=.out\n        |-&gt; \n        |-&gt; rm -rf $OUT\n        |-&gt; mkdir $OUT\n        |-&gt; \n        |-&gt; \n        |-&gt; CFLAGS=\"\\\\\n        |-&gt;     -D__EM_ARCH_arm__ \\\\\n        |-&gt;     -D__EM_BOOT__=0 \\\\\n        |-&gt;     -D__EM_BOOT_FLASH__=0 \\\\\n        |-&gt;     -D__EM_COMPILER_segger__ \\\\\n        |-&gt;     -D__EM_CPU_cortex_m0plus__ \\\\\n        |-&gt;     -D__EM_MCU_null__ \\\\\n        |-&gt;     -D__EM_LANG__=1 \\\\\n        |-&gt;     --std=c++14 \\\\\n        |-&gt;     -triple thumbv6m-none-eabi \\\\\n        |-&gt;     -target-cpu cortex-m0plus \\\\\n        |-&gt;     -ffunction-sections \\\\\n        |-&gt;     -fdata-sections \\\\\n        |-&gt;     -fno-threadsafe-statics \\\\\n        |-&gt;     -Wno-deprecated-register \\\\\n        |-&gt;     -Wno-invalid-noreturn \\\\\n        |-&gt;     -Wno-macro-redefined \\\\\n        |-&gt;     -Wno-switch \\\\\n        |-&gt;     -Wno-uninitialized \\\\\n        |-&gt;     -Wno-c99-designator \\\\\n        |-&gt;     -Wno-c++20-designator \\\\\n        |-&gt;     -Wpointer-to-int-cast \\\\\n        |-&gt;     -target-feature +strict-align -target-feature +soft-float -target-feature +soft-float-abi -msoft-float -target-abi aapcs -mfloat-abi soft -fno-signed-char -fnative-half-type -fnative-half-arguments-and-returns \\\\\n        |-&gt; \"\n        |-&gt; \n        |-&gt; CINCS=\"\\\\\n        |-&gt;     -I . \\\\\n        |-&gt;     -I $TOOLS/include \\\\\n        |-&gt; \"\n        |-&gt; \n        |-&gt; COPTS=\"\\\\\n        |-&gt;     -${opt} \\\\\n        |-&gt; \"\n        |-&gt; \n        |-&gt; LFLAGS=\"\\\\\n        |-&gt;     -eem__start \\\\\n        |-&gt;     -N \\\\\n        |-&gt;     --gc-sections \\\\\n        |-&gt; \"\n        |-&gt; \n        |-&gt; LIBS=\"\n        |-&gt;     $TOOLS/lib/libc_v6m_t_le_eabi_${libflav}.a \\\\\n        |-&gt;     $TOOLS/lib/strops_v6m_t_le_eabi_${libflav}.a \\\\\n        |-&gt; \"\n        |-&gt; \n        |-&gt; $CC -c $CFLAGS $CINCS $COPTS -x c++ main.cpp -o $OUT/main.obj\n        |-&gt; $LD $LFLAGS -Map=$OUT/main.map -T linkcmd.ld -o $OUT/main.out $OUT/main.obj $LIBS\n        |-&gt; $OBJCOPY -O ihex $OUT/main.out $OUT/main.out.hex\n        |-&gt; $OBJDUMP -h -d --demangle $OUT/main.out &gt;$OUT/main.out.dis\n        |-&gt; $OBJDUMP -t --demangle $OUT/main.out | tail -n +5 | sed -e 's/[FO] /  /' | sed -e 's/df /   /' &gt;$OUT/main.out.sym\n        |-&gt; sort -k1 $OUT/main.out.sym &gt; $OUT/main.out.syma\n        |-&gt; sort -k5 $OUT/main.out.sym &gt; $OUT/main.out.symn\n        |-&gt; $OBJDUMP -h $OUT/main.out\n\n    `)\n    out.close()\n    //\n    const dslite = process.platform === 'win32'\n        ? 'dslite.bat'\n        : process.platform === 'linux'\n            ? 'dslite-Cortex_M0P.sh'\n            : 'dslite.sh'\n    out = $outfile('load.sh', 0o755)\n    out.addText(`${tools}/ti-uniflash/${dslite} -c ../ti.cc23xx/ti.distro.cc23xx/CC2340R5.ccxml .out/main.out\\n`)\n    out.close()\n}\n\ndeclare global {\n    const $R: typeof REGS\n}\n\nObject.assign(globalThis, {\n    $R: REGS\n})\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.distro.cc23xx/LinkerC/","title":"LinkerC","text":"ti.distro.cc23xx/LinkerC.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('COMPOSITE')\n\n\nexport function em$generate() {\n    let out = $outfile('linkcmd.ld')\n    const use_sram = $property('em.build.BootFlash', false)\n    if (!use_sram) {\n        out.addFrag(`\n            |-&gt; MEMORY {\n            |-&gt;     DMEM : ORIGIN = 0x20000000, LENGTH = 0x00009000\n            |-&gt;     IMEM : ORIGIN = 0x00000000, LENGTH = 0x00080000\n            |-&gt;     FLASH_CCFG : ORIGIN = 0x4e020000, LENGTH = 0x00000800\n            |-&gt; }\n            |-&gt; \n            |-&gt; SECTIONS {\n            |-&gt; \n            |-&gt;      __boot_flag__ = 0;\n            |-&gt; \n            |-&gt;     .text : {\n            |-&gt;          KEEP(*(.intvec))\n            |-&gt;          *(.start)\n            |-&gt;          *(.text .text.*)\n            |-&gt;          . = ALIGN(., 4);\n            |-&gt;     } &gt; IMEM\n            |-&gt; \n            |-&gt;     .ARM.exidx : { } &gt; IMEM\n            |-&gt; \n            |-&gt;     .const : {\n            |-&gt;         *(.rodata .rodata.* .constdata .constdata.*)\n            |-&gt;         . = ALIGN(., 4);\n            |-&gt;     } &gt; IMEM\n            |-&gt; \n            |-&gt;     __data_load_start__ = ALIGN(., 4);\n            |-&gt; \n            |-&gt;     .data : AT(__data_load_start__) {\n            |-&gt;         *(.data .data.* .sdata .sdata.*)\n            |-&gt;         . = ALIGN(., 4);\n            |-&gt;     } &gt; DMEM\n            |-&gt; \n            |-&gt;     .bss (NOLOAD): {\n            |-&gt;         *(.bss .bss.*)\n            |-&gt;         *(.sbss .sbss.*)\n            |-&gt;         . = ALIGN(., 4);\n            |-&gt;     } &gt; DMEM\n            |-&gt; \n            |-&gt;     .ccfg : { KEEP(*(.ccfg)); } &gt; FLASH_CCFG\n            |-&gt; \n            |-&gt;     __bss_addr__ = ADDR(.bss);\n            |-&gt;     __bss_size__ = SIZEOF(.bss) / 4;\n            |-&gt;     __code_addr__ = ADDR(.text);\n            |-&gt;     __data_addr__ = ADDR(.data);\n            |-&gt;     __data_load__ = LOADADDR(.data);\n            |-&gt;     __data_size__ = SIZEOF(.data) / 4;\n            |-&gt;     __code_load__ = ~0;\n            |-&gt;     __code_size__ = ~0;\n            |-&gt;     __global_pointer__ = __data_addr__ + 0x800;\n            |-&gt;     __global_pointer$ = __global_pointer__;\n            |-&gt;     __stack_top__ = 0x20000000 + 0x00009000;\n            |-&gt; }\n        `)\n    }\n    else { // use_sram\n        out.addFrag(`\n            |-&gt; MEMORY {\n            |-&gt;     DMEM : ORIGIN = 0x20005000, LENGTH = 0x00004000\n            |-&gt;     IMEM : ORIGIN = 0x20000000, LENGTH = 0x00005000\n            |-&gt;     LMEM : ORIGIN = 0x00000000, LENGTH = 0x00080000\n            |-&gt;     FLASH_CCFG : ORIGIN = 0x4e020000, LENGTH = 0x00000800\n            |-&gt; }\n            |-&gt; \n            |-&gt; SECTIONS {\n            |-&gt;  \n            |-&gt;      __boot_flag__ = 0;\n            |-&gt; \n            |-&gt;     .armstart : {\n            |-&gt;         KEEP(*(.start_vec))\n            |-&gt;         KEEP(*(.start))\n            |-&gt;     } &gt; LMEM\n            |-&gt;  \n            |-&gt;     .text : {\n            |-&gt;          KEEP(*(.intvec))\n            |-&gt;          *(.text .text.*)\n            |-&gt;         . = ALIGN(., 4);\n            |-&gt;     } &gt; IMEM AT &gt; LMEM\n            |-&gt; \n            |-&gt;     .ARM.exidx : { } &gt; IMEM AT &gt; LMEM\n            |-&gt;  \n            |-&gt;     __const_load_start__ = (ALIGN(LOADADDR(.text) + SIZEOF(.text) + SIZEOF(.ARM.exidx), 4));\n            |-&gt; \n            |-&gt;     .const : AT(__const_load_start__) {\n            |-&gt;         *(.rodata .rodata.* .constdata .constdata.*)\n            |-&gt;         . = ALIGN(., 4);\n            |-&gt;     } &gt; IMEM\n            |-&gt;  \n            |-&gt;     __data_load_start__ = (ALIGN(LOADADDR(.const) + SIZEOF(.const), 4));\n            |-&gt; \n            |-&gt;     .data : AT(__data_load_start__) {\n            |-&gt;         *(.data .data.* .sdata .sdata.*)\n            |-&gt;         . = ALIGN(., 4);\n            |-&gt;     } &gt; DMEM\n            |-&gt; \n            |-&gt;     .bss (NOLOAD): {\n            |-&gt;         *(.bss .bss.*)\n            |-&gt;         *(.sbss .sbss.*)\n            |-&gt;         . = ALIGN(., 4);\n            |-&gt;     } &gt; DMEM\n            |-&gt;  \n            |-&gt;     .ccfg : { KEEP(*(.ccfg)); } &gt; FLASH_CCFG\n            |-&gt; \n            |-&gt;     __bss_addr__ = ADDR(.bss);\n            |-&gt;     __bss_size__ = SIZEOF(.bss) / 4;\n            |-&gt;     __code_addr__ = ADDR(.text);\n            |-&gt;     __data_addr__ = ADDR(.data);\n            |-&gt;     __data_load__ = LOADADDR(.data);\n            |-&gt;     __data_size__ = SIZEOF(.data) / 4;\n            |-&gt;     __code_load__ = LOADADDR(.text);\n            |-&gt;     __code_size__ = ((__data_load__ - __code_load__) / 4);\n            |-&gt;     __global_pointer__ = __data_addr__ + 0x800;\n            |-&gt;     __global_pointer$ = __global_pointer__;\n            |-&gt;     __stack_top__ = 0x20005000 + 0x00004000;\n            |-&gt; }\n        `)\n    }\n    out.close()\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.distro.cc23xx/REGS/","title":"REGS","text":"ti.distro.cc23xx/REGS.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('COMPOSITE')\n\nexport function em$generate() {\n    let out = new em.$outfile('ti.distro.cc23xx/REGS.hpp')\n    out.addFile('../ti.cc23xx/ti.distro.cc23xx/REGS.hpp.txt')\n    out.close()\n}\n\n// -------- MODULE CKMD -------- //\n\nexport interface CKMD_t {\n    DESC: em.$Reg\n    IMASK: em.$Reg\n    RIS: em.$Reg\n    MIS: em.$Reg\n    ISET: em.$Reg\n    ICLR: em.$Reg\n    IMSET: em.$Reg\n    IMCLR: em.$Reg\n    HFOSCCTL: em.$Reg\n    HFXTCTL: em.$Reg\n    LFOSCCTL: em.$Reg\n    LFXTCTL: em.$Reg\n    LFQUALCTL: em.$Reg\n    LFINCCTL: em.$Reg\n    LFINCOVR: em.$Reg\n    AMPADCCTL: em.$Reg\n    HFTRACKCTL: em.$Reg\n    LDOCTL: em.$Reg\n    NABIASCTL: em.$Reg\n    LFMONCTL: em.$Reg\n    LFCLKSEL: em.$Reg\n    TDCCLKSEL: em.$Reg\n    ADCCLKSEL: em.$Reg\n    LFCLKSTAT: em.$Reg\n    HFXTSTAT: em.$Reg\n    AMPADCSTAT: em.$Reg\n    TRACKSTAT: em.$Reg\n    AMPSTAT: em.$Reg\n    ATBCTL0: em.$Reg\n    ATBCTL1: em.$Reg\n    DTBCTL: em.$Reg\n    TRIM0: em.$Reg\n    TRIM1: em.$Reg\n    HFXTINIT: em.$Reg\n    HFXTTARG: em.$Reg\n    HFXTDYN: em.$Reg\n    AMPCFG0: em.$Reg\n    AMPCFG1: em.$Reg\n    LOOPCFG: em.$Reg\n    TDCCTL: em.$Reg\n    TDCSTAT: em.$Reg\n    TDCRESULT: em.$Reg\n    TDCSATCFG: em.$Reg\n    TDCTRIGSRC: em.$Reg\n    TDCTRIGCNT: em.$Reg\n    TDCTRIGCNTLOAD: em.$Reg\n    TDCTRIGCNTCFG: em.$Reg\n    TDCPRECTL: em.$Reg\n    TDCPRECNTR: em.$Reg\n    WDTCNT: em.$Reg\n    WDTTEST: em.$Reg\n    WDTLOCK: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription Register.\n\n\nThis register provides IP module ID, revision information, instance index and standard MMR registers offset.*/\n/**\nModule identifier used to uniquely identify this IP.*/\nexport const CKMD_DESC_MODID: any = '16'\nexport const CKMD_DESC_MODID_M: any = '16'\nexport const CKMD_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set of from aggregated IRQ registers till DTB.\n\n0: Standard IP MMRs do not exist\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)\n\nNOTE: This IP does not have DTB as part of the Standard IP MMRs. It uses DTBCTL instead.*/\nexport const CKMD_DESC_STDIPOFF: any = '4'\nexport const CKMD_DESC_STDIPOFF_M: any = '4'\nexport const CKMD_DESC_STDIPOFF_S: any = '4'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_DESC_RESERVED8: any = '4'\nexport const CKMD_DESC_RESERVED8_M: any = '4'\nexport const CKMD_DESC_RESERVED8_S: any = '4'\n/**\nMajor revision of IP (0-15).*/\nexport const CKMD_DESC_MAJREV: any = '4'\nexport const CKMD_DESC_MAJREV_M: any = '4'\nexport const CKMD_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP (0-15).\n\n*/\nexport const CKMD_DESC_MINREV: any = '4'\nexport const CKMD_DESC_MINREV_M: any = '4'\nexport const CKMD_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER IMASK -------- //\n\n/**\nInterrupt mask.\n\n\nThis register selects interrupt sources which are allowed to pass from RIS to MIS when the corresponding bit-fields are set to 1.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_IMASK_RESERVED18: any = '14'\nexport const CKMD_IMASK_RESERVED18_M: any = '14'\nexport const CKMD_IMASK_RESERVED18_S: any = '14'\n/**\n32kHz TICK to RTC and WDT.\n\n\nEither derived from selected LFCLK or generated from CLKULL in absence of LFCLK.*/\nexport const CKMD_IMASK_LFTICK: any = '1'\nexport const CKMD_IMASK_LFTICK_M: any = '1'\nexport const CKMD_IMASK_LFTICK_S: any = '1'\n/**\nLFINC filter gearing restart.\n\n\nIndicates that the LFINC filter restarted gearing. Subsequent LFINC estimates may have higher variation.*/\nexport const CKMD_IMASK_LFGEARRSTRT: any = '1'\nexport const CKMD_IMASK_LFGEARRSTRT_M: any = '1'\nexport const CKMD_IMASK_LFGEARRSTRT_S: any = '1'\n/**\nHFXT Amplitude compensation - settled\n\n\nIndicates that the amplitude compensation FSM has reached the SETTLED or TCXOMODE state,\nand the controls configured in HFXTTARG or HFXTDYN are reached.\n*/\nexport const CKMD_IMASK_AMPSETTLED: any = '1'\nexport const CKMD_IMASK_AMPSETTLED_M: any = '1'\nexport const CKMD_IMASK_AMPSETTLED_S: any = '1'\n/**\nHFXT Amplitude compensation - controls at target\n\n\nIndicates that the control values configured in HFXTTARG or HFXTDYN are reached.\nApplies to Q1CAP, Q2CAP and IREF.*/\nexport const CKMD_IMASK_AMPCTRLATTARG: any = '1'\nexport const CKMD_IMASK_AMPCTRLATTARG_M: any = '1'\nexport const CKMD_IMASK_AMPCTRLATTARG_S: any = '1'\n/**\nPre-LF clock edge detect.\n\n\nIndicates that a positive edge occured on the selected pre-LF clock LFCLKSEL.PRE.\nCan be used by software to confirm that a LF clock source is running and within the expected frequency,\nbefore selecting it as the main LF clock source.*/\nexport const CKMD_IMASK_PRELFEDGE: any = '1'\nexport const CKMD_IMASK_PRELFEDGE_M: any = '1'\nexport const CKMD_IMASK_PRELFEDGE_S: any = '1'\n/**\nLF clock is lost.\n\n\nIndicates that no LF clock edge occured for ~49us (~1.6 times nominal period).\nThe system will automatically fall-back to generating LFTICK based on CLKULL,\nto avoid timing corruption.\nNote that this signal is NOT related to the analog LF clock-loss detector which can reset the device during STANDBY.*/\nexport const CKMD_IMASK_LFCLKLOSS: any = '1'\nexport const CKMD_IMASK_LFCLKLOSS_M: any = '1'\nexport const CKMD_IMASK_LFCLKLOSS_S: any = '1'\n/**\nLF clock period out-of-range.\n\n\nIndicates that a LF clock period was measured to be out-of-range,\naccording to LFQUALCTL.MAXERR.*/\nexport const CKMD_IMASK_LFCLKOOR: any = '1'\nexport const CKMD_IMASK_LFCLKOOR_M: any = '1'\nexport const CKMD_IMASK_LFCLKOOR_S: any = '1'\n/**\nLF clock good.\n\n\nIndicates that the LF clock is good, according to the configuration in LFQUALCTL.*/\nexport const CKMD_IMASK_LFCLKGOOD: any = '1'\nexport const CKMD_IMASK_LFCLKGOOD_M: any = '1'\nexport const CKMD_IMASK_LFCLKGOOD_S: any = '1'\n/**\nLFINC updated.\n\n\nIndicates that a new LFINC measurement value is available in LFCLKSTAT.LFINC.*/\nexport const CKMD_IMASK_LFINCUPD: any = '1'\nexport const CKMD_IMASK_LFINCUPD_M: any = '1'\nexport const CKMD_IMASK_LFINCUPD_S: any = '1'\n/**\nTDC done event.\n\n\nIndicates that the TDC measurement is done.*/\nexport const CKMD_IMASK_TDCDONE: any = '1'\nexport const CKMD_IMASK_TDCDONE_M: any = '1'\nexport const CKMD_IMASK_TDCDONE_S: any = '1'\n/**\nHFXT-ADC PEAK measurement update event.\n\n\nIndicates that the HFXT-ADC PEAK measurement is done.*/\nexport const CKMD_IMASK_ADCPEAKUPD: any = '1'\nexport const CKMD_IMASK_ADCPEAKUPD_M: any = '1'\nexport const CKMD_IMASK_ADCPEAKUPD_S: any = '1'\n/**\nHFXT-ADC BIAS measurement update event.\n\n\nIndicates that the HFXT-ADC BIAS measurement is done.*/\nexport const CKMD_IMASK_ADCBIASUPD: any = '1'\nexport const CKMD_IMASK_ADCBIASUPD_M: any = '1'\nexport const CKMD_IMASK_ADCBIASUPD_S: any = '1'\n/**\nHFXT-ADC comparison update event.\n\n\nIndicates that the HFXT-ADC comparison is done.*/\nexport const CKMD_IMASK_ADCCOMPUPD: any = '1'\nexport const CKMD_IMASK_ADCCOMPUPD_M: any = '1'\nexport const CKMD_IMASK_ADCCOMPUPD_S: any = '1'\n/**\nOut-of-range indication from the tracking loop.\n\n\nIndicates that the selected reference clock frequency of the tracking loop is out-of-range.*/\nexport const CKMD_IMASK_TRACKREFOOR: any = '1'\nexport const CKMD_IMASK_TRACKREFOOR_M: any = '1'\nexport const CKMD_IMASK_TRACKREFOOR_S: any = '1'\n/**\nClock loss indication from the tracking loop.\n\n\nIndicates that the selected reference clock of the tracking loop is lost.*/\nexport const CKMD_IMASK_TRACKREFLOSS: any = '1'\nexport const CKMD_IMASK_TRACKREFLOSS_M: any = '1'\nexport const CKMD_IMASK_TRACKREFLOSS_S: any = '1'\n/**\nHFXT amplitude good indication.*/\nexport const CKMD_IMASK_HFXTAMPGOOD: any = '1'\nexport const CKMD_IMASK_HFXTAMPGOOD_M: any = '1'\nexport const CKMD_IMASK_HFXTAMPGOOD_S: any = '1'\n/**\nHFXT fault indication.\n\n\nIndicates that HFXT did not start correctly, or its frequency is too low.\nHFXT will not recover from this fault and has to be restarted.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_IMASK_HFXTFAULT: any = '1'\nexport const CKMD_IMASK_HFXTFAULT_M: any = '1'\nexport const CKMD_IMASK_HFXTFAULT_S: any = '1'\n/**\nHFXT good indication.\n\n\nIndicates that HFXT started correctly. The frequency is not necessarily good enough for radio operation.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_IMASK_HFXTGOOD: any = '1'\nexport const CKMD_IMASK_HFXTGOOD_M: any = '1'\nexport const CKMD_IMASK_HFXTGOOD_S: any = '1'\n\n// -------- REGISTER RIS -------- //\n\n/**\nRaw interrupt status.\n\n\nThis register reflects the state of all pending interrupts, regardless of masking. This register allows the user to implement a poll scheme. A flag set in this register can be cleared by writing 1 to the corresponding ICLR register bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_RIS_RESERVED18: any = '14'\nexport const CKMD_RIS_RESERVED18_M: any = '14'\nexport const CKMD_RIS_RESERVED18_S: any = '14'\n/**\n32kHz TICK to RTC and WDT.\n\n\nEither derived from selected LFCLK or generated from CLKULL in absence of LFCLK.*/\nexport const CKMD_RIS_LFTICK: any = '1'\nexport const CKMD_RIS_LFTICK_M: any = '1'\nexport const CKMD_RIS_LFTICK_S: any = '1'\n/**\nLFINC filter gearing restart.\n\n\nIndicates that the LFINC filter restarted gearing. Subsequent LFINC estimates may have higher variation.*/\nexport const CKMD_RIS_LFGEARRSTRT: any = '1'\nexport const CKMD_RIS_LFGEARRSTRT_M: any = '1'\nexport const CKMD_RIS_LFGEARRSTRT_S: any = '1'\n/**\nHFXT Amplitude compensation - settled\n\n\nIndicates that the amplitude compensation FSM has reached the SETTLED or TCXOMODE state,\nand the controls configured in HFXTTARG or HFXTDYN are reached.\n*/\nexport const CKMD_RIS_AMPSETTLED: any = '1'\nexport const CKMD_RIS_AMPSETTLED_M: any = '1'\nexport const CKMD_RIS_AMPSETTLED_S: any = '1'\n/**\nHFXT Amplitude compensation - controls at target\n\n\nIndicates that the control values configured in HFXTTARG or HFXTDYN are reached.\nApplies to Q1CAP, Q2CAP and IREF.*/\nexport const CKMD_RIS_AMPCTRLATTARG: any = '1'\nexport const CKMD_RIS_AMPCTRLATTARG_M: any = '1'\nexport const CKMD_RIS_AMPCTRLATTARG_S: any = '1'\n/**\nPre-LF clock edge detect.\n\n\nIndicates that a positive edge occured on the selected pre-LF clock LFCLKSEL.PRE.\nCan be used by software to confirm that a LF clock source is running and within the expected frequency,\nbefore selecting it as the main LF clock source.*/\nexport const CKMD_RIS_PRELFEDGE: any = '1'\nexport const CKMD_RIS_PRELFEDGE_M: any = '1'\nexport const CKMD_RIS_PRELFEDGE_S: any = '1'\n/**\nLF clock is lost.\n\n\nIndicates that no LF clock edge occured for ~49us (~1.6 times nominal period).\nThe system will automatically fall-back to generating LFTICK based on CLKULL,\nto avoid timing corruption.\nNote that this signal is NOT related to the analog LF clock-loss detector which can reset the device during STANDBY.*/\nexport const CKMD_RIS_LFCLKLOSS: any = '1'\nexport const CKMD_RIS_LFCLKLOSS_M: any = '1'\nexport const CKMD_RIS_LFCLKLOSS_S: any = '1'\n/**\nLF clock period out-of-range.\n\n\nIndicates that a LF clock period was measured to be out-of-range,\naccording to LFQUALCTL.MAXERR.*/\nexport const CKMD_RIS_LFCLKOOR: any = '1'\nexport const CKMD_RIS_LFCLKOOR_M: any = '1'\nexport const CKMD_RIS_LFCLKOOR_S: any = '1'\n/**\nLF clock good.\n\n\nIndicates that the LF clock is good, according to the configuration in LFQUALCTL.*/\nexport const CKMD_RIS_LFCLKGOOD: any = '1'\nexport const CKMD_RIS_LFCLKGOOD_M: any = '1'\nexport const CKMD_RIS_LFCLKGOOD_S: any = '1'\n/**\nLFINC updated.\n\n\nIndicates that a new LFINC measurement value is available in LFCLKSTAT.LFINC.*/\nexport const CKMD_RIS_LFINCUPD: any = '1'\nexport const CKMD_RIS_LFINCUPD_M: any = '1'\nexport const CKMD_RIS_LFINCUPD_S: any = '1'\n/**\nTDC done event.\n\n\nIndicates that the TDC measurement is done.*/\nexport const CKMD_RIS_TDCDONE: any = '1'\nexport const CKMD_RIS_TDCDONE_M: any = '1'\nexport const CKMD_RIS_TDCDONE_S: any = '1'\n/**\nHFXT-ADC PEAK measurement update event.\n\n\nIndicates that the HFXT-ADC PEAK measurement is done.*/\nexport const CKMD_RIS_ADCPEAKUPD: any = '1'\nexport const CKMD_RIS_ADCPEAKUPD_M: any = '1'\nexport const CKMD_RIS_ADCPEAKUPD_S: any = '1'\n/**\nHFXT-ADC BIAS measurement update event.\n\n\nIndicates that the HFXT-ADC BIAS measurement is done.*/\nexport const CKMD_RIS_ADCBIASUPD: any = '1'\nexport const CKMD_RIS_ADCBIASUPD_M: any = '1'\nexport const CKMD_RIS_ADCBIASUPD_S: any = '1'\n/**\nHFXT-ADC comparison update event.\n\n\nIndicates that the HFXT-ADC comparison is done.*/\nexport const CKMD_RIS_ADCCOMPUPD: any = '1'\nexport const CKMD_RIS_ADCCOMPUPD_M: any = '1'\nexport const CKMD_RIS_ADCCOMPUPD_S: any = '1'\n/**\nOut-of-range indication from the tracking loop.\n\n\nIndicates that the selected reference clock frequency of the tracking loop is out-of-range.*/\nexport const CKMD_RIS_TRACKREFOOR: any = '1'\nexport const CKMD_RIS_TRACKREFOOR_M: any = '1'\nexport const CKMD_RIS_TRACKREFOOR_S: any = '1'\n/**\nClock loss indication from the tracking loop.\n\n\nIndicates that the selected reference clock of the tracking loop is lost.*/\nexport const CKMD_RIS_TRACKREFLOSS: any = '1'\nexport const CKMD_RIS_TRACKREFLOSS_M: any = '1'\nexport const CKMD_RIS_TRACKREFLOSS_S: any = '1'\n/**\nHFXT amplitude good indication.*/\nexport const CKMD_RIS_HFXTAMPGOOD: any = '1'\nexport const CKMD_RIS_HFXTAMPGOOD_M: any = '1'\nexport const CKMD_RIS_HFXTAMPGOOD_S: any = '1'\n/**\nHFXT fault indication.\n\n\nIndicates that HFXT did not start correctly, or its frequency is too low.\nHFXT will not recover from this fault and has to be restarted.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_RIS_HFXTFAULT: any = '1'\nexport const CKMD_RIS_HFXTFAULT_M: any = '1'\nexport const CKMD_RIS_HFXTFAULT_S: any = '1'\n/**\nHFXT good indication.\n\n\nIndicates that HFXT started correctly. The frequency is not necessarily good enough for radio operation.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_RIS_HFXTGOOD: any = '1'\nexport const CKMD_RIS_HFXTGOOD_M: any = '1'\nexport const CKMD_RIS_HFXTGOOD_S: any = '1'\n\n// -------- REGISTER MIS -------- //\n\n/**\nMasked interrupt status.\n\n\nThis register is simply a bitwise AND of the contents of IMASK and RIS.*] registers. A flag set in this register can be cleared by writing 1 to the corresponding ICLR register bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_MIS_RESERVED18: any = '14'\nexport const CKMD_MIS_RESERVED18_M: any = '14'\nexport const CKMD_MIS_RESERVED18_S: any = '14'\n/**\n32kHz TICK to RTC and WDT.\n\n\nEither derived from selected LFCLK or generated from CLKULL in absence of LFCLK.*/\nexport const CKMD_MIS_LFTICK: any = '1'\nexport const CKMD_MIS_LFTICK_M: any = '1'\nexport const CKMD_MIS_LFTICK_S: any = '1'\n/**\nLFINC filter gearing restart.\n\n\nIndicates that the LFINC filter restarted gearing. Subsequent LFINC estimates may have higher variation.*/\nexport const CKMD_MIS_LFGEARRSTRT: any = '1'\nexport const CKMD_MIS_LFGEARRSTRT_M: any = '1'\nexport const CKMD_MIS_LFGEARRSTRT_S: any = '1'\n/**\nHFXT Amplitude compensation - settled\n\n\nIndicates that the amplitude compensation FSM has reached the SETTLED or TCXOMODE state,\nand the controls configured in HFXTTARG or HFXTDYN are reached.\n*/\nexport const CKMD_MIS_AMPSETTLED: any = '1'\nexport const CKMD_MIS_AMPSETTLED_M: any = '1'\nexport const CKMD_MIS_AMPSETTLED_S: any = '1'\n/**\nHFXT Amplitude compensation - controls at target\n\n\nIndicates that the control values configured in HFXTTARG or HFXTDYN are reached.\nApplies to Q1CAP, Q2CAP and IREF.*/\nexport const CKMD_MIS_AMPCTRLATTARG: any = '1'\nexport const CKMD_MIS_AMPCTRLATTARG_M: any = '1'\nexport const CKMD_MIS_AMPCTRLATTARG_S: any = '1'\n/**\nPre-LF clock edge detect.\n\n\nIndicates that a positive edge occured on the selected pre-LF clock LFCLKSEL.PRE.\nCan be used by software to confirm that a LF clock source is running and within the expected frequency,\nbefore selecting it as the main LF clock source.*/\nexport const CKMD_MIS_PRELFEDGE: any = '1'\nexport const CKMD_MIS_PRELFEDGE_M: any = '1'\nexport const CKMD_MIS_PRELFEDGE_S: any = '1'\n/**\nLF clock is lost.\n\n\nIndicates that no LF clock edge occured for ~49us (~1.6 times nominal period).\nThe system will automatically fall-back to generating LFTICK based on CLKULL,\nto avoid timing corruption.\nNote that this signal is NOT related to the analog LF clock-loss detector which can reset the device during STANDBY.*/\nexport const CKMD_MIS_LFCLKLOSS: any = '1'\nexport const CKMD_MIS_LFCLKLOSS_M: any = '1'\nexport const CKMD_MIS_LFCLKLOSS_S: any = '1'\n/**\nLF clock period out-of-range.\n\n\nIndicates that a LF clock period was measured to be out-of-range,\naccording to LFQUALCTL.MAXERR.*/\nexport const CKMD_MIS_LFCLKOOR: any = '1'\nexport const CKMD_MIS_LFCLKOOR_M: any = '1'\nexport const CKMD_MIS_LFCLKOOR_S: any = '1'\n/**\nLF clock good.\n\n\nIndicates that the LF clock is good, according to the configuration in LFQUALCTL.*/\nexport const CKMD_MIS_LFCLKGOOD: any = '1'\nexport const CKMD_MIS_LFCLKGOOD_M: any = '1'\nexport const CKMD_MIS_LFCLKGOOD_S: any = '1'\n/**\nLFINC updated.\n\n\nIndicates that a new LFINC measurement value is available in LFCLKSTAT.LFINC.*/\nexport const CKMD_MIS_LFINCUPD: any = '1'\nexport const CKMD_MIS_LFINCUPD_M: any = '1'\nexport const CKMD_MIS_LFINCUPD_S: any = '1'\n/**\nTDC done event.\n\n\nIndicates that the TDC measurement is done.*/\nexport const CKMD_MIS_TDCDONE: any = '1'\nexport const CKMD_MIS_TDCDONE_M: any = '1'\nexport const CKMD_MIS_TDCDONE_S: any = '1'\n/**\nHFXT-ADC PEAK measurement update event.\n\n\nIndicates that the HFXT-ADC PEAK measurement is done.*/\nexport const CKMD_MIS_ADCPEAKUPD: any = '1'\nexport const CKMD_MIS_ADCPEAKUPD_M: any = '1'\nexport const CKMD_MIS_ADCPEAKUPD_S: any = '1'\n/**\nHFXT-ADC BIAS measurement update event.\n\n\nIndicates that the HFXT-ADC BIAS measurement is done.*/\nexport const CKMD_MIS_ADCBIASUPD: any = '1'\nexport const CKMD_MIS_ADCBIASUPD_M: any = '1'\nexport const CKMD_MIS_ADCBIASUPD_S: any = '1'\n/**\nHFXT-ADC comparison update event.\n\n\nIndicates that the HFXT-ADC comparison is done.*/\nexport const CKMD_MIS_ADCCOMPUPD: any = '1'\nexport const CKMD_MIS_ADCCOMPUPD_M: any = '1'\nexport const CKMD_MIS_ADCCOMPUPD_S: any = '1'\n/**\nOut-of-range indication from the tracking loop.\n\n\nIndicates that the selected reference clock frequency of the tracking loop is out-of-range.*/\nexport const CKMD_MIS_TRACKREFOOR: any = '1'\nexport const CKMD_MIS_TRACKREFOOR_M: any = '1'\nexport const CKMD_MIS_TRACKREFOOR_S: any = '1'\n/**\nClock loss indication from the tracking loop.\n\n\nIndicates that the selected reference clock of the tracking loop is lost.*/\nexport const CKMD_MIS_TRACKREFLOSS: any = '1'\nexport const CKMD_MIS_TRACKREFLOSS_M: any = '1'\nexport const CKMD_MIS_TRACKREFLOSS_S: any = '1'\n/**\nHFXT amplitude good indication.*/\nexport const CKMD_MIS_HFXTAMPGOOD: any = '1'\nexport const CKMD_MIS_HFXTAMPGOOD_M: any = '1'\nexport const CKMD_MIS_HFXTAMPGOOD_S: any = '1'\n/**\nHFXT fault indication.\n\n\nIndicates that HFXT did not start correctly, or its frequency is too low.\nHFXT will not recover from this fault and has to be restarted.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_MIS_HFXTFAULT: any = '1'\nexport const CKMD_MIS_HFXTFAULT_M: any = '1'\nexport const CKMD_MIS_HFXTFAULT_S: any = '1'\n/**\nHFXT good indication.\n\n\nIndicates that HFXT started correctly. The frequency is not necessarily good enough for radio operation.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_MIS_HFXTGOOD: any = '1'\nexport const CKMD_MIS_HFXTGOOD_M: any = '1'\nexport const CKMD_MIS_HFXTGOOD_S: any = '1'\n\n// -------- REGISTER ISET -------- //\n\n/**\nInterrupt set register.\n\n\nThis register can used by software for diagnostics and safety checking purposes. Writing a 1 to a bit in this register will set the event and the corresponding RIS bit also gets set. If the corresponding IMASK bit is set, then the corresponding MIS register bit also gets set.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_ISET_RESERVED18: any = '14'\nexport const CKMD_ISET_RESERVED18_M: any = '14'\nexport const CKMD_ISET_RESERVED18_S: any = '14'\n/**\n32kHz TICK to RTC and WDT.\n\n\nEither derived from selected LFCLK or generated from CLKULL in absence of LFCLK.*/\nexport const CKMD_ISET_LFTICK: any = '1'\nexport const CKMD_ISET_LFTICK_M: any = '1'\nexport const CKMD_ISET_LFTICK_S: any = '1'\n/**\nLFINC filter gearing restart.\n\n\nIndicates that the LFINC filter restarted gearing. Subsequent LFINC estimates may have higher variation.*/\nexport const CKMD_ISET_LFGEARRSTRT: any = '1'\nexport const CKMD_ISET_LFGEARRSTRT_M: any = '1'\nexport const CKMD_ISET_LFGEARRSTRT_S: any = '1'\n/**\nHFXT Amplitude compensation - settled\n\n\nIndicates that the amplitude compensation FSM has reached the SETTLED or TCXOMODE state,\nand the controls configured in HFXTTARG or HFXTDYN are reached.\n*/\nexport const CKMD_ISET_AMPSETTLED: any = '1'\nexport const CKMD_ISET_AMPSETTLED_M: any = '1'\nexport const CKMD_ISET_AMPSETTLED_S: any = '1'\n/**\nHFXT Amplitude compensation - controls at target\n\n\nIndicates that the control values configured in HFXTTARG.Q1CAP, HFXTTARG.Q2CAP and HFXTTARG.IREF or HFXTDYN.Q1CAP, HFXTDYN.Q2CAP and HFXTDYN.IREF are reached.*/\nexport const CKMD_ISET_AMPCTRLATTARG: any = '1'\nexport const CKMD_ISET_AMPCTRLATTARG_M: any = '1'\nexport const CKMD_ISET_AMPCTRLATTARG_S: any = '1'\n/**\nPre-LF clock edge detect.\n\n\nIndicates that a positive edge occured on the selected pre-LF clock LFCLKSEL.PRE.\nCan be used by software to confirm that a LF clock source is running and within the expected frequency,\nbefore selecting it as the main LF clock source.*/\nexport const CKMD_ISET_PRELFEDGE: any = '1'\nexport const CKMD_ISET_PRELFEDGE_M: any = '1'\nexport const CKMD_ISET_PRELFEDGE_S: any = '1'\n/**\nLF clock is lost.\n\n\nIndicates that no LF clock edge occured for ~49us (~1.6 times nominal period).\nThe system will automatically fall-back to generating LFTICK based on CLKULL,\nto avoid timing corruption.\nNote that this signal is NOT related to the analog LF clock-loss detector which can reset the device during STANDBY.*/\nexport const CKMD_ISET_LFCLKLOSS: any = '1'\nexport const CKMD_ISET_LFCLKLOSS_M: any = '1'\nexport const CKMD_ISET_LFCLKLOSS_S: any = '1'\n/**\nLF clock period out-of-range.\n\n\nIndicates that a LF clock period was measured to be out-of-range,\naccording to LFQUALCTL.MAXERR.*/\nexport const CKMD_ISET_LFCLKOOR: any = '1'\nexport const CKMD_ISET_LFCLKOOR_M: any = '1'\nexport const CKMD_ISET_LFCLKOOR_S: any = '1'\n/**\nLF clock good.\n\n\nIndicates that the LF clock is good, according to the configuration in LFQUALCTL.*/\nexport const CKMD_ISET_LFCLKGOOD: any = '1'\nexport const CKMD_ISET_LFCLKGOOD_M: any = '1'\nexport const CKMD_ISET_LFCLKGOOD_S: any = '1'\n/**\nLFINC updated.\n\n\nIndicates that a new LFINC measurement value is available in LFCLKSTAT.LFINC.*/\nexport const CKMD_ISET_LFINCUPD: any = '1'\nexport const CKMD_ISET_LFINCUPD_M: any = '1'\nexport const CKMD_ISET_LFINCUPD_S: any = '1'\n/**\nTDC done event.\n\n\nIndicates that the TDC measurement is done.*/\nexport const CKMD_ISET_TDCDONE: any = '1'\nexport const CKMD_ISET_TDCDONE_M: any = '1'\nexport const CKMD_ISET_TDCDONE_S: any = '1'\n/**\nHFXT-ADC PEAK measurement update event.\n\n\nIndicates that the HFXT-ADC PEAK measurement is done.*/\nexport const CKMD_ISET_ADCPEAKUPD: any = '1'\nexport const CKMD_ISET_ADCPEAKUPD_M: any = '1'\nexport const CKMD_ISET_ADCPEAKUPD_S: any = '1'\n/**\nHFXT-ADC BIAS measurement update event.\n\n\nIndicates that the HFXT-ADC BIAS measurement is done.*/\nexport const CKMD_ISET_ADCBIASUPD: any = '1'\nexport const CKMD_ISET_ADCBIASUPD_M: any = '1'\nexport const CKMD_ISET_ADCBIASUPD_S: any = '1'\n/**\nHFXT-ADC comparison update event.\n\n\nIndicates that the HFXT-ADC comparison is done.*/\nexport const CKMD_ISET_ADCCOMPUPD: any = '1'\nexport const CKMD_ISET_ADCCOMPUPD_M: any = '1'\nexport const CKMD_ISET_ADCCOMPUPD_S: any = '1'\n/**\nOut-of-range indication from the tracking loop.\n\n\nIndicates that the selected reference clock frequency of the tracking loop is out-of-range.*/\nexport const CKMD_ISET_TRACKREFOOR: any = '1'\nexport const CKMD_ISET_TRACKREFOOR_M: any = '1'\nexport const CKMD_ISET_TRACKREFOOR_S: any = '1'\n/**\nClock loss indication from the tracking loop.\n\n\nIndicates that the selected reference clock of the tracking loop is lost.*/\nexport const CKMD_ISET_TRACKREFLOSS: any = '1'\nexport const CKMD_ISET_TRACKREFLOSS_M: any = '1'\nexport const CKMD_ISET_TRACKREFLOSS_S: any = '1'\n/**\nHFXT amplitude good indication.*/\nexport const CKMD_ISET_HFXTAMPGOOD: any = '1'\nexport const CKMD_ISET_HFXTAMPGOOD_M: any = '1'\nexport const CKMD_ISET_HFXTAMPGOOD_S: any = '1'\n/**\nHFXT fault indication.\n\n\nIndicates that HFXT did not start correctly, or its frequency is too low.\nHFXT will not recover from this fault and has to be restarted.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_ISET_HFXTFAULT: any = '1'\nexport const CKMD_ISET_HFXTFAULT_M: any = '1'\nexport const CKMD_ISET_HFXTFAULT_S: any = '1'\n/**\nHFXT good indication.\n\n\nIndicates that HFXT started correctly. The frequency is not necessarily good enough for radio operation.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_ISET_HFXTGOOD: any = '1'\nexport const CKMD_ISET_HFXTGOOD_M: any = '1'\nexport const CKMD_ISET_HFXTGOOD_S: any = '1'\n\n// -------- REGISTER ICLR -------- //\n\n/**\nInterrupt clear register.\n\n\nThis register allows software to clear interrupts. Writing a 1 to a bit in this register will clear the event and the corresponding RIS bit also gets cleared. If the corresponding IMASK bit is set, then the corresponding MIS register bit also gets cleared.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_ICLR_RESERVED18: any = '14'\nexport const CKMD_ICLR_RESERVED18_M: any = '14'\nexport const CKMD_ICLR_RESERVED18_S: any = '14'\n/**\n32kHz TICK to RTC and WDT.\n\n\nEither derived from selected LFCLK or generated from CLKULL in absence of LFCLK.*/\nexport const CKMD_ICLR_LFTICK: any = '1'\nexport const CKMD_ICLR_LFTICK_M: any = '1'\nexport const CKMD_ICLR_LFTICK_S: any = '1'\n/**\nLFINC filter gearing restart.\n\n\nIndicates that the LFINC filter restarted gearing. Subsequent LFINC estimates may have higher variation.*/\nexport const CKMD_ICLR_LFGEARRSTRT: any = '1'\nexport const CKMD_ICLR_LFGEARRSTRT_M: any = '1'\nexport const CKMD_ICLR_LFGEARRSTRT_S: any = '1'\n/**\nHFXT Amplitude compensation - settled\n\n\nIndicates that the amplitude compensation FSM has reached the SETTLED or TCXOMODE state,\nand the controls configured in HFXTTARG or HFXTDYN are reached.\n*/\nexport const CKMD_ICLR_AMPSETTLED: any = '1'\nexport const CKMD_ICLR_AMPSETTLED_M: any = '1'\nexport const CKMD_ICLR_AMPSETTLED_S: any = '1'\n/**\nHFXT Amplitude compensation - controls at target\n\n\nIndicates that the control values configured in HFXTTARG or HFXTDYN are reached.\nApplies to Q1CAP, Q2CAP and IREF.*/\nexport const CKMD_ICLR_AMPCTRLATTARG: any = '1'\nexport const CKMD_ICLR_AMPCTRLATTARG_M: any = '1'\nexport const CKMD_ICLR_AMPCTRLATTARG_S: any = '1'\n/**\nPre-LF clock edge detect.\n\n\nIndicates that a positive edge occured on the selected pre-LF clock LFCLKSEL.PRE.\nCan be used by software to confirm that a LF clock source is running and within the expected frequency,\nbefore selecting it as the main LF clock source.*/\nexport const CKMD_ICLR_PRELFEDGE: any = '1'\nexport const CKMD_ICLR_PRELFEDGE_M: any = '1'\nexport const CKMD_ICLR_PRELFEDGE_S: any = '1'\n/**\nLF clock is lost.\n\n\nIndicates that no LF clock edge occured for ~49us (~1.6 times nominal period).\nThe system will automatically fall-back to generating LFTICK based on CLKULL,\nto avoid timing corruption.\nNote that this signal is NOT related to the analog LF clock-loss detector which can reset the device during STANDBY.*/\nexport const CKMD_ICLR_LFCLKLOSS: any = '1'\nexport const CKMD_ICLR_LFCLKLOSS_M: any = '1'\nexport const CKMD_ICLR_LFCLKLOSS_S: any = '1'\n/**\nLF clock period out-of-range.\n\n\nIndicates that a LF clock period was measured to be out-of-range,\naccording to LFQUALCTL.MAXERR.*/\nexport const CKMD_ICLR_LFCLKOOR: any = '1'\nexport const CKMD_ICLR_LFCLKOOR_M: any = '1'\nexport const CKMD_ICLR_LFCLKOOR_S: any = '1'\n/**\nLF clock good.\n\n\nIndicates that the LF clock is good, according to the configuration in LFQUALCTL.*/\nexport const CKMD_ICLR_LFCLKGOOD: any = '1'\nexport const CKMD_ICLR_LFCLKGOOD_M: any = '1'\nexport const CKMD_ICLR_LFCLKGOOD_S: any = '1'\n/**\nLFINC updated.\n\n\nIndicates that a new LFINC measurement value is available in LFCLKSTAT.LFINC.*/\nexport const CKMD_ICLR_LFINCUPD: any = '1'\nexport const CKMD_ICLR_LFINCUPD_M: any = '1'\nexport const CKMD_ICLR_LFINCUPD_S: any = '1'\n/**\nTDC done event.\n\n\nIndicates that the TDC measurement is done.*/\nexport const CKMD_ICLR_TDCDONE: any = '1'\nexport const CKMD_ICLR_TDCDONE_M: any = '1'\nexport const CKMD_ICLR_TDCDONE_S: any = '1'\n/**\nHFXT-ADC PEAK measurement update event.\n\n\nIndicates that the HFXT-ADC PEAK measurement is done.*/\nexport const CKMD_ICLR_ADCPEAKUPD: any = '1'\nexport const CKMD_ICLR_ADCPEAKUPD_M: any = '1'\nexport const CKMD_ICLR_ADCPEAKUPD_S: any = '1'\n/**\nHFXT-ADC BIAS measurement update event.\n\n\nIndicates that the HFXT-ADC BIAS measurement is done.*/\nexport const CKMD_ICLR_ADCBIASUPD: any = '1'\nexport const CKMD_ICLR_ADCBIASUPD_M: any = '1'\nexport const CKMD_ICLR_ADCBIASUPD_S: any = '1'\n/**\nHFXT-ADC comparison update event.\n\n\nIndicates that the HFXT-ADC comparison is done.*/\nexport const CKMD_ICLR_ADCCOMPUPD: any = '1'\nexport const CKMD_ICLR_ADCCOMPUPD_M: any = '1'\nexport const CKMD_ICLR_ADCCOMPUPD_S: any = '1'\n/**\nOut-of-range indication from the tracking loop.\n\n\nIndicates that the selected reference clock frequency of the tracking loop is out-of-range.*/\nexport const CKMD_ICLR_TRACKREFOOR: any = '1'\nexport const CKMD_ICLR_TRACKREFOOR_M: any = '1'\nexport const CKMD_ICLR_TRACKREFOOR_S: any = '1'\n/**\nClock loss indication from the tracking loop.\n\n\nIndicates that the selected reference clock of the tracking loop is lost.*/\nexport const CKMD_ICLR_TRACKREFLOSS: any = '1'\nexport const CKMD_ICLR_TRACKREFLOSS_M: any = '1'\nexport const CKMD_ICLR_TRACKREFLOSS_S: any = '1'\n/**\nHFXT amplitude good indication.*/\nexport const CKMD_ICLR_HFXTAMPGOOD: any = '1'\nexport const CKMD_ICLR_HFXTAMPGOOD_M: any = '1'\nexport const CKMD_ICLR_HFXTAMPGOOD_S: any = '1'\n/**\nHFXT fault indication.\n\n\nIndicates that HFXT did not start correctly, or its frequency is too low.\nHFXT will not recover from this fault and has to be restarted.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_ICLR_HFXTFAULT: any = '1'\nexport const CKMD_ICLR_HFXTFAULT_M: any = '1'\nexport const CKMD_ICLR_HFXTFAULT_S: any = '1'\n/**\nHFXT good indication.\n\n\nIndicates that HFXT started correctly. The frequency is not necessarily good enough for radio operation.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_ICLR_HFXTGOOD: any = '1'\nexport const CKMD_ICLR_HFXTGOOD_M: any = '1'\nexport const CKMD_ICLR_HFXTGOOD_S: any = '1'\n\n// -------- REGISTER IMSET -------- //\n\n/**\nInterrupt mask set register.\n\n\nWriting a 1 to a bit in this register will set the corresponding IMASK bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_IMSET_RESERVED18: any = '14'\nexport const CKMD_IMSET_RESERVED18_M: any = '14'\nexport const CKMD_IMSET_RESERVED18_S: any = '14'\n/**\n32kHz TICK to RTC and WDT.\n\n\nEither derived from selected LFCLK or generated from CLKULL in absence of LFCLK.*/\nexport const CKMD_IMSET_LFTICK: any = '1'\nexport const CKMD_IMSET_LFTICK_M: any = '1'\nexport const CKMD_IMSET_LFTICK_S: any = '1'\n/**\nLFINC filter gearing restart.\n\n\nIndicates that the LFINC filter restarted gearing. Subsequent LFINC estimates may have higher variation.*/\nexport const CKMD_IMSET_LFGEARRSTRT: any = '1'\nexport const CKMD_IMSET_LFGEARRSTRT_M: any = '1'\nexport const CKMD_IMSET_LFGEARRSTRT_S: any = '1'\n/**\nHFXT Amplitude compensation - settled\n\n\nIndicates that the amplitude compensation FSM has reached the SETTLED or TCXOMODE state,\nand the controls configured in HFXTTARG or HFXTDYN are reached.\n*/\nexport const CKMD_IMSET_AMPSETTLED: any = '1'\nexport const CKMD_IMSET_AMPSETTLED_M: any = '1'\nexport const CKMD_IMSET_AMPSETTLED_S: any = '1'\n/**\nHFXT Amplitude compensation - controls at target\n\n\nIndicates that the control values configured in HFXTTARG or HFXTDYN are reached.\nApplies to Q1CAP, Q2CAP and IREF.*/\nexport const CKMD_IMSET_AMPCTRLATTARG: any = '1'\nexport const CKMD_IMSET_AMPCTRLATTARG_M: any = '1'\nexport const CKMD_IMSET_AMPCTRLATTARG_S: any = '1'\n/**\nPre-LF clock edge detect.\n\n\nIndicates that a positive edge occured on the selected pre-LF clock LFCLKSEL.PRE.\nCan be used by software to confirm that a LF clock source is running and within the expected frequency,\nbefore selecting it as the main LF clock source.*/\nexport const CKMD_IMSET_PRELFEDGE: any = '1'\nexport const CKMD_IMSET_PRELFEDGE_M: any = '1'\nexport const CKMD_IMSET_PRELFEDGE_S: any = '1'\n/**\nLF clock is lost.\n\n\nIndicates that no LF clock edge occured for ~49us (~1.6 times nominal period).\nThe system will automatically fall-back to generating LFTICK based on CLKULL,\nto avoid timing corruption.\nNote that this signal is NOT related to the analog LF clock-loss detector which can reset the device during STANDBY.*/\nexport const CKMD_IMSET_LFCLKLOSS: any = '1'\nexport const CKMD_IMSET_LFCLKLOSS_M: any = '1'\nexport const CKMD_IMSET_LFCLKLOSS_S: any = '1'\n/**\nLF clock period out-of-range.\n\n\nIndicates that a LF clock period was measured to be out-of-range,\naccording to LFQUALCTL.MAXERR.*/\nexport const CKMD_IMSET_LFCLKOOR: any = '1'\nexport const CKMD_IMSET_LFCLKOOR_M: any = '1'\nexport const CKMD_IMSET_LFCLKOOR_S: any = '1'\n/**\nLF clock good.\n\n\nIndicates that the LF clock is good, according to the configuration in LFQUALCTL.*/\nexport const CKMD_IMSET_LFCLKGOOD: any = '1'\nexport const CKMD_IMSET_LFCLKGOOD_M: any = '1'\nexport const CKMD_IMSET_LFCLKGOOD_S: any = '1'\n/**\nLFINC updated.\n\n\nIndicates that a new LFINC measurement value is available in LFCLKSTAT.LFINC.*/\nexport const CKMD_IMSET_LFINCUPD: any = '1'\nexport const CKMD_IMSET_LFINCUPD_M: any = '1'\nexport const CKMD_IMSET_LFINCUPD_S: any = '1'\n/**\nTDC done event.\n\n\nIndicates that the TDC measurement is done.*/\nexport const CKMD_IMSET_TDCDONE: any = '1'\nexport const CKMD_IMSET_TDCDONE_M: any = '1'\nexport const CKMD_IMSET_TDCDONE_S: any = '1'\n/**\nHFXT-ADC PEAK measurement update event.\n\n\nIndicates that the HFXT-ADC PEAK measurement is done.*/\nexport const CKMD_IMSET_ADCPEAKUPD: any = '1'\nexport const CKMD_IMSET_ADCPEAKUPD_M: any = '1'\nexport const CKMD_IMSET_ADCPEAKUPD_S: any = '1'\n/**\nHFXT-ADC BIAS measurement update event.\n\n\nIndicates that the HFXT-ADC BIAS measurement is done.*/\nexport const CKMD_IMSET_ADCBIASUPD: any = '1'\nexport const CKMD_IMSET_ADCBIASUPD_M: any = '1'\nexport const CKMD_IMSET_ADCBIASUPD_S: any = '1'\n/**\nHFXT-ADC comparison update event.\n\n\nIndicates that the HFXT-ADC comparison is done.*/\nexport const CKMD_IMSET_ADCCOMPUPD: any = '1'\nexport const CKMD_IMSET_ADCCOMPUPD_M: any = '1'\nexport const CKMD_IMSET_ADCCOMPUPD_S: any = '1'\n/**\nOut-of-range indication from the tracking loop.\n\n\nIndicates that the selected reference clock frequency of the tracking loop is out-of-range.*/\nexport const CKMD_IMSET_TRACKREFOOR: any = '1'\nexport const CKMD_IMSET_TRACKREFOOR_M: any = '1'\nexport const CKMD_IMSET_TRACKREFOOR_S: any = '1'\n/**\nClock loss indication from the tracking loop.\n\n\nIndicates that the selected reference clock of the tracking loop is lost.*/\nexport const CKMD_IMSET_TRACKREFLOSS: any = '1'\nexport const CKMD_IMSET_TRACKREFLOSS_M: any = '1'\nexport const CKMD_IMSET_TRACKREFLOSS_S: any = '1'\n/**\nHFXT amplitude good indication.*/\nexport const CKMD_IMSET_HFXTAMPGOOD: any = '1'\nexport const CKMD_IMSET_HFXTAMPGOOD_M: any = '1'\nexport const CKMD_IMSET_HFXTAMPGOOD_S: any = '1'\n/**\nHFXT fault indication.\n\n\nIndicates that HFXT did not start correctly, or its frequency is too low.\nHFXT will not recover from this fault and has to be restarted.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_IMSET_HFXTFAULT: any = '1'\nexport const CKMD_IMSET_HFXTFAULT_M: any = '1'\nexport const CKMD_IMSET_HFXTFAULT_S: any = '1'\n/**\nHFXT good indication.\n\n\nIndicates that HFXT started correctly. The frequency is not necessarily good enough for radio operation.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_IMSET_HFXTGOOD: any = '1'\nexport const CKMD_IMSET_HFXTGOOD_M: any = '1'\nexport const CKMD_IMSET_HFXTGOOD_S: any = '1'\n\n// -------- REGISTER IMCLR -------- //\n\n/**\nInterrupt mask clear register.\n\n\nWriting a 1 to a bit in this register will clear the corresponding IMASK bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_IMCLR_RESERVED18: any = '14'\nexport const CKMD_IMCLR_RESERVED18_M: any = '14'\nexport const CKMD_IMCLR_RESERVED18_S: any = '14'\n/**\n32kHz TICK to RTC and WDT.\n\n\nEither derived from selected LFCLK or generated from CLKULL in absence of LFCLK.*/\nexport const CKMD_IMCLR_LFTICK: any = '1'\nexport const CKMD_IMCLR_LFTICK_M: any = '1'\nexport const CKMD_IMCLR_LFTICK_S: any = '1'\n/**\nLFINC filter gearing restart.\n\n\nIndicates that the LFINC filter restarted gearing. Subsequent LFINC estimates may have higher variation.*/\nexport const CKMD_IMCLR_LFGEARRSTRT: any = '1'\nexport const CKMD_IMCLR_LFGEARRSTRT_M: any = '1'\nexport const CKMD_IMCLR_LFGEARRSTRT_S: any = '1'\n/**\nHFXT Amplitude compensation - settled\n\n\nIndicates that the amplitude compensation FSM has reached the SETTLED or TCXOMODE state,\nand the controls configured in HFXTTARG or HFXTDYN are reached.\n*/\nexport const CKMD_IMCLR_AMPSETTLED: any = '1'\nexport const CKMD_IMCLR_AMPSETTLED_M: any = '1'\nexport const CKMD_IMCLR_AMPSETTLED_S: any = '1'\n/**\nHFXT Amplitude compensation - controls at target\n\n\nIndicates that the control values configured in HFXTTARG or HFXTDYN are reached.\nApplies to Q1CAP, Q2CAP and IREF.*/\nexport const CKMD_IMCLR_AMPCTRLATTARG: any = '1'\nexport const CKMD_IMCLR_AMPCTRLATTARG_M: any = '1'\nexport const CKMD_IMCLR_AMPCTRLATTARG_S: any = '1'\n/**\nPre-LF clock edge detect.\n\n\nIndicates that a positive edge occured on the selected pre-LF clock LFCLKSEL.PRE.\nCan be used by software to confirm that a LF clock source is running and within the expected frequency,\nbefore selecting it as the main LF clock source.*/\nexport const CKMD_IMCLR_PRELFEDGE: any = '1'\nexport const CKMD_IMCLR_PRELFEDGE_M: any = '1'\nexport const CKMD_IMCLR_PRELFEDGE_S: any = '1'\n/**\nLF clock is lost.\n\n\nIndicates that no LF clock edge occured for ~49us (~1.6 times nominal period).\nThe system will automatically fall-back to generating LFTICK based on CLKULL,\nto avoid timing corruption.\nNote that this signal is NOT related to the analog LF clock-loss detector which can reset the device during STANDBY.*/\nexport const CKMD_IMCLR_LFCLKLOSS: any = '1'\nexport const CKMD_IMCLR_LFCLKLOSS_M: any = '1'\nexport const CKMD_IMCLR_LFCLKLOSS_S: any = '1'\n/**\nLF clock period out-of-range.\n\n\nIndicates that a LF clock period was measured to be out-of-range,\naccording to LFQUALCTL.MAXERR.*/\nexport const CKMD_IMCLR_LFCLKOOR: any = '1'\nexport const CKMD_IMCLR_LFCLKOOR_M: any = '1'\nexport const CKMD_IMCLR_LFCLKOOR_S: any = '1'\n/**\nLF clock good.\n\n\nIndicates that the LF clock is good, according to the configuration in LFQUALCTL.*/\nexport const CKMD_IMCLR_LFCLKGOOD: any = '1'\nexport const CKMD_IMCLR_LFCLKGOOD_M: any = '1'\nexport const CKMD_IMCLR_LFCLKGOOD_S: any = '1'\n/**\nLFINC updated.\n\n\nIndicates that a new LFINC measurement value is available in LFCLKSTAT.LFINC.*/\nexport const CKMD_IMCLR_LFINCUPD: any = '1'\nexport const CKMD_IMCLR_LFINCUPD_M: any = '1'\nexport const CKMD_IMCLR_LFINCUPD_S: any = '1'\n/**\nTDC done event.\n\n\nIndicates that the TDC measurement is done.*/\nexport const CKMD_IMCLR_TDCDONE: any = '1'\nexport const CKMD_IMCLR_TDCDONE_M: any = '1'\nexport const CKMD_IMCLR_TDCDONE_S: any = '1'\n/**\nHFXT-ADC PEAK measurement update event.\n\n\nIndicates that the HFXT-ADC PEAK measurement is done.*/\nexport const CKMD_IMCLR_ADCPEAKUPD: any = '1'\nexport const CKMD_IMCLR_ADCPEAKUPD_M: any = '1'\nexport const CKMD_IMCLR_ADCPEAKUPD_S: any = '1'\n/**\nHFXT-ADC BIAS measurement update event.\n\n\nIndicates that the HFXT-ADC BIAS measurement is done.*/\nexport const CKMD_IMCLR_ADCBIASUPD: any = '1'\nexport const CKMD_IMCLR_ADCBIASUPD_M: any = '1'\nexport const CKMD_IMCLR_ADCBIASUPD_S: any = '1'\n/**\nHFXT-ADC comparison update event.\n\n\nIndicates that the HFXT-ADC comparison is done.*/\nexport const CKMD_IMCLR_ADCCOMPUPD: any = '1'\nexport const CKMD_IMCLR_ADCCOMPUPD_M: any = '1'\nexport const CKMD_IMCLR_ADCCOMPUPD_S: any = '1'\n/**\nOut-of-range indication from the tracking loop.\n\n\nIndicates that the selected reference clock frequency of the tracking loop is out-of-range.*/\nexport const CKMD_IMCLR_TRACKREFOOR: any = '1'\nexport const CKMD_IMCLR_TRACKREFOOR_M: any = '1'\nexport const CKMD_IMCLR_TRACKREFOOR_S: any = '1'\n/**\nClock loss indication from the tracking loop.\n\n\nIndicates that the selected reference clock of the tracking loop is lost.*/\nexport const CKMD_IMCLR_TRACKREFLOSS: any = '1'\nexport const CKMD_IMCLR_TRACKREFLOSS_M: any = '1'\nexport const CKMD_IMCLR_TRACKREFLOSS_S: any = '1'\n/**\nHFXT amplitude good indication.*/\nexport const CKMD_IMCLR_HFXTAMPGOOD: any = '1'\nexport const CKMD_IMCLR_HFXTAMPGOOD_M: any = '1'\nexport const CKMD_IMCLR_HFXTAMPGOOD_S: any = '1'\n/**\nHFXT fault indication.\n\n\nIndicates that HFXT did not start correctly, or its frequency is too low.\nHFXT will not recover from this fault and has to be restarted.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_IMCLR_HFXTFAULT: any = '1'\nexport const CKMD_IMCLR_HFXTFAULT_M: any = '1'\nexport const CKMD_IMCLR_HFXTFAULT_S: any = '1'\n/**\nHFXT good indication.\n\n\nIndicates that HFXT started correctly. The frequency is not necessarily good enough for radio operation.\nThis is only a one-time check at HFXT startup.*/\nexport const CKMD_IMCLR_HFXTGOOD: any = '1'\nexport const CKMD_IMCLR_HFXTGOOD_M: any = '1'\nexport const CKMD_IMCLR_HFXTGOOD_S: any = '1'\n\n// -------- REGISTER HFOSCCTL -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFOSCCTL_PW: any = '8'\nexport const CKMD_HFOSCCTL_PW_M: any = '8'\nexport const CKMD_HFOSCCTL_PW_S: any = '8'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFOSCCTL_RESERVED9: any = '15'\nexport const CKMD_HFOSCCTL_RESERVED9_M: any = '15'\nexport const CKMD_HFOSCCTL_RESERVED9_S: any = '15'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFOSCCTL_CLKSVTOVR: any = '1'\nexport const CKMD_HFOSCCTL_CLKSVTOVR_M: any = '1'\nexport const CKMD_HFOSCCTL_CLKSVTOVR_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFOSCCTL_CLKSVTOVR_HFXT: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFOSCCTL_CLKSVTOVR_HFOSC: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFOSCCTL_RESERVED2: any = '6'\nexport const CKMD_HFOSCCTL_RESERVED2_M: any = '6'\nexport const CKMD_HFOSCCTL_RESERVED2_S: any = '6'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFOSCCTL_FORCEOFF: any = '1'\nexport const CKMD_HFOSCCTL_FORCEOFF_M: any = '1'\nexport const CKMD_HFOSCCTL_FORCEOFF_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFOSCCTL_QUALBYP: any = '1'\nexport const CKMD_HFOSCCTL_QUALBYP_M: any = '1'\nexport const CKMD_HFOSCCTL_QUALBYP_S: any = '1'\n\n// -------- REGISTER HFXTCTL -------- //\n\n/**\nHigh frequency crystal control*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFXTCTL_AMPOVR: any = '1'\nexport const CKMD_HFXTCTL_AMPOVR_M: any = '1'\nexport const CKMD_HFXTCTL_AMPOVR_S: any = '1'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_HFXTCTL_RESERVED27: any = '4'\nexport const CKMD_HFXTCTL_RESERVED27_M: any = '4'\nexport const CKMD_HFXTCTL_RESERVED27_S: any = '4'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFXTCTL_BIASEN: any = '1'\nexport const CKMD_HFXTCTL_BIASEN_M: any = '1'\nexport const CKMD_HFXTCTL_BIASEN_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFXTCTL_LPBUFEN: any = '1'\nexport const CKMD_HFXTCTL_LPBUFEN_M: any = '1'\nexport const CKMD_HFXTCTL_LPBUFEN_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFXTCTL_INJECT: any = '1'\nexport const CKMD_HFXTCTL_INJECT_M: any = '1'\nexport const CKMD_HFXTCTL_INJECT_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFXTCTL_QUALBYP: any = '1'\nexport const CKMD_HFXTCTL_QUALBYP_M: any = '1'\nexport const CKMD_HFXTCTL_QUALBYP_S: any = '1'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_HFXTCTL_RESERVED20: any = '3'\nexport const CKMD_HFXTCTL_RESERVED20_M: any = '3'\nexport const CKMD_HFXTCTL_RESERVED20_S: any = '3'\n/**\nSkip potentially unstable clock cycles after enabling HFXT.\n\nNumber of cycles skipped is 8*QUALDLY.*/\nexport const CKMD_HFXTCTL_QUALDLY: any = '12'\nexport const CKMD_HFXTCTL_QUALDLY_M: any = '12'\nexport const CKMD_HFXTCTL_QUALDLY_S: any = '12'\n/**\nTemperature compensated crystal oscillator mode.\n\n\nSet this bit if a TXCO is connected.*/\nexport const CKMD_HFXTCTL_TCXOMODE: any = '1'\nexport const CKMD_HFXTCTL_TCXOMODE_M: any = '1'\nexport const CKMD_HFXTCTL_TCXOMODE_S: any = '1'\n/**\nType of temperature compensated crystal used.\n\n\nOnly has effect if TCXOMODE is set.*/\nexport const CKMD_HFXTCTL_TCXOTYPE: any = '1'\nexport const CKMD_HFXTCTL_TCXOTYPE_M: any = '1'\nexport const CKMD_HFXTCTL_TCXOTYPE_S: any = '1'\n/**\nUse with CMOS TCXO*/\nexport const CKMD_HFXTCTL_TCXOTYPE_CMOS: any = '1'\n\n/**\nUse with clipped-sine TCXO*/\nexport const CKMD_HFXTCTL_TCXOTYPE_CLIPPEDSINE: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_HFXTCTL_RESERVED3: any = '3'\nexport const CKMD_HFXTCTL_RESERVED3_M: any = '3'\nexport const CKMD_HFXTCTL_RESERVED3_S: any = '3'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFXTCTL_AUTOEN: any = '1'\nexport const CKMD_HFXTCTL_AUTOEN_M: any = '1'\nexport const CKMD_HFXTCTL_AUTOEN_S: any = '1'\n/**\nHigh performance clock buffer enable.\n\n\nThis bit controls the clock output for the RF PLL.\nIt is required for radio operation.*/\nexport const CKMD_HFXTCTL_HPBUFEN: any = '1'\nexport const CKMD_HFXTCTL_HPBUFEN_M: any = '1'\nexport const CKMD_HFXTCTL_HPBUFEN_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_HFXTCTL_EN: any = '1'\nexport const CKMD_HFXTCTL_EN_M: any = '1'\nexport const CKMD_HFXTCTL_EN_S: any = '1'\n\n// -------- REGISTER LFOSCCTL -------- //\n\n/**\nLow frequency oscillator control*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_LFOSCCTL_RESERVED1: any = '31'\nexport const CKMD_LFOSCCTL_RESERVED1_M: any = '31'\nexport const CKMD_LFOSCCTL_RESERVED1_S: any = '31'\n/**\nLFOSC enable*/\nexport const CKMD_LFOSCCTL_EN: any = '1'\nexport const CKMD_LFOSCCTL_EN_M: any = '1'\nexport const CKMD_LFOSCCTL_EN_S: any = '1'\n\n// -------- REGISTER LFXTCTL -------- //\n\n/**\nLow frequency crystal control*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_LFXTCTL_RESERVED15: any = '17'\nexport const CKMD_LFXTCTL_RESERVED15_M: any = '17'\nexport const CKMD_LFXTCTL_RESERVED15_S: any = '17'\n/**\nLeakage compensation control*/\nexport const CKMD_LFXTCTL_LEAKCOMP: any = '2'\nexport const CKMD_LFXTCTL_LEAKCOMP_M: any = '2'\nexport const CKMD_LFXTCTL_LEAKCOMP_S: any = '2'\n/**\nNo leakage compensation*/\nexport const CKMD_LFXTCTL_LEAKCOMP_OFF: any = '3'\n\n/**\nHalf leakage compensation*/\nexport const CKMD_LFXTCTL_LEAKCOMP_HALF: any = '1'\n\n/**\nFull leakage compensation*/\nexport const CKMD_LFXTCTL_LEAKCOMP_FULL: any = '0'\n\n/**\nControl the BIAS current of the input amp in LP buffer*/\nexport const CKMD_LFXTCTL_BUFBIAS: any = '1'\nexport const CKMD_LFXTCTL_BUFBIAS_M: any = '1'\nexport const CKMD_LFXTCTL_BUFBIAS_S: any = '1'\n/**\nMaximum bias current: 50nA*/\nexport const CKMD_LFXTCTL_BUFBIAS_MAX: any = '1'\n\n/**\nMinimum bias current: 25nA*/\nexport const CKMD_LFXTCTL_BUFBIAS_MIN: any = '0'\n\n/**\nAdjust current mirror ratio into oscillator core.\u00a0This value is depending on crystal and is set by FW.\u00a0This field uses a 2's complement encoding.*/\nexport const CKMD_LFXTCTL_AMPBIAS: any = '4'\nexport const CKMD_LFXTCTL_AMPBIAS_M: any = '4'\nexport const CKMD_LFXTCTL_AMPBIAS_S: any = '4'\n/**\nBoost oscillator amplitude\n\n\nThis value depends on the crystal and needs to be configured by Firmware.*/\nexport const CKMD_LFXTCTL_BIASBOOST: any = '2'\nexport const CKMD_LFXTCTL_BIASBOOST_M: any = '2'\nexport const CKMD_LFXTCTL_BIASBOOST_S: any = '2'\n/**\nRegulation loop bias resistor value\n\n\nThis value depends on the crystal and needs to be configured by Firmware.*/\nexport const CKMD_LFXTCTL_REGBIAS: any = '2'\nexport const CKMD_LFXTCTL_REGBIAS_M: any = '2'\nexport const CKMD_LFXTCTL_REGBIAS_S: any = '2'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_LFXTCTL_RESERVED3: any = '1'\nexport const CKMD_LFXTCTL_RESERVED3_M: any = '1'\nexport const CKMD_LFXTCTL_RESERVED3_S: any = '1'\n/**\nControl the buffer used. In normal operation, low-power buffer is used in all device modes. The high-performance buffer is only used for test purposes.\n\n*/\nexport const CKMD_LFXTCTL_HPBUFEN: any = '1'\nexport const CKMD_LFXTCTL_HPBUFEN_M: any = '1'\nexport const CKMD_LFXTCTL_HPBUFEN_S: any = '1'\n/**\nAmplitude regulation mode*/\nexport const CKMD_LFXTCTL_AMPREGMODE: any = '1'\nexport const CKMD_LFXTCTL_AMPREGMODE_M: any = '1'\nexport const CKMD_LFXTCTL_AMPREGMODE_S: any = '1'\n/**\nAmplitude control loop disabled*/\nexport const CKMD_LFXTCTL_AMPREGMODE_LOOPDIS: any = '1'\n\n/**\nAmplitude control loop enabled*/\nexport const CKMD_LFXTCTL_AMPREGMODE_LOOPEN: any = '0'\n\n/**\nLFXT enable*/\nexport const CKMD_LFXTCTL_EN: any = '1'\nexport const CKMD_LFXTCTL_EN_M: any = '1'\nexport const CKMD_LFXTCTL_EN_S: any = '1'\n\n// -------- REGISTER LFQUALCTL -------- //\n\n/**\nLow frequency clock qualification control*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_LFQUALCTL_RESERVED14: any = '18'\nexport const CKMD_LFQUALCTL_RESERVED14_M: any = '18'\nexport const CKMD_LFQUALCTL_RESERVED14_S: any = '18'\n/**\nMaximum LFCLK period error.\n\n\nValue given in microseconds, 3 integer bits + 3 fractional bits.*/\nexport const CKMD_LFQUALCTL_MAXERR: any = '6'\nexport const CKMD_LFQUALCTL_MAXERR_M: any = '6'\nexport const CKMD_LFQUALCTL_MAXERR_S: any = '6'\n/**\nNumber of consecutive times the LFCLK period error has to be \n\nsmaller than MAXERR to be considered \"good\".\nSetting this value to 0 will bypass clock qualification,\nand the \"good\" indicator will always be 1.*/\nexport const CKMD_LFQUALCTL_CONSEC: any = '8'\nexport const CKMD_LFQUALCTL_CONSEC_M: any = '8'\nexport const CKMD_LFQUALCTL_CONSEC_S: any = '8'\n\n// -------- REGISTER LFINCCTL -------- //\n\n/**\nLow frequency time increment control*/\n/**\nControls if the LFINC filter prevents STANBY entry until settled.\n\n*/\nexport const CKMD_LFINCCTL_PREVENTSTBY: any = '1'\nexport const CKMD_LFINCCTL_PREVENTSTBY_M: any = '1'\nexport const CKMD_LFINCCTL_PREVENTSTBY_S: any = '1'\n/**\nEnable. Prevent STANDBY entry.*/\nexport const CKMD_LFINCCTL_PREVENTSTBY_ON: any = '1'\n\n/**\nDisable. Do not prevent STANDBY entry.*/\nexport const CKMD_LFINCCTL_PREVENTSTBY_OFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_LFINCCTL_RESERVED30: any = '1'\nexport const CKMD_LFINCCTL_RESERVED30_M: any = '1'\nexport const CKMD_LFINCCTL_RESERVED30_S: any = '1'\n/**\nIntegral part of the LFINC filter.\n\n\nThis value is updated by Hardware to reflect the current state of the filter.\nIt can also be written to change the current state.*/\nexport const CKMD_LFINCCTL_INT: any = '22'\nexport const CKMD_LFINCCTL_INT_M: any = '22'\nexport const CKMD_LFINCCTL_INT_S: any = '22'\n/**\nControls the final gear of the LFINC filter.*/\nexport const CKMD_LFINCCTL_STOPGEAR: any = '1'\nexport const CKMD_LFINCCTL_STOPGEAR_M: any = '1'\nexport const CKMD_LFINCCTL_STOPGEAR_S: any = '1'\n/**\nHighest final gear. Best dynamic frequency tracking, but higher variation in filter value.*/\nexport const CKMD_LFINCCTL_STOPGEAR_HIGH: any = '1'\n\n/**\nLowest final gear. Best settling, but less dynamic frequency tracking.*/\nexport const CKMD_LFINCCTL_STOPGEAR_LOW: any = '0'\n\n/**\nControls the threshold for gearing restart of the LFINC filter.\n\n\nOnly effective if GEARRSTRT is not ONETHR or TWOTHR.*/\nexport const CKMD_LFINCCTL_ERRTHR: any = '2'\nexport const CKMD_LFINCCTL_ERRTHR_M: any = '2'\nexport const CKMD_LFINCCTL_ERRTHR_S: any = '2'\n/**\nRestart gearing on small error. Potentially more false restarts, faster response on small frequency shifts.*/\nexport const CKMD_LFINCCTL_ERRTHR_SMALL: any = '3'\n\n/**\nMiddle value towards SMALL.*/\nexport const CKMD_LFINCCTL_ERRTHR_MIDSMALL: any = '2'\n\n/**\nMiddle value towards LARGE.*/\nexport const CKMD_LFINCCTL_ERRTHR_MIDLARGE: any = '1'\n\n/**\nRestart gearing on large error. Fewer false restarts, slower response on small frequency shifts.*/\nexport const CKMD_LFINCCTL_ERRTHR_LARGE: any = '0'\n\n/**\nControls gearing restart of the LFINC filter.*/\nexport const CKMD_LFINCCTL_GEARRSTRT: any = '2'\nexport const CKMD_LFINCCTL_GEARRSTRT_M: any = '2'\nexport const CKMD_LFINCCTL_GEARRSTRT_S: any = '2'\n/**\nRestart gearing when the error accumulator crosses the threshold twice in a row.*/\nexport const CKMD_LFINCCTL_GEARRSTRT_TWOTHR: any = '2'\n\n/**\nRestart gearing when the error accumulator crosses the threshold once.*/\nexport const CKMD_LFINCCTL_GEARRSTRT_ONETHR: any = '1'\n\n/**\nNever restart gearing. Very stable filter value, but very slow response on frequency changes.*/\nexport const CKMD_LFINCCTL_GEARRSTRT_NEVER: any = '0'\n\n/**\nUse a higher gear after re-enabling / wakeup.\n\n\nThe filter will require 16-24 LFCLK periods to settle (depending on STOPGEAR), but may respond faster to frequency changes during STANDBY.*/\nexport const CKMD_LFINCCTL_SOFTRSTRT: any = '1'\nexport const CKMD_LFINCCTL_SOFTRSTRT_M: any = '1'\nexport const CKMD_LFINCCTL_SOFTRSTRT_S: any = '1'\n/**\nUse soft gearing restarts*/\nexport const CKMD_LFINCCTL_SOFTRSTRT_ON: any = '1'\n\n/**\nDon't use soft gearing restarts*/\nexport const CKMD_LFINCCTL_SOFTRSTRT_OFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_LFINCCTL_RESERVED0: any = '2'\nexport const CKMD_LFINCCTL_RESERVED0_M: any = '2'\nexport const CKMD_LFINCCTL_RESERVED0_S: any = '2'\n\n// -------- REGISTER LFINCOVR -------- //\n\n/**\nLow frequency time increment override control*/\n/**\nOverride LF increment\n\n\nUse the value provided in LFINC instead of the value calculated by Hardware.*/\nexport const CKMD_LFINCOVR_OVERRIDE: any = '1'\nexport const CKMD_LFINCOVR_OVERRIDE_M: any = '1'\nexport const CKMD_LFINCOVR_OVERRIDE_S: any = '1'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_LFINCOVR_RESERVED22: any = '9'\nexport const CKMD_LFINCOVR_RESERVED22_M: any = '9'\nexport const CKMD_LFINCOVR_RESERVED22_S: any = '9'\n/**\nLF increment value\n\n\nThis value is used when OVERRIDE is set to 1.\nOtherwise the value is calculated automatically.*/\nexport const CKMD_LFINCOVR_LFINC: any = '22'\nexport const CKMD_LFINCOVR_LFINC_M: any = '22'\nexport const CKMD_LFINCOVR_LFINC_S: any = '22'\n\n// -------- REGISTER AMPADCCTL -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_SWOVR: any = '1'\nexport const CKMD_AMPADCCTL_SWOVR_M: any = '1'\nexport const CKMD_AMPADCCTL_SWOVR_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_RESERVED18: any = '13'\nexport const CKMD_AMPADCCTL_RESERVED18_M: any = '13'\nexport const CKMD_AMPADCCTL_RESERVED18_S: any = '13'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_PEAKDETEN: any = '1'\nexport const CKMD_AMPADCCTL_PEAKDETEN_M: any = '1'\nexport const CKMD_AMPADCCTL_PEAKDETEN_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_PEAKDETEN_ENABLE: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_PEAKDETEN_DISABLE: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_ADCEN: any = '1'\nexport const CKMD_AMPADCCTL_ADCEN_M: any = '1'\nexport const CKMD_AMPADCCTL_ADCEN_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_ADCEN_ENABLE: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_ADCEN_DISABLE: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_RESERVED15: any = '1'\nexport const CKMD_AMPADCCTL_RESERVED15_M: any = '1'\nexport const CKMD_AMPADCCTL_RESERVED15_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_COMPVAL: any = '7'\nexport const CKMD_AMPADCCTL_COMPVAL_M: any = '7'\nexport const CKMD_AMPADCCTL_COMPVAL_S: any = '7'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_RESERVED5: any = '3'\nexport const CKMD_AMPADCCTL_RESERVED5_M: any = '3'\nexport const CKMD_AMPADCCTL_RESERVED5_S: any = '3'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_SRCSEL: any = '1'\nexport const CKMD_AMPADCCTL_SRCSEL_M: any = '1'\nexport const CKMD_AMPADCCTL_SRCSEL_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_SRCSEL_PEAK: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_SRCSEL_BIAS: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_RESERVED2: any = '2'\nexport const CKMD_AMPADCCTL_RESERVED2_M: any = '2'\nexport const CKMD_AMPADCCTL_RESERVED2_S: any = '2'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_COMPSTRT: any = '1'\nexport const CKMD_AMPADCCTL_COMPSTRT_M: any = '1'\nexport const CKMD_AMPADCCTL_COMPSTRT_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCCTL_SARSTRT: any = '1'\nexport const CKMD_AMPADCCTL_SARSTRT_M: any = '1'\nexport const CKMD_AMPADCCTL_SARSTRT_S: any = '1'\n\n// -------- REGISTER HFTRACKCTL -------- //\n\n/**\nHigh frequency tracking loop control*/\n/**\nEnable tracking loop.*/\nexport const CKMD_HFTRACKCTL_EN: any = '1'\nexport const CKMD_HFTRACKCTL_EN_M: any = '1'\nexport const CKMD_HFTRACKCTL_EN_S: any = '1'\n/**\nBypass Delta-Sigma-Modulation of fine trim.*/\nexport const CKMD_HFTRACKCTL_DSMBYP: any = '1'\nexport const CKMD_HFTRACKCTL_DSMBYP_M: any = '1'\nexport const CKMD_HFTRACKCTL_DSMBYP_S: any = '1'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_HFTRACKCTL_RESERVED28: any = '2'\nexport const CKMD_HFTRACKCTL_RESERVED28_M: any = '2'\nexport const CKMD_HFTRACKCTL_RESERVED28_S: any = '2'\n/**\nSelect the reference clock for the tracking loop.\n\nChange only while the tracking loop is disabled.*/\nexport const CKMD_HFTRACKCTL_REFCLK: any = '2'\nexport const CKMD_HFTRACKCTL_REFCLK_M: any = '2'\nexport const CKMD_HFTRACKCTL_REFCLK_S: any = '2'\n/**\nSelect GPI as reference clock.*/\nexport const CKMD_HFTRACKCTL_REFCLK_GPI: any = '2'\n\n/**\nSelect LRF reference clock.*/\nexport const CKMD_HFTRACKCTL_REFCLK_LRF: any = '1'\n\n/**\nSelect HFXT as reference clock.*/\nexport const CKMD_HFTRACKCTL_REFCLK_HFXT: any = '0'\n\n/**\nReference clock ratio.\n\n\nRATIO = 24MHz / (2*reference-frequency) * 2^24\nCommonly used reference clock frequencies are provided as enumerations.\n*/\nexport const CKMD_HFTRACKCTL_RATIO: any = '26'\nexport const CKMD_HFTRACKCTL_RATIO_M: any = '26'\nexport const CKMD_HFTRACKCTL_RATIO_S: any = '26'\n/**\nUse for 4MHz reference clock*/\nexport const CKMD_HFTRACKCTL_RATIO_REF4M: any = '50331648'\n\n/**\nUse for 8MHz reference clock*/\nexport const CKMD_HFTRACKCTL_RATIO_REF8M: any = '25165824'\n\n/**\nUse for 48MHz reference clock*/\nexport const CKMD_HFTRACKCTL_RATIO_REF48M: any = '4194304'\n\n\n// -------- REGISTER LDOCTL -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_LDOCTL_SWOVR: any = '1'\nexport const CKMD_LDOCTL_SWOVR_M: any = '1'\nexport const CKMD_LDOCTL_SWOVR_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_LDOCTL_RESERVED5: any = '26'\nexport const CKMD_LDOCTL_RESERVED5_M: any = '26'\nexport const CKMD_LDOCTL_RESERVED5_S: any = '26'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_LDOCTL_HFXTLVLEN: any = '1'\nexport const CKMD_LDOCTL_HFXTLVLEN_M: any = '1'\nexport const CKMD_LDOCTL_HFXTLVLEN_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_LDOCTL_STARTCTL: any = '1'\nexport const CKMD_LDOCTL_STARTCTL_M: any = '1'\nexport const CKMD_LDOCTL_STARTCTL_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_LDOCTL_START: any = '1'\nexport const CKMD_LDOCTL_START_M: any = '1'\nexport const CKMD_LDOCTL_START_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_LDOCTL_BYPASS: any = '1'\nexport const CKMD_LDOCTL_BYPASS_M: any = '1'\nexport const CKMD_LDOCTL_BYPASS_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_LDOCTL_EN: any = '1'\nexport const CKMD_LDOCTL_EN_M: any = '1'\nexport const CKMD_LDOCTL_EN_S: any = '1'\n\n// -------- REGISTER NABIASCTL -------- //\n\n/**\nNanoamp-bias control*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_NABIASCTL_RESERVED1: any = '31'\nexport const CKMD_NABIASCTL_RESERVED1_M: any = '31'\nexport const CKMD_NABIASCTL_RESERVED1_S: any = '31'\n/**\nEnable nanoamp-bias*/\nexport const CKMD_NABIASCTL_EN: any = '1'\nexport const CKMD_NABIASCTL_EN_M: any = '1'\nexport const CKMD_NABIASCTL_EN_S: any = '1'\n\n// -------- REGISTER LFMONCTL -------- //\n\n/**\nLow-frequency clock-monitor control*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_LFMONCTL_RESERVED1: any = '31'\nexport const CKMD_LFMONCTL_RESERVED1_M: any = '31'\nexport const CKMD_LFMONCTL_RESERVED1_S: any = '31'\n/**\nEnable LFMONITOR.\n\nEnable only after a LF clock source has been selected, enabled and is stable.\nIf LFMONITOR detects a clock loss, the system will be reset.*/\nexport const CKMD_LFMONCTL_EN: any = '1'\nexport const CKMD_LFMONCTL_EN_M: any = '1'\nexport const CKMD_LFMONCTL_EN_S: any = '1'\n\n// -------- REGISTER LFCLKSEL -------- //\n\n/**\nLow frequency clock selection*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_LFCLKSEL_RESERVED4: any = '28'\nexport const CKMD_LFCLKSEL_RESERVED4_M: any = '28'\nexport const CKMD_LFCLKSEL_RESERVED4_S: any = '28'\n/**\nSelect low frequency clock source for the PRELFCLK interrupt.\n\n\nCan be used by Software to confirm that the clock is running and it's frequency is good, before selecting it in MAIN.*/\nexport const CKMD_LFCLKSEL_PRE: any = '2'\nexport const CKMD_LFCLKSEL_PRE_M: any = '2'\nexport const CKMD_LFCLKSEL_PRE_S: any = '2'\n/**\nExternal LF clock through GPI.*/\nexport const CKMD_LFCLKSEL_PRE_EXTLF: any = '3'\n\n/**\nLow frequency crystal oscillator*/\nexport const CKMD_LFCLKSEL_PRE_LFXT: any = '2'\n\n/**\nLow frequency on-chip oscillator*/\nexport const CKMD_LFCLKSEL_PRE_LFOSC: any = '1'\n\n/**\nNo clock. Output will be tied low.*/\nexport const CKMD_LFCLKSEL_PRE_NONE: any = '0'\n\n/**\nSelect the main low frequency clock source.\n\n\nIf running, this clock will be used to generate LFTICK and as CLKULL during STANDBY.\nIf not running, LFTICK will be generated from HFOSC and STANDBY entry will be prevented.*/\nexport const CKMD_LFCLKSEL_MAIN: any = '2'\nexport const CKMD_LFCLKSEL_MAIN_M: any = '2'\nexport const CKMD_LFCLKSEL_MAIN_S: any = '2'\n/**\nExternal LF clock through GPI.*/\nexport const CKMD_LFCLKSEL_MAIN_EXTLF: any = '3'\n\n/**\nLow frequency crystal oscillator*/\nexport const CKMD_LFCLKSEL_MAIN_LFXT: any = '2'\n\n/**\nLow frequency on-chip oscillator*/\nexport const CKMD_LFCLKSEL_MAIN_LFOSC: any = '1'\n\n/**\nNo LF clock selected. LFTICK will be generated from HFOSC, STANDBY entry will be prevented.*/\nexport const CKMD_LFCLKSEL_MAIN_FAKE: any = '0'\n\n\n// -------- REGISTER TDCCLKSEL -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCLKSEL_RESERVED2: any = '30'\nexport const CKMD_TDCCLKSEL_RESERVED2_M: any = '30'\nexport const CKMD_TDCCLKSEL_RESERVED2_S: any = '30'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCLKSEL_REFCLK: any = '2'\nexport const CKMD_TDCCLKSEL_REFCLK_M: any = '2'\nexport const CKMD_TDCCLKSEL_REFCLK_S: any = '2'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCLKSEL_REFCLK_GPI: any = '3'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCLKSEL_REFCLK_CLKULL: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCLKSEL_REFCLK_CLKSVT: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCLKSEL_REFCLK_NONE: any = '0'\n\n\n// -------- REGISTER ADCCLKSEL -------- //\n\n/**\nADC clock selection*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_ADCCLKSEL_RESERVED2: any = '30'\nexport const CKMD_ADCCLKSEL_RESERVED2_M: any = '30'\nexport const CKMD_ADCCLKSEL_RESERVED2_S: any = '30'\n/**\nSelect ADC clock source\n\n\nChange only while ADC is disabled.*/\nexport const CKMD_ADCCLKSEL_SRC: any = '2'\nexport const CKMD_ADCCLKSEL_SRC_M: any = '2'\nexport const CKMD_ADCCLKSEL_SRC_S: any = '2'\n/**\n48MHz HFXT*/\nexport const CKMD_ADCCLKSEL_SRC_HFXT: any = '1'\n\n/**\n48MHz CLKSVT*/\nexport const CKMD_ADCCLKSEL_SRC_CLKSVT: any = '0'\n\n\n// -------- REGISTER LFCLKSTAT -------- //\n\n/**\nLow-frequency clock status*/\n/**\nLow frequency clock good\n\n\nNote: This is only a coarse frequency check based on LFQUALCTL. The clock may not be accurate enough for timing purposes.*/\nexport const CKMD_LFCLKSTAT_GOOD: any = '1'\nexport const CKMD_LFCLKSTAT_GOOD_M: any = '1'\nexport const CKMD_LFCLKSTAT_GOOD_S: any = '1'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_LFCLKSTAT_RESERVED26: any = '5'\nexport const CKMD_LFCLKSTAT_RESERVED26_M: any = '5'\nexport const CKMD_LFCLKSTAT_RESERVED26_S: any = '5'\n/**\nLFINC filter is running and settled.*/\nexport const CKMD_LFCLKSTAT_FLTSETTLED: any = '1'\nexport const CKMD_LFCLKSTAT_FLTSETTLED_M: any = '1'\nexport const CKMD_LFCLKSTAT_FLTSETTLED_S: any = '1'\n/**\nSource of LFTICK.*/\nexport const CKMD_LFCLKSTAT_LFTICKSRC: any = '1'\nexport const CKMD_LFCLKSTAT_LFTICKSRC_M: any = '1'\nexport const CKMD_LFCLKSTAT_LFTICKSRC_S: any = '1'\n/**\nLFTICK generated from CLKULL (LFCLK not available)*/\nexport const CKMD_LFCLKSTAT_LFTICKSRC_FAKE: any = '1'\n\n/**\nLFTICK generated from the selected LFCLK*/\nexport const CKMD_LFCLKSTAT_LFTICKSRC_LFCLK: any = '0'\n\n/**\nSource of LFINC used by the RTC.\n\n\nThis value depends on LFINCOVR.OVERRIDE, LF clock availability, HF tracking loop status and the device state (ACTIVE/STANDBY).*/\nexport const CKMD_LFCLKSTAT_LFINCSRC: any = '2'\nexport const CKMD_LFCLKSTAT_LFINCSRC_M: any = '2'\nexport const CKMD_LFCLKSTAT_LFINCSRC_S: any = '2'\n/**\nUsing FAKE LFTICKs with corresponding LFINC value.*/\nexport const CKMD_LFCLKSTAT_LFINCSRC_FAKE: any = '3'\n\n/**\nUsing override value from LFINCOVR.LFINC*/\nexport const CKMD_LFCLKSTAT_LFINCSRC_OVERRIDE: any = '2'\n\n/**\nUsing filtered / average value.\n\nThis value is updated by hardware and can be read and updated in LFINCCTL.INT.*/\nexport const CKMD_LFCLKSTAT_LFINCSRC_AVG: any = '1'\n\n/**\nUsing measured value.\n\nThis value is updated by hardware and can be read from LFINC.*/\nexport const CKMD_LFCLKSTAT_LFINCSRC_MEAS: any = '0'\n\n/**\nMeasured value of LFINC.\n\n\nGiven in microseconds with 16 fractional bits.\nThis value is calculated by Hardware.\nIt is the LFCLK period according to CLKULL cycles.*/\nexport const CKMD_LFCLKSTAT_LFINC: any = '22'\nexport const CKMD_LFCLKSTAT_LFINC_M: any = '22'\nexport const CKMD_LFCLKSTAT_LFINC_S: any = '22'\n\n// -------- REGISTER HFXTSTAT -------- //\n\n/**\nHFXT status information*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_HFXTSTAT_RESERVED31: any = '1'\nexport const CKMD_HFXTSTAT_RESERVED31_M: any = '1'\nexport const CKMD_HFXTSTAT_RESERVED31_S: any = '1'\n/**\nHFXT startup time\n\n\nCan be used by software to plan starting HFXT ahead in time.\nMeasured whenever HFXT is enabled in CLKULL periods (24MHz), from HFXTCTL.EN until the clock is good for radio operation (amplitude compensation is settled).*/\nexport const CKMD_HFXTSTAT_STARTUPTIME: any = '15'\nexport const CKMD_HFXTSTAT_STARTUPTIME_M: any = '15'\nexport const CKMD_HFXTSTAT_STARTUPTIME_S: any = '15'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_HFXTSTAT_RESERVED2: any = '14'\nexport const CKMD_HFXTSTAT_RESERVED2_M: any = '14'\nexport const CKMD_HFXTSTAT_RESERVED2_S: any = '14'\n/**\nHFXT clock fault\n\n\nIndicates a lower than expected HFXT frequency.\nHFXT will not recover from this fault, disabling and re-enabling HFXT is required.*/\nexport const CKMD_HFXTSTAT_FAULT: any = '1'\nexport const CKMD_HFXTSTAT_FAULT_M: any = '1'\nexport const CKMD_HFXTSTAT_FAULT_S: any = '1'\n/**\nHFXT clock available.\n\n\nThe frequency is not necessarily good enough for radio operation.*/\nexport const CKMD_HFXTSTAT_GOOD: any = '1'\nexport const CKMD_HFXTSTAT_GOOD_M: any = '1'\nexport const CKMD_HFXTSTAT_GOOD_S: any = '1'\n\n// -------- REGISTER AMPADCSTAT -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCSTAT_RESERVED25: any = '7'\nexport const CKMD_AMPADCSTAT_RESERVED25_M: any = '7'\nexport const CKMD_AMPADCSTAT_RESERVED25_S: any = '7'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCSTAT_COMPOUT: any = '1'\nexport const CKMD_AMPADCSTAT_COMPOUT_M: any = '1'\nexport const CKMD_AMPADCSTAT_COMPOUT_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCSTAT_RESERVED23: any = '1'\nexport const CKMD_AMPADCSTAT_RESERVED23_M: any = '1'\nexport const CKMD_AMPADCSTAT_RESERVED23_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCSTAT_PEAKRAW: any = '7'\nexport const CKMD_AMPADCSTAT_PEAKRAW_M: any = '7'\nexport const CKMD_AMPADCSTAT_PEAKRAW_S: any = '7'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCSTAT_PEAK: any = '8'\nexport const CKMD_AMPADCSTAT_PEAK_M: any = '8'\nexport const CKMD_AMPADCSTAT_PEAK_S: any = '8'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCSTAT_RESERVED7: any = '1'\nexport const CKMD_AMPADCSTAT_RESERVED7_M: any = '1'\nexport const CKMD_AMPADCSTAT_RESERVED7_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_AMPADCSTAT_BIAS: any = '7'\nexport const CKMD_AMPADCSTAT_BIAS_M: any = '7'\nexport const CKMD_AMPADCSTAT_BIAS_S: any = '7'\n\n// -------- REGISTER TRACKSTAT -------- //\n\n/**\nHFOSC tracking loop status information*/\n/**\nCurrent HFOSC tracking error valid\n\n\nThis bit is one if the tracking loop is running and the error value is valid.*/\nexport const CKMD_TRACKSTAT_LOOPERRVLD: any = '1'\nexport const CKMD_TRACKSTAT_LOOPERRVLD_M: any = '1'\nexport const CKMD_TRACKSTAT_LOOPERRVLD_S: any = '1'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_TRACKSTAT_RESERVED30: any = '1'\nexport const CKMD_TRACKSTAT_RESERVED30_M: any = '1'\nexport const CKMD_TRACKSTAT_RESERVED30_S: any = '1'\n/**\nCurrent HFOSC tracking error*/\nexport const CKMD_TRACKSTAT_LOOPERR: any = '14'\nexport const CKMD_TRACKSTAT_LOOPERR_M: any = '14'\nexport const CKMD_TRACKSTAT_LOOPERR_S: any = '14'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_TRACKSTAT_RESERVED13: any = '3'\nexport const CKMD_TRACKSTAT_RESERVED13_M: any = '3'\nexport const CKMD_TRACKSTAT_RESERVED13_S: any = '3'\n/**\nCurrent HFOSC Fine-trim value\n\n\nThis field uses the internal fractional representation (sign, 4 integer bits, 8 fractional bits).\nThe actual trim value applied to the oscillator is delta-sigma modulated 5 bits non-signed\n(inverted sign bit + integer bits).\n\n*/\nexport const CKMD_TRACKSTAT_FINETRIM: any = '13'\nexport const CKMD_TRACKSTAT_FINETRIM_M: any = '13'\nexport const CKMD_TRACKSTAT_FINETRIM_S: any = '13'\n\n// -------- REGISTER AMPSTAT -------- //\n\n/**\nHFXT Amplitude Compensation Status*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_AMPSTAT_RESERVED29: any = '3'\nexport const CKMD_AMPSTAT_RESERVED29_M: any = '3'\nexport const CKMD_AMPSTAT_RESERVED29_S: any = '3'\n/**\nCurrent AMPCOMP FSM state.*/\nexport const CKMD_AMPSTAT_STATE: any = '4'\nexport const CKMD_AMPSTAT_STATE_M: any = '4'\nexport const CKMD_AMPSTAT_STATE_S: any = '4'\n/**\nSettled state*/\nexport const CKMD_AMPSTAT_STATE_SETTLED: any = '15'\n\n/**\nAmplitude up correction*/\nexport const CKMD_AMPSTAT_STATE_UPDATEUP: any = '14'\n\n/**\nTCXO settled state*/\nexport const CKMD_AMPSTAT_STATE_TXCOMODE: any = '12'\n\n/**\nFirst shutdown state*/\nexport const CKMD_AMPSTAT_STATE_SHUTDN0: any = '10'\n\n/**\nPost injection settle wait*/\nexport const CKMD_AMPSTAT_STATE_INJWAIT: any = '7'\n\n/**\nAmplitude down correction*/\nexport const CKMD_AMPSTAT_STATE_UPDATEDN: any = '6'\n\n/**\nInitial amplitude ramping with HFXTINIT values*/\nexport const CKMD_AMPSTAT_STATE_RAMP0: any = '5'\n\n/**\nTransition to HFXTTARG values*/\nexport const CKMD_AMPSTAT_STATE_RAMP1: any = '4'\n\n/**\nInjecting HFOSC for fast startup*/\nexport const CKMD_AMPSTAT_STATE_INJECT: any = '3'\n\n/**\nSecond shutdown state*/\nexport const CKMD_AMPSTAT_STATE_SHUTDN1: any = '2'\n\n/**\nStarting LDO*/\nexport const CKMD_AMPSTAT_STATE_LDOSTART: any = '1'\n\n/**\nFSM in idle state*/\nexport const CKMD_AMPSTAT_STATE_IDLE: any = '0'\n\n/**\nCurrent IDAC control value.*/\nexport const CKMD_AMPSTAT_IDAC: any = '7'\nexport const CKMD_AMPSTAT_IDAC_M: any = '7'\nexport const CKMD_AMPSTAT_IDAC_S: any = '7'\n/**\nCurrent IREF control value.*/\nexport const CKMD_AMPSTAT_IREF: any = '4'\nexport const CKMD_AMPSTAT_IREF_M: any = '4'\nexport const CKMD_AMPSTAT_IREF_S: any = '4'\n/**\nCurrent Q2CAP control value.*/\nexport const CKMD_AMPSTAT_Q2CAP: any = '6'\nexport const CKMD_AMPSTAT_Q2CAP_M: any = '6'\nexport const CKMD_AMPSTAT_Q2CAP_S: any = '6'\n/**\nCurrent Q1CAP control value.*/\nexport const CKMD_AMPSTAT_Q1CAP: any = '6'\nexport const CKMD_AMPSTAT_Q1CAP_M: any = '6'\nexport const CKMD_AMPSTAT_Q1CAP_S: any = '6'\n/**\nHFXT control values match target values.\n\n\nThis applies to IREF, Q1CAP, Q2CAP values.*/\nexport const CKMD_AMPSTAT_CTRLATTARGET: any = '1'\nexport const CKMD_AMPSTAT_CTRLATTARGET_M: any = '1'\nexport const CKMD_AMPSTAT_CTRLATTARGET_S: any = '1'\n/**\nHFXT amplitude good*/\nexport const CKMD_AMPSTAT_AMPGOOD: any = '1'\nexport const CKMD_AMPSTAT_AMPGOOD_M: any = '1'\nexport const CKMD_AMPSTAT_AMPGOOD_S: any = '1'\n\n// -------- REGISTER ATBCTL0 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_RESERVED19: any = '13'\nexport const CKMD_ATBCTL0_RESERVED19_M: any = '13'\nexport const CKMD_ATBCTL0_RESERVED19_S: any = '13'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL: any = '19'\nexport const CKMD_ATBCTL0_SEL_M: any = '19'\nexport const CKMD_ATBCTL0_SEL_S: any = '19'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_LFXTTESTCLK: any = '458752'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_LFOSCTESTCLK: any = '327680'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_HFXTTESTCLK: any = '196608'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_HFOSCTESTCLK: any = '65536'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_LFMONVTEST: any = '4096'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_LFOSCVDDL: any = '2048'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_HFOSCIBIAS: any = '1024'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_HFOSCVDDL: any = '512'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_HFOSCVREF: any = '256'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_NABIASITEST: any = '128'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_ADCDACOUT: any = '64'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_ADCCOMPIN: any = '32'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_ADCCOMPOUT: any = '16'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_LFXTANA: any = '8'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_LDOITEST: any = '4'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_VDDCKM: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_HFXTANA: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL0_SEL_OFF: any = '0'\n\n\n// -------- REGISTER ATBCTL1 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_RESERVED15: any = '17'\nexport const CKMD_ATBCTL1_RESERVED15_M: any = '17'\nexport const CKMD_ATBCTL1_RESERVED15_S: any = '17'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFOSC: any = '2'\nexport const CKMD_ATBCTL1_LFOSC_M: any = '2'\nexport const CKMD_ATBCTL1_LFOSC_S: any = '2'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFOSC_BOTH: any = '3'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFOSC_VDDLOCAL: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFOSC_TESTCLK: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFOSC_OFF: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_NABIAS: any = '1'\nexport const CKMD_ATBCTL1_NABIAS_M: any = '1'\nexport const CKMD_ATBCTL1_NABIAS_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_RESERVED11: any = '1'\nexport const CKMD_ATBCTL1_RESERVED11_M: any = '1'\nexport const CKMD_ATBCTL1_RESERVED11_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFXT: any = '1'\nexport const CKMD_ATBCTL1_LFXT_M: any = '1'\nexport const CKMD_ATBCTL1_LFXT_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFXT_TESTCLK: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFXT_OFF: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFMON: any = '2'\nexport const CKMD_ATBCTL1_LFMON_M: any = '2'\nexport const CKMD_ATBCTL1_LFMON_S: any = '2'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFMON_TEST2: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFMON_TEST1: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_LFMON_OFF: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_HFXT: any = '1'\nexport const CKMD_ATBCTL1_HFXT_M: any = '1'\nexport const CKMD_ATBCTL1_HFXT_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_RESERVED1: any = '6'\nexport const CKMD_ATBCTL1_RESERVED1_M: any = '6'\nexport const CKMD_ATBCTL1_RESERVED1_S: any = '6'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_ATBCTL1_HFOSC: any = '1'\nexport const CKMD_ATBCTL1_HFOSC_M: any = '1'\nexport const CKMD_ATBCTL1_HFOSC_S: any = '1'\n\n// -------- REGISTER DTBCTL -------- //\n\n/**\nDigital test bus mux control*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_DTBCTL_RESERVED23: any = '9'\nexport const CKMD_DTBCTL_RESERVED23_M: any = '9'\nexport const CKMD_DTBCTL_RESERVED23_S: any = '9'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_DTBCTL_DSEL2: any = '5'\nexport const CKMD_DTBCTL_DSEL2_M: any = '5'\nexport const CKMD_DTBCTL_DSEL2_S: any = '5'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_DTBCTL_DSEL1: any = '5'\nexport const CKMD_DTBCTL_DSEL1_M: any = '5'\nexport const CKMD_DTBCTL_DSEL1_S: any = '5'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_DTBCTL_DSEL0: any = '5'\nexport const CKMD_DTBCTL_DSEL0_M: any = '5'\nexport const CKMD_DTBCTL_DSEL0_S: any = '5'\n/**\nSelect clock to output on DTB[0]*/\nexport const CKMD_DTBCTL_CLKSEL: any = '4'\nexport const CKMD_DTBCTL_CLKSEL_M: any = '4'\nexport const CKMD_DTBCTL_CLKSEL_S: any = '4'\n/**\nSelect LFXT*/\nexport const CKMD_DTBCTL_CLKSEL_LFXT: any = '15'\n\n/**\nSelect LFOSC*/\nexport const CKMD_DTBCTL_CLKSEL_LFOSC: any = '14'\n\n/**\nSelect HFXT*/\nexport const CKMD_DTBCTL_CLKSEL_HFXT: any = '13'\n\n/**\nSelect HFXT divided by 8*/\nexport const CKMD_DTBCTL_CLKSEL_HFXTBY8: any = '12'\n\n/**\nSelect HFOSC after qualification*/\nexport const CKMD_DTBCTL_CLKSEL_HFOSC: any = '10'\n\n/**\nSelect LFCLK (selected by LFCLKSEL.MAIN)*/\nexport const CKMD_DTBCTL_CLKSEL_LFCLK: any = '7'\n\n/**\nSelect tracking loop reference clock*/\nexport const CKMD_DTBCTL_CLKSEL_TRACKREF: any = '4'\n\n/**\nSelect CLKADC (48 MHz)*/\nexport const CKMD_DTBCTL_CLKSEL_CLKADC: any = '2'\n\n/**\nSelect CLKSVT (48 MHz)*/\nexport const CKMD_DTBCTL_CLKSEL_CLKSVT: any = '1'\n\n/**\nSelect CLKULL (24 MHz during ACTIVE, 32kHz during STANDBY)*/\nexport const CKMD_DTBCTL_CLKSEL_CLKULL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_DTBCTL_RESERVED1: any = '3'\nexport const CKMD_DTBCTL_RESERVED1_M: any = '3'\nexport const CKMD_DTBCTL_RESERVED1_S: any = '3'\n/**\nEnable DTB output*/\nexport const CKMD_DTBCTL_EN: any = '1'\nexport const CKMD_DTBCTL_EN_M: any = '1'\nexport const CKMD_DTBCTL_EN_S: any = '1'\n\n// -------- REGISTER TRIM0 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM0_RESERVED9: any = '23'\nexport const CKMD_TRIM0_RESERVED9_M: any = '23'\nexport const CKMD_TRIM0_RESERVED9_S: any = '23'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM0_HFOSC_CAP: any = '4'\nexport const CKMD_TRIM0_HFOSC_CAP_M: any = '4'\nexport const CKMD_TRIM0_HFOSC_CAP_S: any = '4'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM0_HFOSC_COARSE: any = '5'\nexport const CKMD_TRIM0_HFOSC_COARSE_M: any = '5'\nexport const CKMD_TRIM0_HFOSC_COARSE_S: any = '5'\n\n// -------- REGISTER TRIM1 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM1_HFXTSLICER: any = '2'\nexport const CKMD_TRIM1_HFXTSLICER_M: any = '2'\nexport const CKMD_TRIM1_HFXTSLICER_S: any = '2'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM1_PEAKIBIAS: any = '2'\nexport const CKMD_TRIM1_PEAKIBIAS_M: any = '2'\nexport const CKMD_TRIM1_PEAKIBIAS_S: any = '2'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM1_NABIAS_UDIGLDO: any = '1'\nexport const CKMD_TRIM1_NABIAS_UDIGLDO_M: any = '1'\nexport const CKMD_TRIM1_NABIAS_UDIGLDO_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM1_LDOBW: any = '3'\nexport const CKMD_TRIM1_LDOBW_M: any = '3'\nexport const CKMD_TRIM1_LDOBW_S: any = '3'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM1_LDOFB: any = '4'\nexport const CKMD_TRIM1_LDOFB_M: any = '4'\nexport const CKMD_TRIM1_LDOFB_S: any = '4'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM1_LFDLY: any = '4'\nexport const CKMD_TRIM1_LFDLY_M: any = '4'\nexport const CKMD_TRIM1_LFDLY_S: any = '4'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM1_NABIAS_LFOSC: any = '1'\nexport const CKMD_TRIM1_NABIAS_LFOSC_M: any = '1'\nexport const CKMD_TRIM1_NABIAS_LFOSC_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM1_NABIAS_RES: any = '7'\nexport const CKMD_TRIM1_NABIAS_RES_M: any = '7'\nexport const CKMD_TRIM1_NABIAS_RES_S: any = '7'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TRIM1_LFOSC_CAP: any = '8'\nexport const CKMD_TRIM1_LFOSC_CAP_M: any = '8'\nexport const CKMD_TRIM1_LFOSC_CAP_S: any = '8'\n\n// -------- REGISTER HFXTINIT -------- //\n\n/**\nInitial values for HFXT ramping*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_HFXTINIT_RESERVED30: any = '2'\nexport const CKMD_HFXTINIT_RESERVED30_M: any = '2'\nexport const CKMD_HFXTINIT_RESERVED30_S: any = '2'\n/**\nAmplitude threshold during HFXT ramping*/\nexport const CKMD_HFXTINIT_AMPTHR: any = '7'\nexport const CKMD_HFXTINIT_AMPTHR_M: any = '7'\nexport const CKMD_HFXTINIT_AMPTHR_S: any = '7'\n/**\nInitial HFXT IDAC current*/\nexport const CKMD_HFXTINIT_IDAC: any = '7'\nexport const CKMD_HFXTINIT_IDAC_M: any = '7'\nexport const CKMD_HFXTINIT_IDAC_S: any = '7'\n/**\nInitial HFXT IREF current*/\nexport const CKMD_HFXTINIT_IREF: any = '4'\nexport const CKMD_HFXTINIT_IREF_M: any = '4'\nexport const CKMD_HFXTINIT_IREF_S: any = '4'\n/**\nInitial HFXT Q2 cap trim*/\nexport const CKMD_HFXTINIT_Q2CAP: any = '6'\nexport const CKMD_HFXTINIT_Q2CAP_M: any = '6'\nexport const CKMD_HFXTINIT_Q2CAP_S: any = '6'\n/**\nInitial HFXT Q1 cap trim*/\nexport const CKMD_HFXTINIT_Q1CAP: any = '6'\nexport const CKMD_HFXTINIT_Q1CAP_M: any = '6'\nexport const CKMD_HFXTINIT_Q1CAP_S: any = '6'\n\n// -------- REGISTER HFXTTARG -------- //\n\n/**\nTarget values for HFXT ramping*/\n/**\nADC hysteresis used during IDAC updates.\n\n\nEvery AMPCFG1.INTERVAL, IDAC will be regulated\n- up as long as ADC $lt; AMPTHR\n- down as long as ADC $gt; AMPTHR+AMPHYST*/\nexport const CKMD_HFXTTARG_AMPHYST: any = '2'\nexport const CKMD_HFXTTARG_AMPHYST_M: any = '2'\nexport const CKMD_HFXTTARG_AMPHYST_S: any = '2'\n/**\nMinimum HFXT amplitude*/\nexport const CKMD_HFXTTARG_AMPTHR: any = '7'\nexport const CKMD_HFXTTARG_AMPTHR_M: any = '7'\nexport const CKMD_HFXTTARG_AMPTHR_S: any = '7'\n/**\nMinimum IDAC current*/\nexport const CKMD_HFXTTARG_IDAC: any = '7'\nexport const CKMD_HFXTTARG_IDAC_M: any = '7'\nexport const CKMD_HFXTTARG_IDAC_S: any = '7'\n/**\nTarget HFXT IREF current*/\nexport const CKMD_HFXTTARG_IREF: any = '4'\nexport const CKMD_HFXTTARG_IREF_M: any = '4'\nexport const CKMD_HFXTTARG_IREF_S: any = '4'\n/**\nTarget HFXT Q2 cap trim*/\nexport const CKMD_HFXTTARG_Q2CAP: any = '6'\nexport const CKMD_HFXTTARG_Q2CAP_M: any = '6'\nexport const CKMD_HFXTTARG_Q2CAP_S: any = '6'\n/**\nTarget HFXT Q1 cap trim*/\nexport const CKMD_HFXTTARG_Q1CAP: any = '6'\nexport const CKMD_HFXTTARG_Q1CAP_M: any = '6'\nexport const CKMD_HFXTTARG_Q1CAP_S: any = '6'\n\n// -------- REGISTER HFXTDYN -------- //\n\n/**\nAlternative target values for HFXT configuration\n\n\nSoftware can change these values to dynamically transition the HFXT configuration while HFXT is running.\nSet SEL to select the alternative set of target values.*/\n/**\nSelect the dynamic configuration.\n\n\nAmplitude ramping will always happen using the values in HFXTINIT, and HFXTTARG.\nAfterwards, this bit can be used to select between HFXTTARG and HFXTDYN.\nHardware will ensure a smooth transition of analog control signals.*/\nexport const CKMD_HFXTDYN_SEL: any = '1'\nexport const CKMD_HFXTDYN_SEL_M: any = '1'\nexport const CKMD_HFXTDYN_SEL_S: any = '1'\n/**\nSelect configuration in HFXTDYN.*/\nexport const CKMD_HFXTDYN_SEL_DYNAMIC: any = '1'\n\n/**\nSelect configuration in HFXTTARG.*/\nexport const CKMD_HFXTDYN_SEL_TARGET: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_HFXTDYN_RESERVED30: any = '1'\nexport const CKMD_HFXTDYN_RESERVED30_M: any = '1'\nexport const CKMD_HFXTDYN_RESERVED30_S: any = '1'\n/**\nMinimum HFXT amplitude*/\nexport const CKMD_HFXTDYN_AMPTHR: any = '7'\nexport const CKMD_HFXTDYN_AMPTHR_M: any = '7'\nexport const CKMD_HFXTDYN_AMPTHR_S: any = '7'\n/**\nMinimum IDAC current*/\nexport const CKMD_HFXTDYN_IDAC: any = '7'\nexport const CKMD_HFXTDYN_IDAC_M: any = '7'\nexport const CKMD_HFXTDYN_IDAC_S: any = '7'\n/**\nTarget HFXT IREF current*/\nexport const CKMD_HFXTDYN_IREF: any = '4'\nexport const CKMD_HFXTDYN_IREF_M: any = '4'\nexport const CKMD_HFXTDYN_IREF_S: any = '4'\n/**\nTarget HFXT Q2 cap trim*/\nexport const CKMD_HFXTDYN_Q2CAP: any = '6'\nexport const CKMD_HFXTDYN_Q2CAP_M: any = '6'\nexport const CKMD_HFXTDYN_Q2CAP_S: any = '6'\n/**\nTarget HFXT Q1 cap trim*/\nexport const CKMD_HFXTDYN_Q1CAP: any = '6'\nexport const CKMD_HFXTDYN_Q1CAP_M: any = '6'\nexport const CKMD_HFXTDYN_Q1CAP_S: any = '6'\n\n// -------- REGISTER AMPCFG0 -------- //\n\n/**\nAmplitude Compensation Configuration 0*/\n/**\nQ2CAP change delay.\n\n\nNumber of clock cycles to wait before changing Q2CAP by one step.\nClock frequency defined in FSMRATE.*/\nexport const CKMD_AMPCFG0_Q2DLY: any = '4'\nexport const CKMD_AMPCFG0_Q2DLY_M: any = '4'\nexport const CKMD_AMPCFG0_Q2DLY_S: any = '4'\n/**\nQ1CAP change delay.\n\n\nNumber of clock cycles to wait before changing Q1CAP by one step.\nClock frequency defined in FSMRATE.*/\nexport const CKMD_AMPCFG0_Q1DLY: any = '4'\nexport const CKMD_AMPCFG0_Q1DLY_M: any = '4'\nexport const CKMD_AMPCFG0_Q1DLY_S: any = '4'\n/**\nADC and PEAKDET startup time.\n\n\nNumber of clock cycles to wait after enabling the PEAKDET and ADC before the first measurement.\nClock frequency defined in FSMRATE.*/\nexport const CKMD_AMPCFG0_ADCDLY: any = '4'\nexport const CKMD_AMPCFG0_ADCDLY_M: any = '4'\nexport const CKMD_AMPCFG0_ADCDLY_S: any = '4'\n/**\nLDO startup time.\n\n\nNumber of clock cycles to bypass the LDO resistors for faster startup.\nClock frequency defined in FSMRATE.*/\nexport const CKMD_AMPCFG0_LDOSTART: any = '5'\nexport const CKMD_AMPCFG0_LDOSTART_M: any = '5'\nexport const CKMD_AMPCFG0_LDOSTART_S: any = '5'\n/**\nInject HFOSC for faster HFXT startup.\n\n\nThis value specifies the number of clock cycles to wait after injection is done.\nThe clock speed is defined in FSMRATE.*/\nexport const CKMD_AMPCFG0_INJWAIT: any = '5'\nexport const CKMD_AMPCFG0_INJWAIT_M: any = '5'\nexport const CKMD_AMPCFG0_INJWAIT_S: any = '5'\n/**\nInject HFOSC for faster HFXT startup.\n\n\nThis value specifies the number of clock cycles the injection is enabled.\nThe clock speed is defined in FSMRATE.\nSet to 0 to disable injection.*/\nexport const CKMD_AMPCFG0_INJTIME: any = '5'\nexport const CKMD_AMPCFG0_INJTIME_M: any = '5'\nexport const CKMD_AMPCFG0_INJTIME_S: any = '5'\n/**\nUpdate rate for the AMPCOMP update rate.\n\nAlso affects the clock rate for the Amplitude ADC.\n\nThe update rate is 6MHz / (FSMRATE+1).*/\nexport const CKMD_AMPCFG0_FSMRATE: any = '5'\nexport const CKMD_AMPCFG0_FSMRATE_M: any = '5'\nexport const CKMD_AMPCFG0_FSMRATE_S: any = '5'\n/**\n250 kHz*/\nexport const CKMD_AMPCFG0_FSMRATE__250K: any = '23'\n\n/**\n500 kHz*/\nexport const CKMD_AMPCFG0_FSMRATE__500K: any = '11'\n\n/**\n1 MHz*/\nexport const CKMD_AMPCFG0_FSMRATE__1M: any = '5'\n\n/**\n2 MHz*/\nexport const CKMD_AMPCFG0_FSMRATE__2M: any = '2'\n\n/**\n3 MHz*/\nexport const CKMD_AMPCFG0_FSMRATE__3M: any = '1'\n\n/**\n6 MHz*/\nexport const CKMD_AMPCFG0_FSMRATE__6M: any = '0'\n\n\n// -------- REGISTER AMPCFG1 -------- //\n\n/**\nAmplitude Compensation Configuration 1*/\n/**\nIDAC change delay.\n\n\nTime to wait before changing IDAC by one step.\nThis time needs to be long enough for the crystal to settle.\nThe number of clock cycles to wait is IDACDLY$lt;$lt;4 + 15.\nClock frequency defined in AMPCFG0.FSMRATE.*/\nexport const CKMD_AMPCFG1_IDACDLY: any = '4'\nexport const CKMD_AMPCFG1_IDACDLY_M: any = '4'\nexport const CKMD_AMPCFG1_IDACDLY_S: any = '4'\n/**\nIREF change delay.\n\n\nNumber of clock cycles to wait before changing IREF by one step.\nClock frequency defined in AMPCFG0.FSMRATE.*/\nexport const CKMD_AMPCFG1_IREFDLY: any = '4'\nexport const CKMD_AMPCFG1_IREFDLY_M: any = '4'\nexport const CKMD_AMPCFG1_IREFDLY_S: any = '4'\n/**\nLifetime of the amplitude ADC bias value.\n\nThis value specifies the number of adjustment intervals,\nuntil the ADC bias value has to be measured again.\nSet to 0 to disable automatic bias measurements.*/\nexport const CKMD_AMPCFG1_BIASLT: any = '12'\nexport const CKMD_AMPCFG1_BIASLT_M: any = '12'\nexport const CKMD_AMPCFG1_BIASLT_S: any = '12'\n/**\nInterval for amplitude adjustments.\n\nSet to 0 to disable periodic adjustments.\n\nThis value specifies the number of clock cycles between adjustments.\nThe clock speed is defined in AMPCFG0.FSMRATE.*/\nexport const CKMD_AMPCFG1_INTERVAL: any = '12'\nexport const CKMD_AMPCFG1_INTERVAL_M: any = '12'\nexport const CKMD_AMPCFG1_INTERVAL_S: any = '12'\n\n// -------- REGISTER LOOPCFG -------- //\n\n/**\nConfiguration Register for the Tracking Loop*/\n/**\nInitial value for the resistor fine trim*/\nexport const CKMD_LOOPCFG_FINETRIM_INIT: any = '6'\nexport const CKMD_LOOPCFG_FINETRIM_INIT_M: any = '6'\nexport const CKMD_LOOPCFG_FINETRIM_INIT_S: any = '6'\n/**\nNumber of error-updates using BOOST values, before using KI/KP*/\nexport const CKMD_LOOPCFG_BOOST_TARGET: any = '5'\nexport const CKMD_LOOPCFG_BOOST_TARGET_M: any = '5'\nexport const CKMD_LOOPCFG_BOOST_TARGET_S: any = '5'\n/**\nProportional loop coefficient during BOOST*/\nexport const CKMD_LOOPCFG_KP_BOOST: any = '3'\nexport const CKMD_LOOPCFG_KP_BOOST_M: any = '3'\nexport const CKMD_LOOPCFG_KP_BOOST_S: any = '3'\n/**\nIntegral loop coefficient during BOOST*/\nexport const CKMD_LOOPCFG_KI_BOOST: any = '3'\nexport const CKMD_LOOPCFG_KI_BOOST_M: any = '3'\nexport const CKMD_LOOPCFG_KI_BOOST_S: any = '3'\n/**\nNumber of updates before HFOSC is considered \"settled\"*/\nexport const CKMD_LOOPCFG_SETTLED_TARGET: any = '5'\nexport const CKMD_LOOPCFG_SETTLED_TARGET_M: any = '5'\nexport const CKMD_LOOPCFG_SETTLED_TARGET_S: any = '5'\n/**\nOut-of-range threshold*/\nexport const CKMD_LOOPCFG_OOR_LIMIT: any = '4'\nexport const CKMD_LOOPCFG_OOR_LIMIT_M: any = '4'\nexport const CKMD_LOOPCFG_OOR_LIMIT_S: any = '4'\n/**\nProportional loop coefficient*/\nexport const CKMD_LOOPCFG_KP: any = '3'\nexport const CKMD_LOOPCFG_KP_M: any = '3'\nexport const CKMD_LOOPCFG_KP_S: any = '3'\n/**\nIntegral loop coefficient*/\nexport const CKMD_LOOPCFG_KI: any = '3'\nexport const CKMD_LOOPCFG_KI_M: any = '3'\nexport const CKMD_LOOPCFG_KI_S: any = '3'\n\n// -------- REGISTER TDCCTL -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCTL_RESERVED2: any = '30'\nexport const CKMD_TDCCTL_RESERVED2_M: any = '30'\nexport const CKMD_TDCCTL_RESERVED2_S: any = '30'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCTL_CMD: any = '2'\nexport const CKMD_TDCCTL_CMD_M: any = '2'\nexport const CKMD_TDCCTL_CMD_S: any = '2'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCTL_CMD_ABORT: any = '3'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCTL_CMD_RUN: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCTL_CMD_RUN_SYNC_START: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCCTL_CMD_CLR_RESULT: any = '0'\n\n\n// -------- REGISTER TDCSTAT -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_RESERVED10: any = '22'\nexport const CKMD_TDCSTAT_RESERVED10_M: any = '22'\nexport const CKMD_TDCSTAT_RESERVED10_S: any = '22'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STOP_BF: any = '1'\nexport const CKMD_TDCSTAT_STOP_BF_M: any = '1'\nexport const CKMD_TDCSTAT_STOP_BF_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_START_BF: any = '1'\nexport const CKMD_TDCSTAT_START_BF_M: any = '1'\nexport const CKMD_TDCSTAT_START_BF_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_SAT: any = '1'\nexport const CKMD_TDCSTAT_SAT_M: any = '1'\nexport const CKMD_TDCSTAT_SAT_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_DONE: any = '1'\nexport const CKMD_TDCSTAT_DONE_M: any = '1'\nexport const CKMD_TDCSTAT_DONE_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE: any = '6'\nexport const CKMD_TDCSTAT_STATE_M: any = '6'\nexport const CKMD_TDCSTAT_STATE_S: any = '6'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_FORCE_STOP: any = '46'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_START_FALL: any = '30'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_WAIT_CLR_CNT_DONE: any = '22'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_POR: any = '15'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_GET_RESULT: any = '14'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_WAIT_STOP_CNTDWN: any = '12'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_WAIT_STOP: any = '8'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_CLR_CNT: any = '7'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_IDLE: any = '6'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_WAIT_START_STOP_CNT_EN: any = '4'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSTAT_STATE_WAIT_START: any = '0'\n\n\n// -------- REGISTER TDCRESULT -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCRESULT_VALUE: any = '32'\nexport const CKMD_TDCRESULT_VALUE_M: any = '32'\nexport const CKMD_TDCRESULT_VALUE_S: any = '32'\n\n// -------- REGISTER TDCSATCFG -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_RESERVED5: any = '27'\nexport const CKMD_TDCSATCFG_RESERVED5_M: any = '27'\nexport const CKMD_TDCSATCFG_RESERVED5_S: any = '27'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT: any = '5'\nexport const CKMD_TDCSATCFG_LIMIT_M: any = '5'\nexport const CKMD_TDCSATCFG_LIMIT_S: any = '5'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R30: any = '21'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R29: any = '20'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R28: any = '19'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R27: any = '18'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R26: any = '17'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R25: any = '16'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R24: any = '15'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R23: any = '14'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R22: any = '13'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R21: any = '12'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R20: any = '11'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R19: any = '10'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R18: any = '9'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R17: any = '8'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R16: any = '7'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R15: any = '6'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R14: any = '5'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R13: any = '4'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_R12: any = '3'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCSATCFG_LIMIT_NONE: any = '0'\n\n\n// -------- REGISTER TDCTRIGSRC -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_RESERVED16: any = '16'\nexport const CKMD_TDCTRIGSRC_RESERVED16_M: any = '16'\nexport const CKMD_TDCTRIGSRC_RESERVED16_S: any = '16'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_POL: any = '1'\nexport const CKMD_TDCTRIGSRC_STOP_POL_M: any = '1'\nexport const CKMD_TDCTRIGSRC_STOP_POL_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_POL_LOW: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_POL_HIGH: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_RESERVED13: any = '2'\nexport const CKMD_TDCTRIGSRC_RESERVED13_M: any = '2'\nexport const CKMD_TDCTRIGSRC_RESERVED13_S: any = '2'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC: any = '5'\nexport const CKMD_TDCTRIGSRC_STOP_SRC_M: any = '5'\nexport const CKMD_TDCTRIGSRC_STOP_SRC_S: any = '5'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_TDC_PRE: any = '31'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB15: any = '20'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB14: any = '19'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB13: any = '18'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB12: any = '17'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB11: any = '16'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB10: any = '15'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB9: any = '14'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB8: any = '13'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB7: any = '12'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB6: any = '11'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB5: any = '10'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB4: any = '9'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB3: any = '8'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB2: any = '7'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB1: any = '6'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_DTB0: any = '5'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_GPI: any = '4'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_LFCLK_DLY: any = '3'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_LFXT: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_LFOSC: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_STOP_SRC_LFTICK: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_POL: any = '1'\nexport const CKMD_TDCTRIGSRC_START_POL_M: any = '1'\nexport const CKMD_TDCTRIGSRC_START_POL_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_POL_LOW: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_POL_HIGH: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_RESERVED5: any = '2'\nexport const CKMD_TDCTRIGSRC_RESERVED5_M: any = '2'\nexport const CKMD_TDCTRIGSRC_RESERVED5_S: any = '2'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC: any = '5'\nexport const CKMD_TDCTRIGSRC_START_SRC_M: any = '5'\nexport const CKMD_TDCTRIGSRC_START_SRC_S: any = '5'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_TDC_PRE: any = '31'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB15: any = '20'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB14: any = '19'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB13: any = '18'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB12: any = '17'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB11: any = '16'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB10: any = '15'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB9: any = '14'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB8: any = '13'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB7: any = '12'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB6: any = '11'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB5: any = '10'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB4: any = '9'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB3: any = '8'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB2: any = '7'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB1: any = '6'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_DTB0: any = '5'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_GPI: any = '4'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_LFCLK_DLY: any = '3'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_LFXT: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_LFOSC: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGSRC_START_SRC_LFTICK: any = '0'\n\n\n// -------- REGISTER TDCTRIGCNT -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGCNT_RESERVED16: any = '16'\nexport const CKMD_TDCTRIGCNT_RESERVED16_M: any = '16'\nexport const CKMD_TDCTRIGCNT_RESERVED16_S: any = '16'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGCNT_CNT: any = '16'\nexport const CKMD_TDCTRIGCNT_CNT_M: any = '16'\nexport const CKMD_TDCTRIGCNT_CNT_S: any = '16'\n\n// -------- REGISTER TDCTRIGCNTLOAD -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGCNTLOAD_RESERVED16: any = '16'\nexport const CKMD_TDCTRIGCNTLOAD_RESERVED16_M: any = '16'\nexport const CKMD_TDCTRIGCNTLOAD_RESERVED16_S: any = '16'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGCNTLOAD_CNT: any = '16'\nexport const CKMD_TDCTRIGCNTLOAD_CNT_M: any = '16'\nexport const CKMD_TDCTRIGCNTLOAD_CNT_S: any = '16'\n\n// -------- REGISTER TDCTRIGCNTCFG -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGCNTCFG_RESERVED1: any = '31'\nexport const CKMD_TDCTRIGCNTCFG_RESERVED1_M: any = '31'\nexport const CKMD_TDCTRIGCNTCFG_RESERVED1_S: any = '31'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCTRIGCNTCFG_EN: any = '1'\nexport const CKMD_TDCTRIGCNTCFG_EN_M: any = '1'\nexport const CKMD_TDCTRIGCNTCFG_EN_S: any = '1'\n\n// -------- REGISTER TDCPRECTL -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_RESERVED8: any = '24'\nexport const CKMD_TDCPRECTL_RESERVED8_M: any = '24'\nexport const CKMD_TDCPRECTL_RESERVED8_S: any = '24'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_RESET_N: any = '1'\nexport const CKMD_TDCPRECTL_RESET_N_M: any = '1'\nexport const CKMD_TDCPRECTL_RESET_N_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_RATIO: any = '1'\nexport const CKMD_TDCPRECTL_RATIO_M: any = '1'\nexport const CKMD_TDCPRECTL_RATIO_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_RATIO_DIV64: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_RATIO_DIV16: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_RESERVED5: any = '1'\nexport const CKMD_TDCPRECTL_RESERVED5_M: any = '1'\nexport const CKMD_TDCPRECTL_RESERVED5_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC: any = '5'\nexport const CKMD_TDCPRECTL_SRC_M: any = '5'\nexport const CKMD_TDCPRECTL_SRC_S: any = '5'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_HFXT: any = '22'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_HFOSC: any = '21'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB15: any = '20'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB14: any = '19'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB13: any = '18'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB12: any = '17'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB11: any = '16'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB10: any = '15'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB9: any = '14'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB8: any = '13'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB7: any = '12'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB6: any = '11'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB5: any = '10'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB4: any = '9'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB3: any = '8'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB2: any = '7'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB1: any = '6'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_DTB0: any = '5'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_GPI: any = '4'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_LFCLK_DLY: any = '3'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_LFXT: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_LFOSC: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECTL_SRC_LFTICK: any = '0'\n\n\n// -------- REGISTER TDCPRECNTR -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECNTR_RESERVED17: any = '15'\nexport const CKMD_TDCPRECNTR_RESERVED17_M: any = '15'\nexport const CKMD_TDCPRECNTR_RESERVED17_S: any = '15'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECNTR_CAPT: any = '1'\nexport const CKMD_TDCPRECNTR_CAPT_M: any = '1'\nexport const CKMD_TDCPRECNTR_CAPT_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CKMD_TDCPRECNTR_CNT: any = '16'\nexport const CKMD_TDCPRECNTR_CNT_M: any = '16'\nexport const CKMD_TDCPRECNTR_CNT_S: any = '16'\n\n// -------- REGISTER WDTCNT -------- //\n\n/**\nWDT counter value register*/\n/**\nCounter value.\n\n\nA write to this field immediately starts (or restarts) the counter. It will count down from the written value.\nIf the counter reaches 0, a reset will be generated.\nA write value of 0 immediately generates a reset.\n\nThis field is only writable if not locked. See WDTLOCK register.\nWriting this field will automatically activate the lock.\n\nA read returns the current value of the counter.*/\nexport const CKMD_WDTCNT_VAL: any = '32'\nexport const CKMD_WDTCNT_VAL_M: any = '32'\nexport const CKMD_WDTCNT_VAL_S: any = '32'\n\n// -------- REGISTER WDTTEST -------- //\n\n/**\nWDT test mode register*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CKMD_WDTTEST_RESERVED1: any = '31'\nexport const CKMD_WDTTEST_RESERVED1_M: any = '31'\nexport const CKMD_WDTTEST_RESERVED1_S: any = '31'\n/**\nWDT stall enable\n\n\nThis field is only writable if not locked. See WDTLOCK register.*/\nexport const CKMD_WDTTEST_STALLEN: any = '1'\nexport const CKMD_WDTTEST_STALLEN_M: any = '1'\nexport const CKMD_WDTTEST_STALLEN_S: any = '1'\n/**\nENABLE\n\n\nWDT stops counting while the CPU is stopped by a debugger.*/\nexport const CKMD_WDTTEST_STALLEN_EN: any = '1'\n\n/**\nDISABLE\n\n\nWDT continues counting while the CPU is stopped by a debugger.*/\nexport const CKMD_WDTTEST_STALLEN_DIS: any = '0'\n\n\n// -------- REGISTER WDTLOCK -------- //\n\n/**\nWDT lock register*/\n/**\nA write with value 0x1ACCE551 unlocks the watchdog registers for write access.\n\nA write with any other value locks the watchdog registers for write access.\nWriting the WDTCNT register will also lock the watchdog registers.\n\nA read of this field returns the state of the lock (0=unlocked, 1=locked).*/\nexport const CKMD_WDTLOCK_STAT: any = '32'\nexport const CKMD_WDTLOCK_STAT_M: any = '32'\nexport const CKMD_WDTLOCK_STAT_S: any = '32'\n\n// -------- MODULE CLKCTL -------- //\n\nexport interface CLKCTL_t {\n    DESC: em.$Reg\n    DESCEX0: em.$Reg\n    DESCEX1: em.$Reg\n    CLKCFG0: em.$Reg\n    CLKCFG1: em.$Reg\n    CLKENSET0: em.$Reg\n    CLKENSET1: em.$Reg\n    CLKENCLR0: em.$Reg\n    CLKENCLR1: em.$Reg\n    STBYPTR: em.$Reg\n    IDLECFG: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription Register. \n\nThis register provides IP module ID, revision information, instance index and standard MMR registers offset.*/\n/**\nModule identifier used to uniquely identify this IP.*/\nexport const CLKCTL_DESC_MODID: any = '16'\nexport const CLKCTL_DESC_MODID_M: any = '16'\nexport const CLKCTL_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set of from aggregated IRQ registers till DTB.\n\n\n0: Standard IP MMRs do not exist\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)*/\nexport const CLKCTL_DESC_STDIPOFF: any = '4'\nexport const CLKCTL_DESC_STDIPOFF_M: any = '4'\nexport const CLKCTL_DESC_STDIPOFF_S: any = '4'\n/**\nIP Instance ID number. If multiple instances of IP exist in the device, this field can identify the instance number (0-15).*/\nexport const CLKCTL_DESC_INSTIDX: any = '4'\nexport const CLKCTL_DESC_INSTIDX_M: any = '4'\nexport const CLKCTL_DESC_INSTIDX_S: any = '4'\n/**\nMajor revision of IP 0-15*/\nexport const CLKCTL_DESC_MAJREV: any = '4'\nexport const CLKCTL_DESC_MAJREV_M: any = '4'\nexport const CLKCTL_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP 0-15.*/\nexport const CLKCTL_DESC_MINREV: any = '4'\nexport const CLKCTL_DESC_MINREV_M: any = '4'\nexport const CLKCTL_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER DESCEX0 -------- //\n\n/**\nExtended Description Register 0. \n\nThis register shows SVT IP availability, HW features and memory size configuration.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_DESCEX0_RESERVED31: any = '1'\nexport const CLKCTL_DESCEX0_RESERVED31_M: any = '1'\nexport const CLKCTL_DESCEX0_RESERVED31_S: any = '1'\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_LGPT3: any = '1'\nexport const CLKCTL_DESCEX0_LGPT3_M: any = '1'\nexport const CLKCTL_DESCEX0_LGPT3_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_LGPT3_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_LGPT3_IP_UNAVAIL: any = '0'\n\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_LGPT2: any = '1'\nexport const CLKCTL_DESCEX0_LGPT2_M: any = '1'\nexport const CLKCTL_DESCEX0_LGPT2_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_LGPT2_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_LGPT2_IP_UNAVAIL: any = '0'\n\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_LGPT1: any = '1'\nexport const CLKCTL_DESCEX0_LGPT1_M: any = '1'\nexport const CLKCTL_DESCEX0_LGPT1_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_LGPT1_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_LGPT1_IP_UNAVAIL: any = '0'\n\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_LGPT0: any = '1'\nexport const CLKCTL_DESCEX0_LGPT0_M: any = '1'\nexport const CLKCTL_DESCEX0_LGPT0_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_LGPT0_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_LGPT0_IP_UNAVAIL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_DESCEX0_RESERVED18: any = '9'\nexport const CLKCTL_DESCEX0_RESERVED18_M: any = '9'\nexport const CLKCTL_DESCEX0_RESERVED18_S: any = '9'\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_DMA: any = '1'\nexport const CLKCTL_DESCEX0_DMA_M: any = '1'\nexport const CLKCTL_DESCEX0_DMA_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_DMA_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_DMA_IP_UNAVAIL: any = '0'\n\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_LAES: any = '1'\nexport const CLKCTL_DESCEX0_LAES_M: any = '1'\nexport const CLKCTL_DESCEX0_LAES_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_LAES_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_LAES_IP_UNAVAIL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_DESCEX0_RESERVED15: any = '1'\nexport const CLKCTL_DESCEX0_RESERVED15_M: any = '1'\nexport const CLKCTL_DESCEX0_RESERVED15_S: any = '1'\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_ADC0: any = '1'\nexport const CLKCTL_DESCEX0_ADC0_M: any = '1'\nexport const CLKCTL_DESCEX0_ADC0_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_ADC0_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_ADC0_IP_UNAVAIL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_DESCEX0_RESERVED11: any = '3'\nexport const CLKCTL_DESCEX0_RESERVED11_M: any = '3'\nexport const CLKCTL_DESCEX0_RESERVED11_S: any = '3'\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_SPI0: any = '1'\nexport const CLKCTL_DESCEX0_SPI0_M: any = '1'\nexport const CLKCTL_DESCEX0_SPI0_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_SPI0_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_SPI0_IP_UNAVAIL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_DESCEX0_RESERVED7: any = '3'\nexport const CLKCTL_DESCEX0_RESERVED7_M: any = '3'\nexport const CLKCTL_DESCEX0_RESERVED7_S: any = '3'\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_I2C0: any = '1'\nexport const CLKCTL_DESCEX0_I2C0_M: any = '1'\nexport const CLKCTL_DESCEX0_I2C0_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_I2C0_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_I2C0_IP_UNAVAIL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_DESCEX0_RESERVED3: any = '3'\nexport const CLKCTL_DESCEX0_RESERVED3_M: any = '3'\nexport const CLKCTL_DESCEX0_RESERVED3_S: any = '3'\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_UART0: any = '1'\nexport const CLKCTL_DESCEX0_UART0_M: any = '1'\nexport const CLKCTL_DESCEX0_UART0_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_UART0_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_UART0_IP_UNAVAIL: any = '0'\n\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_LRFD: any = '1'\nexport const CLKCTL_DESCEX0_LRFD_M: any = '1'\nexport const CLKCTL_DESCEX0_LRFD_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_LRFD_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_LRFD_IP_UNAVAIL: any = '0'\n\n/**\nIP status on device*/\nexport const CLKCTL_DESCEX0_GPIO: any = '1'\nexport const CLKCTL_DESCEX0_GPIO_M: any = '1'\nexport const CLKCTL_DESCEX0_GPIO_S: any = '1'\n/**\nIP is available*/\nexport const CLKCTL_DESCEX0_GPIO_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const CLKCTL_DESCEX0_GPIO_IP_UNAVAIL: any = '0'\n\n\n// -------- REGISTER DESCEX1 -------- //\n\n/**\nExtended Description Register 1. \n\nThis register shows SVT IP availability, HW features and memory size configuration.*/\n/**\nSystem flash availability*/\nexport const CLKCTL_DESCEX1_FLASHSZ: any = '2'\nexport const CLKCTL_DESCEX1_FLASHSZ_M: any = '2'\nexport const CLKCTL_DESCEX1_FLASHSZ_S: any = '2'\n/**\nFlash size set to level 3 (Max size)*/\nexport const CLKCTL_DESCEX1_FLASHSZ_SZ3: any = '3'\n\n/**\nFlash size set to level 2*/\nexport const CLKCTL_DESCEX1_FLASHSZ_SZ2: any = '2'\n\n/**\nFlash size set to level 1*/\nexport const CLKCTL_DESCEX1_FLASHSZ_SZ1: any = '1'\n\n/**\nFlash size set to level 0 (Min size)*/\nexport const CLKCTL_DESCEX1_FLASHSZ_SZ0: any = '0'\n\n/**\nSystem SRAM availability*/\nexport const CLKCTL_DESCEX1_SRAMSZ: any = '2'\nexport const CLKCTL_DESCEX1_SRAMSZ_M: any = '2'\nexport const CLKCTL_DESCEX1_SRAMSZ_S: any = '2'\n/**\nSRAM size set to level 3 (Max size)*/\nexport const CLKCTL_DESCEX1_SRAMSZ_SZ3: any = '3'\n\n/**\nSRAM size set to level 2*/\nexport const CLKCTL_DESCEX1_SRAMSZ_SZ2: any = '2'\n\n/**\nSRAM size set to level 1*/\nexport const CLKCTL_DESCEX1_SRAMSZ_SZ1: any = '1'\n\n/**\nSRAM size set to level 0 (Min size)*/\nexport const CLKCTL_DESCEX1_SRAMSZ_SZ0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_DESCEX1_RESERVED16: any = '12'\nexport const CLKCTL_DESCEX1_RESERVED16_M: any = '12'\nexport const CLKCTL_DESCEX1_RESERVED16_S: any = '12'\n/**\nSystem radio feature availability*/\nexport const CLKCTL_DESCEX1_ROPT: any = '8'\nexport const CLKCTL_DESCEX1_ROPT_M: any = '8'\nexport const CLKCTL_DESCEX1_ROPT_S: any = '8'\n/**\nAll features available*/\nexport const CLKCTL_DESCEX1_ROPT_MAX: any = '255'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_DESCEX1_RESERVED0: any = '8'\nexport const CLKCTL_DESCEX1_RESERVED0_M: any = '8'\nexport const CLKCTL_DESCEX1_RESERVED0_S: any = '8'\n\n// -------- REGISTER CLKCFG0 -------- //\n\n/**\nClock Configuration Register 0.\n\nThis register shows the IP clock configuration for the system.\nThe configuration is updated through CLKENSET0 and CLKENCLR0.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKCFG0_RESERVED31: any = '1'\nexport const CLKCTL_CLKCFG0_RESERVED31_M: any = '1'\nexport const CLKCTL_CLKCFG0_RESERVED31_S: any = '1'\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_LGPT3: any = '1'\nexport const CLKCTL_CLKCFG0_LGPT3_M: any = '1'\nexport const CLKCTL_CLKCFG0_LGPT3_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_LGPT3_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_LGPT3_CLK_DIS: any = '0'\n\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_LGPT2: any = '1'\nexport const CLKCTL_CLKCFG0_LGPT2_M: any = '1'\nexport const CLKCTL_CLKCFG0_LGPT2_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_LGPT2_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_LGPT2_CLK_DIS: any = '0'\n\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_LGPT1: any = '1'\nexport const CLKCTL_CLKCFG0_LGPT1_M: any = '1'\nexport const CLKCTL_CLKCFG0_LGPT1_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_LGPT1_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_LGPT1_CLK_DIS: any = '0'\n\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_LGPT0: any = '1'\nexport const CLKCTL_CLKCFG0_LGPT0_M: any = '1'\nexport const CLKCTL_CLKCFG0_LGPT0_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_LGPT0_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_LGPT0_CLK_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKCFG0_RESERVED18: any = '9'\nexport const CLKCTL_CLKCFG0_RESERVED18_M: any = '9'\nexport const CLKCTL_CLKCFG0_RESERVED18_S: any = '9'\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_DMA: any = '1'\nexport const CLKCTL_CLKCFG0_DMA_M: any = '1'\nexport const CLKCTL_CLKCFG0_DMA_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_DMA_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_DMA_CLK_DIS: any = '0'\n\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_LAES: any = '1'\nexport const CLKCTL_CLKCFG0_LAES_M: any = '1'\nexport const CLKCTL_CLKCFG0_LAES_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_LAES_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_LAES_CLK_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKCFG0_RESERVED15: any = '1'\nexport const CLKCTL_CLKCFG0_RESERVED15_M: any = '1'\nexport const CLKCTL_CLKCFG0_RESERVED15_S: any = '1'\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_ADC0: any = '1'\nexport const CLKCTL_CLKCFG0_ADC0_M: any = '1'\nexport const CLKCTL_CLKCFG0_ADC0_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_ADC0_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_ADC0_CLK_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKCFG0_RESERVED11: any = '3'\nexport const CLKCTL_CLKCFG0_RESERVED11_M: any = '3'\nexport const CLKCTL_CLKCFG0_RESERVED11_S: any = '3'\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_SPI0: any = '1'\nexport const CLKCTL_CLKCFG0_SPI0_M: any = '1'\nexport const CLKCTL_CLKCFG0_SPI0_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_SPI0_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_SPI0_CLK_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKCFG0_RESERVED7: any = '3'\nexport const CLKCTL_CLKCFG0_RESERVED7_M: any = '3'\nexport const CLKCTL_CLKCFG0_RESERVED7_S: any = '3'\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_I2C0: any = '1'\nexport const CLKCTL_CLKCFG0_I2C0_M: any = '1'\nexport const CLKCTL_CLKCFG0_I2C0_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_I2C0_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_I2C0_CLK_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKCFG0_RESERVED3: any = '3'\nexport const CLKCTL_CLKCFG0_RESERVED3_M: any = '3'\nexport const CLKCTL_CLKCFG0_RESERVED3_S: any = '3'\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_UART0: any = '1'\nexport const CLKCTL_CLKCFG0_UART0_M: any = '1'\nexport const CLKCTL_CLKCFG0_UART0_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_UART0_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_UART0_CLK_DIS: any = '0'\n\n/**\nIP clock configuration*/\nexport const CLKCTL_CLKCFG0_LRFD: any = '1'\nexport const CLKCTL_CLKCFG0_LRFD_M: any = '1'\nexport const CLKCTL_CLKCFG0_LRFD_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_LRFD_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_LRFD_CLK_DIS: any = '0'\n\n/**\nIP clock configuration\n\n*/\nexport const CLKCTL_CLKCFG0_GPIO: any = '1'\nexport const CLKCTL_CLKCFG0_GPIO_M: any = '1'\nexport const CLKCTL_CLKCFG0_GPIO_S: any = '1'\n/**\nClock is enabled*/\nexport const CLKCTL_CLKCFG0_GPIO_CLK_EN: any = '1'\n\n/**\nClock is disabled*/\nexport const CLKCTL_CLKCFG0_GPIO_CLK_DIS: any = '0'\n\n\n// -------- REGISTER CLKCFG1 -------- //\n\n/**\nClock Configuration Register 1.\n\nThis register shows the IP clock configuration for the system.\nThe configuration is updated through CLKENSET1 and CLKENCLR1.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKCFG1_RESERVED0: any = '32'\nexport const CLKCTL_CLKCFG1_RESERVED0_M: any = '32'\nexport const CLKCTL_CLKCFG1_RESERVED0_S: any = '32'\n\n// -------- REGISTER CLKENSET0 -------- //\n\n/**\nClock Enable Set Register 0.\n\nThis register enables IP clocks in the system. \nUsed to set the corresponding fields in CLKCFG0 to 1.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENSET0_RESERVED31: any = '1'\nexport const CLKCTL_CLKENSET0_RESERVED31_M: any = '1'\nexport const CLKCTL_CLKENSET0_RESERVED31_S: any = '1'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_LGPT3: any = '1'\nexport const CLKCTL_CLKENSET0_LGPT3_M: any = '1'\nexport const CLKCTL_CLKENSET0_LGPT3_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_LGPT3_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_LGPT3_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_LGPT2: any = '1'\nexport const CLKCTL_CLKENSET0_LGPT2_M: any = '1'\nexport const CLKCTL_CLKENSET0_LGPT2_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_LGPT2_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_LGPT2_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_LGPT1: any = '1'\nexport const CLKCTL_CLKENSET0_LGPT1_M: any = '1'\nexport const CLKCTL_CLKENSET0_LGPT1_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_LGPT1_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_LGPT1_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_LGPT0: any = '1'\nexport const CLKCTL_CLKENSET0_LGPT0_M: any = '1'\nexport const CLKCTL_CLKENSET0_LGPT0_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_LGPT0_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_LGPT0_CLK_UNCHGD: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENSET0_RESERVED18: any = '9'\nexport const CLKCTL_CLKENSET0_RESERVED18_M: any = '9'\nexport const CLKCTL_CLKENSET0_RESERVED18_S: any = '9'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_DMA: any = '1'\nexport const CLKCTL_CLKENSET0_DMA_M: any = '1'\nexport const CLKCTL_CLKENSET0_DMA_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_DMA_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_DMA_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_LAES: any = '1'\nexport const CLKCTL_CLKENSET0_LAES_M: any = '1'\nexport const CLKCTL_CLKENSET0_LAES_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_LAES_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_LAES_CLK_UNCHGD: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENSET0_RESERVED15: any = '1'\nexport const CLKCTL_CLKENSET0_RESERVED15_M: any = '1'\nexport const CLKCTL_CLKENSET0_RESERVED15_S: any = '1'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_ADC0: any = '1'\nexport const CLKCTL_CLKENSET0_ADC0_M: any = '1'\nexport const CLKCTL_CLKENSET0_ADC0_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_ADC0_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_ADC0_CLK_UNCHGD: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENSET0_RESERVED11: any = '3'\nexport const CLKCTL_CLKENSET0_RESERVED11_M: any = '3'\nexport const CLKCTL_CLKENSET0_RESERVED11_S: any = '3'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_SPI0: any = '1'\nexport const CLKCTL_CLKENSET0_SPI0_M: any = '1'\nexport const CLKCTL_CLKENSET0_SPI0_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_SPI0_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_SPI0_CLK_UNCHGD: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENSET0_RESERVED7: any = '3'\nexport const CLKCTL_CLKENSET0_RESERVED7_M: any = '3'\nexport const CLKCTL_CLKENSET0_RESERVED7_S: any = '3'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_I2C0: any = '1'\nexport const CLKCTL_CLKENSET0_I2C0_M: any = '1'\nexport const CLKCTL_CLKENSET0_I2C0_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_I2C0_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_I2C0_CLK_UNCHGD: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENSET0_RESERVED3: any = '3'\nexport const CLKCTL_CLKENSET0_RESERVED3_M: any = '3'\nexport const CLKCTL_CLKENSET0_RESERVED3_S: any = '3'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_UART0: any = '1'\nexport const CLKCTL_CLKENSET0_UART0_M: any = '1'\nexport const CLKCTL_CLKENSET0_UART0_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_UART0_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_UART0_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_LRFD: any = '1'\nexport const CLKCTL_CLKENSET0_LRFD_M: any = '1'\nexport const CLKCTL_CLKENSET0_LRFD_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_LRFD_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_LRFD_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENSET0_GPIO: any = '1'\nexport const CLKCTL_CLKENSET0_GPIO_M: any = '1'\nexport const CLKCTL_CLKENSET0_GPIO_S: any = '1'\n/**\nSet IP clock enable*/\nexport const CLKCTL_CLKENSET0_GPIO_CLK_SET: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENSET0_GPIO_CLK_UNCHGD: any = '0'\n\n\n// -------- REGISTER CLKENSET1 -------- //\n\n/**\nClock Enable Set Register 1.\n\nThis register enables IP clocks in the system. \nUsed to set the corresponding fields in CLKCFG1 to 1.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENSET1_RESERVED0: any = '32'\nexport const CLKCTL_CLKENSET1_RESERVED0_M: any = '32'\nexport const CLKCTL_CLKENSET1_RESERVED0_S: any = '32'\n\n// -------- REGISTER CLKENCLR0 -------- //\n\n/**\nClock Enable Clear Register 0.\n\nThis register disables IP clocks in the system. \nUsed to clear the corresponding fields in CLKCFG0 to 0.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENCLR0_RESERVED31: any = '1'\nexport const CLKCTL_CLKENCLR0_RESERVED31_M: any = '1'\nexport const CLKCTL_CLKENCLR0_RESERVED31_S: any = '1'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LGPT3: any = '1'\nexport const CLKCTL_CLKENCLR0_LGPT3_M: any = '1'\nexport const CLKCTL_CLKENCLR0_LGPT3_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LGPT3_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_LGPT3_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LGPT2: any = '1'\nexport const CLKCTL_CLKENCLR0_LGPT2_M: any = '1'\nexport const CLKCTL_CLKENCLR0_LGPT2_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LGPT2_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_LGPT2_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LGPT1: any = '1'\nexport const CLKCTL_CLKENCLR0_LGPT1_M: any = '1'\nexport const CLKCTL_CLKENCLR0_LGPT1_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LGPT1_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_LGPT1_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LGPT0: any = '1'\nexport const CLKCTL_CLKENCLR0_LGPT0_M: any = '1'\nexport const CLKCTL_CLKENCLR0_LGPT0_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LGPT0_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_LGPT0_CLK_UNCHGD: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENCLR0_RESERVED18: any = '9'\nexport const CLKCTL_CLKENCLR0_RESERVED18_M: any = '9'\nexport const CLKCTL_CLKENCLR0_RESERVED18_S: any = '9'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_DMA: any = '1'\nexport const CLKCTL_CLKENCLR0_DMA_M: any = '1'\nexport const CLKCTL_CLKENCLR0_DMA_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_DMA_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_DMA_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LAES: any = '1'\nexport const CLKCTL_CLKENCLR0_LAES_M: any = '1'\nexport const CLKCTL_CLKENCLR0_LAES_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LAES_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_LAES_CLK_UNCHGD: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENCLR0_RESERVED15: any = '1'\nexport const CLKCTL_CLKENCLR0_RESERVED15_M: any = '1'\nexport const CLKCTL_CLKENCLR0_RESERVED15_S: any = '1'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_ADC0: any = '1'\nexport const CLKCTL_CLKENCLR0_ADC0_M: any = '1'\nexport const CLKCTL_CLKENCLR0_ADC0_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_ADC0_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_ADC0_CLK_UNCHGD: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENCLR0_RESERVED11: any = '3'\nexport const CLKCTL_CLKENCLR0_RESERVED11_M: any = '3'\nexport const CLKCTL_CLKENCLR0_RESERVED11_S: any = '3'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_SPI0: any = '1'\nexport const CLKCTL_CLKENCLR0_SPI0_M: any = '1'\nexport const CLKCTL_CLKENCLR0_SPI0_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_SPI0_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_SPI0_CLK_UNCHGD: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENCLR0_RESERVED7: any = '3'\nexport const CLKCTL_CLKENCLR0_RESERVED7_M: any = '3'\nexport const CLKCTL_CLKENCLR0_RESERVED7_S: any = '3'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_I2C0: any = '1'\nexport const CLKCTL_CLKENCLR0_I2C0_M: any = '1'\nexport const CLKCTL_CLKENCLR0_I2C0_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_I2C0_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_I2C0_CLK_UNCHGD: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENCLR0_RESERVED3: any = '3'\nexport const CLKCTL_CLKENCLR0_RESERVED3_M: any = '3'\nexport const CLKCTL_CLKENCLR0_RESERVED3_S: any = '3'\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_UART0: any = '1'\nexport const CLKCTL_CLKENCLR0_UART0_M: any = '1'\nexport const CLKCTL_CLKENCLR0_UART0_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_UART0_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_UART0_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LRFD: any = '1'\nexport const CLKCTL_CLKENCLR0_LRFD_M: any = '1'\nexport const CLKCTL_CLKENCLR0_LRFD_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_LRFD_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_LRFD_CLK_UNCHGD: any = '0'\n\n/**\nConfigure IP clock enable*/\nexport const CLKCTL_CLKENCLR0_GPIO: any = '1'\nexport const CLKCTL_CLKENCLR0_GPIO_M: any = '1'\nexport const CLKCTL_CLKENCLR0_GPIO_S: any = '1'\n/**\nClear IP clock enable*/\nexport const CLKCTL_CLKENCLR0_GPIO_CLK_CLR: any = '1'\n\n/**\nIP clock enable is unchanged*/\nexport const CLKCTL_CLKENCLR0_GPIO_CLK_UNCHGD: any = '0'\n\n\n// -------- REGISTER CLKENCLR1 -------- //\n\n/**\nClock Enable Clear Register 1.\n\nThis register disables IP clocks in the system. \nUsed to clear the corresponding fields in CLKCFG1 to 0.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_CLKENCLR1_RESERVED0: any = '32'\nexport const CLKCTL_CLKENCLR1_RESERVED0_M: any = '32'\nexport const CLKCTL_CLKENCLR1_RESERVED0_S: any = '32'\n\n// -------- REGISTER STBYPTR -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CLKCTL_STBYPTR_VAL: any = '32'\nexport const CLKCTL_STBYPTR_VAL_M: any = '32'\nexport const CLKCTL_STBYPTR_VAL_S: any = '32'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const CLKCTL_STBYPTR_VAL_MIN: any = '0'\n\n\n// -------- REGISTER IDLECFG -------- //\n\n/**\nIDLE Configuration Register.\n\nThis register contains flash LDO configuration for IDLE mode.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const CLKCTL_IDLECFG_RESERVED1: any = '31'\nexport const CLKCTL_IDLECFG_RESERVED1_M: any = '31'\nexport const CLKCTL_IDLECFG_RESERVED1_S: any = '31'\n/**\nFlash LDO configuration in SLEEP/IDLE mode.*/\nexport const CLKCTL_IDLECFG_MODE: any = '1'\nexport const CLKCTL_IDLECFG_MODE_M: any = '1'\nexport const CLKCTL_IDLECFG_MODE_S: any = '1'\n/**\nFlash LDO is off in SLEEP/IDLE mode. \n\nDecreases power consumption in SLEEP/IDLE mode, but gives longer wake up time.\n\nNote: NVM clock is turned off independent of DMA status. Therefore SW must ensure that DMA never access NVM in this mode.*/\nexport const CLKCTL_IDLECFG_MODE_LDO_OFF: any = '1'\n\n/**\nFlash LDO is on in SLEEP/IDLE mode.\n\nGives fast wake up time from SLEEP/IDLE mode, but increased power consumption.*/\nexport const CLKCTL_IDLECFG_MODE_LDO_ON: any = '0'\n\n\n// -------- MODULE EVTSVT -------- //\n\nexport interface EVTSVT_t {\n    DESC: em.$Reg\n    DESCEX: em.$Reg\n    DTB: em.$Reg\n    NMISEL: em.$Reg\n    CPUIRQ0SEL: em.$Reg\n    CPUIRQ1SEL: em.$Reg\n    CPUIRQ2SEL: em.$Reg\n    CPUIRQ3SEL: em.$Reg\n    CPUIRQ4SEL: em.$Reg\n    CPUIRQ5SEL: em.$Reg\n    CPUIRQ6SEL: em.$Reg\n    CPUIRQ7SEL: em.$Reg\n    CPUIRQ8SEL: em.$Reg\n    CPUIRQ9SEL: em.$Reg\n    CPUIRQ10SEL: em.$Reg\n    CPUIRQ11SEL: em.$Reg\n    CPUIRQ12SEL: em.$Reg\n    CPUIRQ13SEL: em.$Reg\n    CPUIRQ14SEL: em.$Reg\n    CPUIRQ15SEL: em.$Reg\n    CPUIRQ16SEL: em.$Reg\n    CPUIRQ17SEL: em.$Reg\n    CPUIRQ18SEL: em.$Reg\n    SYSTIMC0SEL: em.$Reg\n    SYSTIMC1SEL: em.$Reg\n    SYSTIMC2SEL: em.$Reg\n    SYSTIMC3SEL: em.$Reg\n    SYSTIMC4SEL: em.$Reg\n    ADCTRGSEL: em.$Reg\n    LGPTSYNCSEL: em.$Reg\n    LGPT0IN0SEL: em.$Reg\n    LGPT0IN1SEL: em.$Reg\n    LGPT0IN2SEL: em.$Reg\n    LGPT0TENSEL: em.$Reg\n    LGPT1IN0SEL: em.$Reg\n    LGPT1IN1SEL: em.$Reg\n    LGPT1IN2SEL: em.$Reg\n    LGPT1TENSEL: em.$Reg\n    LGPT2IN0SEL: em.$Reg\n    LGPT2IN1SEL: em.$Reg\n    LGPT2IN2SEL: em.$Reg\n    LGPT2TENSEL: em.$Reg\n    LGPT3IN0SEL: em.$Reg\n    LGPT3IN1SEL: em.$Reg\n    LGPT3IN2SEL: em.$Reg\n    LGPT3TENSEL: em.$Reg\n    LRFDIN0SEL: em.$Reg\n    LRFDIN1SEL: em.$Reg\n    LRFDIN2SEL: em.$Reg\n    DMACH0SEL: em.$Reg\n    DMACH1SEL: em.$Reg\n    DMACH2SEL: em.$Reg\n    DMACH3SEL: em.$Reg\n    DMACH4SEL: em.$Reg\n    DMACH5SEL: em.$Reg\n    DMACH6SEL: em.$Reg\n    DMACH7SEL: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription \n\n\n                    This register provides IP module ID, revision information, instance index and standard MMR registers offset.*/\n/**\nModule identifier used to uniquely identify this IP.*/\nexport const EVTSVT_DESC_MODID: any = '16'\nexport const EVTSVT_DESC_MODID_M: any = '16'\nexport const EVTSVT_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set of from aggregated IRQ registers till DTB.\n\n0: Standard IP MMRs do not exist\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)*/\nexport const EVTSVT_DESC_STDIPOFF: any = '4'\nexport const EVTSVT_DESC_STDIPOFF_M: any = '4'\nexport const EVTSVT_DESC_STDIPOFF_S: any = '4'\n/**\nIP Instance ID number. If multiple instances of IP exist in the device, this field can identify the instance number (0-15).*/\nexport const EVTSVT_DESC_INSTIDX: any = '4'\nexport const EVTSVT_DESC_INSTIDX_M: any = '4'\nexport const EVTSVT_DESC_INSTIDX_S: any = '4'\n/**\nMajor revision of IP (0-15).*/\nexport const EVTSVT_DESC_MAJREV: any = '4'\nexport const EVTSVT_DESC_MAJREV_M: any = '4'\nexport const EVTSVT_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP (0-15).*/\nexport const EVTSVT_DESC_MINREV: any = '4'\nexport const EVTSVT_DESC_MINREV_M: any = '4'\nexport const EVTSVT_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER DESCEX -------- //\n\n/**\nExtended Description\n\n\n                    This register provides configuration details of the IP to software drivers and end users.\n*/\n/**\nNumber of DMA input channels*/\nexport const EVTSVT_DESCEX_IDMA: any = '10'\nexport const EVTSVT_DESCEX_IDMA_M: any = '10'\nexport const EVTSVT_DESCEX_IDMA_S: any = '10'\n/**\nNumber of DMA output channels*/\nexport const EVTSVT_DESCEX_NDMA: any = '5'\nexport const EVTSVT_DESCEX_NDMA_M: any = '5'\nexport const EVTSVT_DESCEX_NDMA_S: any = '5'\n/**\nPower Domain.\n\n0 : SVT\n 1 : ULL*/\nexport const EVTSVT_DESCEX_PD: any = '1'\nexport const EVTSVT_DESCEX_PD_M: any = '1'\nexport const EVTSVT_DESCEX_PD_S: any = '1'\n/**\nNumber of Subscribers*/\nexport const EVTSVT_DESCEX_NSUB: any = '8'\nexport const EVTSVT_DESCEX_NSUB_M: any = '8'\nexport const EVTSVT_DESCEX_NSUB_S: any = '8'\n/**\nNumber of Publishers*/\nexport const EVTSVT_DESCEX_NPUB: any = '8'\nexport const EVTSVT_DESCEX_NPUB_M: any = '8'\nexport const EVTSVT_DESCEX_NPUB_S: any = '8'\n\n// -------- REGISTER DTB -------- //\n\n/**\nDigital test bus control \n\n\n                    This register can be used to bring out IP internal signals to the pads for observation. 16 signals can be observed per select value.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DTB_RESERVED2: any = '30'\nexport const EVTSVT_DTB_RESERVED2_M: any = '30'\nexport const EVTSVT_DTB_RESERVED2_S: any = '30'\n/**\nDigital test bus selection mux control.\n\nNon-zero select values output a 16 bit selected group of signals per value.*/\nexport const EVTSVT_DTB_SEL: any = '2'\nexport const EVTSVT_DTB_SEL_M: any = '2'\nexport const EVTSVT_DTB_SEL_S: any = '2'\n/**\nAll 16 observation signals are set to zero.*/\nexport const EVTSVT_DTB_SEL_DIS: any = '0'\n\n\n// -------- REGISTER NMISEL -------- //\n\n/**\nOutput Selection for CPU NMI Exception\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_NMISEL_RESERVED6: any = '26'\nexport const EVTSVT_NMISEL_RESERVED6_M: any = '26'\nexport const EVTSVT_NMISEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_NMISEL_PUBID: any = '6'\nexport const EVTSVT_NMISEL_PUBID_M: any = '6'\nexport const EVTSVT_NMISEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_NMISEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_NMISEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_NMISEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_NMISEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_NMISEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_NMISEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_NMISEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_NMISEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_NMISEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_NMISEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_NMISEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_NMISEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_NMISEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_NMISEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_NMISEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_NMISEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_NMISEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_NMISEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_NMISEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_NMISEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_NMISEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_NMISEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_NMISEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_NMISEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_NMISEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_NMISEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_NMISEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_NMISEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_NMISEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_NMISEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nSelects an AON_NMI source, controlled by EVTULL:NMISEL*/\nexport const EVTSVT_NMISEL_PUBID_AON_NMI_SEL: any = '1'\n\n/**\nAlways inactive*/\nexport const EVTSVT_NMISEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER CPUIRQ0SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ0\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ0SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ0SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ0SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ0SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ0SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_CPUIRQ0SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_CPUIRQ0SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER CPUIRQ1SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ1\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ1SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ1SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ1SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ1SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ1SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_CPUIRQ1SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_CPUIRQ1SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER CPUIRQ2SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ2\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ2SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ2SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ2SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ2SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ2SEL_PUBID_S: any = '6'\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_CPUIRQ2SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER CPUIRQ3SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ3\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ3SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ3SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ3SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ3SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ3SEL_PUBID_S: any = '6'\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_CPUIRQ3SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER CPUIRQ4SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ4\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ4SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ4SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ4SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ4SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ4SEL_PUBID_S: any = '6'\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_CPUIRQ4SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER CPUIRQ5SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ5\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ5SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ5SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ5SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ5SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ5SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ5SEL_PUBID_S: any = '6'\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_CPUIRQ5SEL_PUBID_GPIO_COMB: any = '9'\n\n\n// -------- REGISTER CPUIRQ6SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ6\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ6SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ6SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ6SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ6SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ6SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ6SEL_PUBID_S: any = '6'\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_CPUIRQ6SEL_PUBID_LRFD_IRQ0: any = '12'\n\n\n// -------- REGISTER CPUIRQ7SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ7\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ7SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ7SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ7SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ7SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ7SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ7SEL_PUBID_S: any = '6'\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_CPUIRQ7SEL_PUBID_LRFD_IRQ1: any = '13'\n\n\n// -------- REGISTER CPUIRQ8SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ8\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ8SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ8SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ8SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ8SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ8SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ8SEL_PUBID_S: any = '6'\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_CPUIRQ8SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n\n// -------- REGISTER CPUIRQ9SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ9\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ9SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ9SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ9SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ9SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ9SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ9SEL_PUBID_S: any = '6'\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_CPUIRQ9SEL_PUBID_AES_COMB: any = '22'\n\n\n// -------- REGISTER CPUIRQ10SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ10\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ10SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ10SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ10SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ10SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ10SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ10SEL_PUBID_S: any = '6'\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_CPUIRQ10SEL_PUBID_SPI0_COMB: any = '15'\n\n\n// -------- REGISTER CPUIRQ11SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ11\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ11SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ11SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ11SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ11SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ11SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ11SEL_PUBID_S: any = '6'\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_CPUIRQ11SEL_PUBID_UART0_COMB: any = '23'\n\n\n// -------- REGISTER CPUIRQ12SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ12\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ12SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ12SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ12SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ12SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ12SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ12SEL_PUBID_S: any = '6'\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_CPUIRQ12SEL_PUBID_I2C0_IRQ: any = '24'\n\n\n// -------- REGISTER CPUIRQ13SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ13\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ13SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ13SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ13SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ13SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ13SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ13SEL_PUBID_S: any = '6'\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_CPUIRQ13SEL_PUBID_LGPT0_COMB: any = '18'\n\n\n// -------- REGISTER CPUIRQ14SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ14\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ14SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ14SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ14SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ14SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ14SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ14SEL_PUBID_S: any = '6'\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_CPUIRQ14SEL_PUBID_LGPT1_COMB: any = '19'\n\n\n// -------- REGISTER CPUIRQ15SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ15\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ15SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ15SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ15SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ15SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ15SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ15SEL_PUBID_S: any = '6'\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_CPUIRQ15SEL_PUBID_ADC_COMB: any = '16'\n\n\n// -------- REGISTER CPUIRQ16SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ16\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ16SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ16SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ16SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ16SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ16SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_CPUIRQ16SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_CPUIRQ16SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER CPUIRQ17SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ17\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ17SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ17SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ17SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ17SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ17SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ17SEL_PUBID_S: any = '6'\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_CPUIRQ17SEL_PUBID_LGPT2_COMB: any = '49'\n\n\n// -------- REGISTER CPUIRQ18SEL -------- //\n\n/**\nOutput Selection for CPU Interrupt CPUIRQ18\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_CPUIRQ18SEL_RESERVED6: any = '26'\nexport const EVTSVT_CPUIRQ18SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_CPUIRQ18SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_CPUIRQ18SEL_PUBID: any = '6'\nexport const EVTSVT_CPUIRQ18SEL_PUBID_M: any = '6'\nexport const EVTSVT_CPUIRQ18SEL_PUBID_S: any = '6'\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_CPUIRQ18SEL_PUBID_LGPT3_COMB: any = '55'\n\n\n// -------- REGISTER SYSTIMC0SEL -------- //\n\n/**\nOutput Selection for SYSTIMC0\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_SYSTIMC0SEL_RESERVED6: any = '26'\nexport const EVTSVT_SYSTIMC0SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_SYSTIMC0SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_SYSTIMC0SEL_PUBID: any = '6'\nexport const EVTSVT_SYSTIMC0SEL_PUBID_M: any = '6'\nexport const EVTSVT_SYSTIMC0SEL_PUBID_S: any = '6'\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_SYSTIMC0SEL_PUBID_AON_RTC_COMB: any = '4'\n\n\n// -------- REGISTER SYSTIMC1SEL -------- //\n\n/**\n Output Selection for SYSTIMC1\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_SYSTIMC1SEL_RESERVED6: any = '26'\nexport const EVTSVT_SYSTIMC1SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_SYSTIMC1SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID: any = '6'\nexport const EVTSVT_SYSTIMC1SEL_PUBID_M: any = '6'\nexport const EVTSVT_SYSTIMC1SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_SYSTIMC1SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_SYSTIMC1SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER SYSTIMC2SEL -------- //\n\n/**\nOutput Selection for SYSTIMC2\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_SYSTIMC2SEL_RESERVED6: any = '26'\nexport const EVTSVT_SYSTIMC2SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_SYSTIMC2SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_SYSTIMC2SEL_PUBID: any = '6'\nexport const EVTSVT_SYSTIMC2SEL_PUBID_M: any = '6'\nexport const EVTSVT_SYSTIMC2SEL_PUBID_S: any = '6'\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_SYSTIMC2SEL_PUBID_LRFD_EVT0: any = '42'\n\n\n// -------- REGISTER SYSTIMC3SEL -------- //\n\n/**\nOutput Selection for SYSTIMC3\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_SYSTIMC3SEL_RESERVED6: any = '26'\nexport const EVTSVT_SYSTIMC3SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_SYSTIMC3SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_SYSTIMC3SEL_PUBID: any = '6'\nexport const EVTSVT_SYSTIMC3SEL_PUBID_M: any = '6'\nexport const EVTSVT_SYSTIMC3SEL_PUBID_S: any = '6'\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_SYSTIMC3SEL_PUBID_LRFD_EVT1: any = '43'\n\n\n// -------- REGISTER SYSTIMC4SEL -------- //\n\n/**\nOutput Selection for SYSTIMC4\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_SYSTIMC4SEL_RESERVED6: any = '26'\nexport const EVTSVT_SYSTIMC4SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_SYSTIMC4SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_SYSTIMC4SEL_PUBID: any = '6'\nexport const EVTSVT_SYSTIMC4SEL_PUBID_M: any = '6'\nexport const EVTSVT_SYSTIMC4SEL_PUBID_S: any = '6'\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_SYSTIMC4SEL_PUBID_LRFD_EVT2: any = '44'\n\n\n// -------- REGISTER ADCTRGSEL -------- //\n\n/**\nOutput Selection for ADCTRG\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_ADCTRGSEL_RESERVED6: any = '26'\nexport const EVTSVT_ADCTRGSEL_RESERVED6_M: any = '26'\nexport const EVTSVT_ADCTRGSEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_ADCTRGSEL_PUBID: any = '6'\nexport const EVTSVT_ADCTRGSEL_PUBID_M: any = '6'\nexport const EVTSVT_ADCTRGSEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_ADCTRGSEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_ADCTRGSEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_ADCTRGSEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_ADCTRGSEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_ADCTRGSEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_ADCTRGSEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_ADCTRGSEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_ADCTRGSEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_ADCTRGSEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_ADCTRGSEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_ADCTRGSEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_ADCTRGSEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_ADCTRGSEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_ADCTRGSEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_ADCTRGSEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_ADCTRGSEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_ADCTRGSEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_ADCTRGSEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPTSYNCSEL -------- //\n\n/**\nOutput Selection for LGPTSYNC\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPTSYNCSEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPTSYNCSEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPTSYNCSEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID: any = '6'\nexport const EVTSVT_LGPTSYNCSEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPTSYNCSEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPTSYNCSEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPTSYNCSEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT0IN0SEL -------- //\n\n/**\nOutput Selection for LGPT0IN0\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT0IN0SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT0IN0SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT0IN0SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT0IN0SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT0IN0SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT0IN0SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT0IN0SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT0IN1SEL -------- //\n\n/**\nOutput Selection for LGPT0IN1\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT0IN1SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT0IN1SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT0IN1SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT0IN1SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT0IN1SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT0IN1SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT0IN1SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT0IN2SEL -------- //\n\n/**\nOutput Selection for LGPT0IN2\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT0IN2SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT0IN2SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT0IN2SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT0IN2SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT0IN2SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT0IN2SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT0IN2SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT0TENSEL -------- //\n\n/**\nOutput Selection for LGPT0TEN\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT0TENSEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT0TENSEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT0TENSEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT0TENSEL_PUBID: any = '6'\nexport const EVTSVT_LGPT0TENSEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT0TENSEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT0TENSEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT0TENSEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT1IN0SEL -------- //\n\n/**\nOutput Selection for LGPT1IN0\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT1IN0SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT1IN0SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT1IN0SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT1IN0SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT1IN0SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT1IN0SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT1IN0SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT1IN1SEL -------- //\n\n/**\nOutput Selection for LGPT1IN1\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT1IN1SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT1IN1SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT1IN1SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT1IN1SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT1IN1SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT1IN1SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT1IN1SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT1IN2SEL -------- //\n\n/**\nOutput Selection for LGPT1IN2\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT1IN2SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT1IN2SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT1IN2SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT1IN2SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT1IN2SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT1IN2SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT1IN2SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT1TENSEL -------- //\n\n/**\nOutput Selection for LGPT1TEN\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT1TENSEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT1TENSEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT1TENSEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT1TENSEL_PUBID: any = '6'\nexport const EVTSVT_LGPT1TENSEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT1TENSEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT1TENSEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT1TENSEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT2IN0SEL -------- //\n\n/**\nOutput Selection for LGPT2IN0\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT2IN0SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT2IN0SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT2IN0SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT2IN0SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT2IN0SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT2IN0SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT2IN0SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT2IN1SEL -------- //\n\n/**\nOutput Selection for LGPT2IN1\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT2IN1SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT2IN1SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT2IN1SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT2IN1SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT2IN1SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT2IN1SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT2IN1SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT2IN2SEL -------- //\n\n/**\nOutput Selection for LGPT2IN2\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT2IN2SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT2IN2SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT2IN2SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT2IN2SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT2IN2SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT2IN2SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT2IN2SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT2TENSEL -------- //\n\n/**\nOutput Selection for LGPT2TEN\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT2TENSEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT2TENSEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT2TENSEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT2TENSEL_PUBID: any = '6'\nexport const EVTSVT_LGPT2TENSEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT2TENSEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT2TENSEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT2TENSEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT3IN0SEL -------- //\n\n/**\nOutput Selection for LGPT3IN0\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT3IN0SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT3IN0SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT3IN0SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT3IN0SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT3IN0SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT3IN0SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT3IN0SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT3IN1SEL -------- //\n\n/**\nOutput Selection for LGPT3IN1\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT3IN1SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT3IN1SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT3IN1SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT3IN1SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT3IN1SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT3IN1SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT3IN1SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT3IN2SEL -------- //\n\n/**\nOutput Selection for LGPT3IN2\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT3IN2SEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT3IN2SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT3IN2SEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID: any = '6'\nexport const EVTSVT_LGPT3IN2SEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT3IN2SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT3IN2SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT3IN2SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LGPT3TENSEL -------- //\n\n/**\nOutput Selection for LGPT3TEN\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LGPT3TENSEL_RESERVED6: any = '26'\nexport const EVTSVT_LGPT3TENSEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LGPT3TENSEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_LGPT3TENSEL_PUBID: any = '6'\nexport const EVTSVT_LGPT3TENSEL_PUBID_M: any = '6'\nexport const EVTSVT_LGPT3TENSEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_LGPT3TENSEL_PUBID_ADC_EVT: any = '17'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nAlways inactive*/\nexport const EVTSVT_LGPT3TENSEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER LRFDIN0SEL -------- //\n\n/**\nOutput Selection for LRFDIN0\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LRFDIN0SEL_RESERVED6: any = '26'\nexport const EVTSVT_LRFDIN0SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LRFDIN0SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_LRFDIN0SEL_PUBID: any = '6'\nexport const EVTSVT_LRFDIN0SEL_PUBID_M: any = '6'\nexport const EVTSVT_LRFDIN0SEL_PUBID_S: any = '6'\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_LRFDIN0SEL_PUBID_SYSTIM2: any = '29'\n\n\n// -------- REGISTER LRFDIN1SEL -------- //\n\n/**\nOutput Selection for LRFDIN1\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LRFDIN1SEL_RESERVED6: any = '26'\nexport const EVTSVT_LRFDIN1SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LRFDIN1SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_LRFDIN1SEL_PUBID: any = '6'\nexport const EVTSVT_LRFDIN1SEL_PUBID_M: any = '6'\nexport const EVTSVT_LRFDIN1SEL_PUBID_S: any = '6'\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_LRFDIN1SEL_PUBID_SYSTIM3: any = '30'\n\n\n// -------- REGISTER LRFDIN2SEL -------- //\n\n/**\nOutput Selection for LRFDIN2\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_LRFDIN2SEL_RESERVED6: any = '26'\nexport const EVTSVT_LRFDIN2SEL_RESERVED6_M: any = '26'\nexport const EVTSVT_LRFDIN2SEL_RESERVED6_S: any = '26'\n/**\nRead only selection value*/\nexport const EVTSVT_LRFDIN2SEL_PUBID: any = '6'\nexport const EVTSVT_LRFDIN2SEL_PUBID_M: any = '6'\nexport const EVTSVT_LRFDIN2SEL_PUBID_S: any = '6'\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_LRFDIN2SEL_PUBID_SYSTIM4: any = '31'\n\n\n// -------- REGISTER DMACH0SEL -------- //\n\n/**\nOutput Selection for DMA CH0\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const EVTSVT_DMACH0SEL_RESERVED29: any = '3'\nexport const EVTSVT_DMACH0SEL_RESERVED29_M: any = '3'\nexport const EVTSVT_DMACH0SEL_RESERVED29_S: any = '3'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DMACH0SEL_RESERVED3: any = '26'\nexport const EVTSVT_DMACH0SEL_RESERVED3_M: any = '26'\nexport const EVTSVT_DMACH0SEL_RESERVED3_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_DMACH0SEL_IPID: any = '3'\nexport const EVTSVT_DMACH0SEL_IPID_M: any = '3'\nexport const EVTSVT_DMACH0SEL_IPID_S: any = '3'\n/**\nSelects uart0rxtrg as channel source*/\nexport const EVTSVT_DMACH0SEL_IPID_UART0RXTRG: any = '7'\n\n/**\nSelects spi0txtrg as channel source*/\nexport const EVTSVT_DMACH0SEL_IPID_SPI0TXTRG: any = '0'\n\n\n// -------- REGISTER DMACH1SEL -------- //\n\n/**\nOutput Selection for DMA CH1\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const EVTSVT_DMACH1SEL_RESERVED29: any = '3'\nexport const EVTSVT_DMACH1SEL_RESERVED29_M: any = '3'\nexport const EVTSVT_DMACH1SEL_RESERVED29_S: any = '3'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DMACH1SEL_RESERVED3: any = '26'\nexport const EVTSVT_DMACH1SEL_RESERVED3_M: any = '26'\nexport const EVTSVT_DMACH1SEL_RESERVED3_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_DMACH1SEL_IPID: any = '3'\nexport const EVTSVT_DMACH1SEL_IPID_M: any = '3'\nexport const EVTSVT_DMACH1SEL_IPID_S: any = '3'\n/**\nSelects uart0txtrg as channel source*/\nexport const EVTSVT_DMACH1SEL_IPID_UART0TXTRG: any = '6'\n\n/**\nSelects spi0rxtrg as channel source*/\nexport const EVTSVT_DMACH1SEL_IPID_SPI0RXTRG: any = '1'\n\n\n// -------- REGISTER DMACH2SEL -------- //\n\n/**\nOutput Selection for DMA CH2\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const EVTSVT_DMACH2SEL_RESERVED29: any = '3'\nexport const EVTSVT_DMACH2SEL_RESERVED29_M: any = '3'\nexport const EVTSVT_DMACH2SEL_RESERVED29_S: any = '3'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DMACH2SEL_RESERVED3: any = '26'\nexport const EVTSVT_DMACH2SEL_RESERVED3_M: any = '26'\nexport const EVTSVT_DMACH2SEL_RESERVED3_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_DMACH2SEL_IPID: any = '3'\nexport const EVTSVT_DMACH2SEL_IPID_M: any = '3'\nexport const EVTSVT_DMACH2SEL_IPID_S: any = '3'\n/**\nSelects uart0txtrg as channel source*/\nexport const EVTSVT_DMACH2SEL_IPID_UART0TXTRG: any = '6'\n\n/**\nReserved value. Should not be programmed.\n\n*/\nexport const EVTSVT_DMACH2SEL_IPID_RSVD: any = '2'\n\n\n// -------- REGISTER DMACH3SEL -------- //\n\n/**\nOutput Selection for DMA CH3\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const EVTSVT_DMACH3SEL_RESERVED29: any = '3'\nexport const EVTSVT_DMACH3SEL_RESERVED29_M: any = '3'\nexport const EVTSVT_DMACH3SEL_RESERVED29_S: any = '3'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DMACH3SEL_RESERVED3: any = '26'\nexport const EVTSVT_DMACH3SEL_RESERVED3_M: any = '26'\nexport const EVTSVT_DMACH3SEL_RESERVED3_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_DMACH3SEL_IPID: any = '3'\nexport const EVTSVT_DMACH3SEL_IPID_M: any = '3'\nexport const EVTSVT_DMACH3SEL_IPID_S: any = '3'\n/**\nSelects uart0rxtrg as channel source*/\nexport const EVTSVT_DMACH3SEL_IPID_UART0RXTRG: any = '7'\n\n/**\nSelects adc0trg as channel source*/\nexport const EVTSVT_DMACH3SEL_IPID_ADC0TRG: any = '5'\n\n\n// -------- REGISTER DMACH4SEL -------- //\n\n/**\nOutput Selection for DMA CH4\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const EVTSVT_DMACH4SEL_RESERVED29: any = '3'\nexport const EVTSVT_DMACH4SEL_RESERVED29_M: any = '3'\nexport const EVTSVT_DMACH4SEL_RESERVED29_S: any = '3'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DMACH4SEL_RESERVED3: any = '26'\nexport const EVTSVT_DMACH4SEL_RESERVED3_M: any = '26'\nexport const EVTSVT_DMACH4SEL_RESERVED3_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_DMACH4SEL_IPID: any = '3'\nexport const EVTSVT_DMACH4SEL_IPID_M: any = '3'\nexport const EVTSVT_DMACH4SEL_IPID_S: any = '3'\n/**\nSelects laestrga as channel source*/\nexport const EVTSVT_DMACH4SEL_IPID_LAESTRGA: any = '3'\n\n/**\nReserved value. Should not be programmed.\n\n*/\nexport const EVTSVT_DMACH4SEL_IPID_RSVD: any = '2'\n\n\n// -------- REGISTER DMACH5SEL -------- //\n\n/**\nOutput Selection for DMA CH5\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const EVTSVT_DMACH5SEL_RESERVED29: any = '3'\nexport const EVTSVT_DMACH5SEL_RESERVED29_M: any = '3'\nexport const EVTSVT_DMACH5SEL_RESERVED29_S: any = '3'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DMACH5SEL_RESERVED3: any = '26'\nexport const EVTSVT_DMACH5SEL_RESERVED3_M: any = '26'\nexport const EVTSVT_DMACH5SEL_RESERVED3_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_DMACH5SEL_IPID: any = '3'\nexport const EVTSVT_DMACH5SEL_IPID_M: any = '3'\nexport const EVTSVT_DMACH5SEL_IPID_S: any = '3'\n/**\nSelects adc0trg as channel source*/\nexport const EVTSVT_DMACH5SEL_IPID_ADC0TRG: any = '5'\n\n/**\nSelects laestrgb as channel source*/\nexport const EVTSVT_DMACH5SEL_IPID_LAESTRGB: any = '4'\n\n\n// -------- REGISTER DMACH6SEL -------- //\n\n/**\nOutput Selection for DMA CH6\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DMACH6SEL_RESERVED17: any = '15'\nexport const EVTSVT_DMACH6SEL_RESERVED17_M: any = '15'\nexport const EVTSVT_DMACH6SEL_RESERVED17_S: any = '15'\n/**\nEdge detect disable.\n\n0: Enabled.\n1: Disabled*/\nexport const EVTSVT_DMACH6SEL_EDGDETDIS: any = '1'\nexport const EVTSVT_DMACH6SEL_EDGDETDIS_M: any = '1'\nexport const EVTSVT_DMACH6SEL_EDGDETDIS_S: any = '1'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DMACH6SEL_RESERVED6: any = '10'\nexport const EVTSVT_DMACH6SEL_RESERVED6_M: any = '10'\nexport const EVTSVT_DMACH6SEL_RESERVED6_S: any = '10'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_DMACH6SEL_PUBID: any = '6'\nexport const EVTSVT_DMACH6SEL_PUBID_M: any = '6'\nexport const EVTSVT_DMACH6SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_DMACH6SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_DMACH6SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_DMACH6SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_DMACH6SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_DMACH6SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_DMACH6SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_DMACH6SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_DMACH6SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_DMACH6SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_DMACH6SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_DMACH6SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_DMACH6SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_DMACH6SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_DMACH6SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_DMACH6SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_DMACH6SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_DMACH6SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_DMACH6SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_DMACH6SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_DMACH6SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_DMACH6SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_DMACH6SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_DMACH6SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_DMACH6SEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER DMACH7SEL -------- //\n\n/**\nOutput Selection for DMA CH7\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DMACH7SEL_RESERVED17: any = '15'\nexport const EVTSVT_DMACH7SEL_RESERVED17_M: any = '15'\nexport const EVTSVT_DMACH7SEL_RESERVED17_S: any = '15'\n/**\nEdge detect disable.\n\n0: Enabled.\n1: Disabled*/\nexport const EVTSVT_DMACH7SEL_EDGDETDIS: any = '1'\nexport const EVTSVT_DMACH7SEL_EDGDETDIS_M: any = '1'\nexport const EVTSVT_DMACH7SEL_EDGDETDIS_S: any = '1'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTSVT_DMACH7SEL_RESERVED6: any = '10'\nexport const EVTSVT_DMACH7SEL_RESERVED6_M: any = '10'\nexport const EVTSVT_DMACH7SEL_RESERVED6_S: any = '10'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTSVT_DMACH7SEL_PUBID: any = '6'\nexport const EVTSVT_DMACH7SEL_PUBID_M: any = '6'\nexport const EVTSVT_DMACH7SEL_PUBID_S: any = '6'\n/**\nLGPT3 ADC trigger event, controlled by LGPT3:ADCTRG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT3_ADC: any = '57'\n\n/**\nLGPT3 DMA request event, controlled by LGPT3:DMA setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT3_DMA: any = '56'\n\n/**\nLGPT3 combined interrupt, interrupt flags are found here LGPT3:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT3_COMB: any = '55'\n\n/**\nLGPT3 compare/capture output event 2, controlled by LGPT3:C2CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT3C2: any = '54'\n\n/**\nLGPT3 compare/capture output event 1, controlled by LGPT3:C1CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT3C1: any = '53'\n\n/**\nLGPT3 compare/capture output event 0, controlled by LGPT3:C0CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT3C0: any = '52'\n\n/**\nLGPT2 ADC trigger event, controlled by LGPT2:ADCTRG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT2_ADC: any = '51'\n\n/**\nLGPT2 DMA request event, controlled by LGPT2:DMA setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT2_DMA: any = '50'\n\n/**\nLGPT2 combined interrupt, interrupt flags are found here LGPT2:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT2_COMB: any = '49'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT2:C2CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT2C2: any = '48'\n\n/**\nLGPT2 compare/capture output event 1, controlled by LGPT2:C1CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT2C1: any = '47'\n\n/**\nLGPT2 compare/capture output event 0, controlled by LGPT2:C0CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT2C0: any = '46'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC2*/\nexport const EVTSVT_DMACH7SEL_PUBID_LRFD_EVT2: any = '44'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC1*/\nexport const EVTSVT_DMACH7SEL_PUBID_LRFD_EVT1: any = '43'\n\n/**\nLRFD interrupt to SYSTIM, controlled by LRFDDBELL:SYSTIMOEV.SRC0*/\nexport const EVTSVT_DMACH7SEL_PUBID_LRFD_EVT0: any = '42'\n\n/**\nLGPT1 ADC trigger event, controlled by LGPT1:ADCTRG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT1_ADC: any = '41'\n\n/**\nLGPT1 DMA request event, controlled by LGPT1:DMA setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT1_DMA: any = '40'\n\n/**\nLGPT1 compare/capture output event 2, controlled by LGPT1:C2CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT1C2: any = '39'\n\n/**\nLGPT1 compare/capture output event 1, controlled by LGPT1:C1CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT1C1: any = '38'\n\n/**\nLGPT1 compare/capture output event 0, controlled by LGPT1:C0CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT1C0: any = '37'\n\n/**\nLGPT0 ADC trigger event, controlled by LGPT0:ADCTRG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT0_ADC: any = '36'\n\n/**\nLGPT0 DMA request event, controlled by LGPT0:DMA setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT0_DMA: any = '35'\n\n/**\nLGPT0 compare/capture output event 2, controlled by LGPT0:C2CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT0C2: any = '34'\n\n/**\nLGPT0 compare/capture output event 1, controlled by LGPT0:C1CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT0C1: any = '33'\n\n/**\nLGPT0 compare/capture output event 0, controlled by LGPT0:C0CFG setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT0C0: any = '32'\n\n/**\nSYSTIM Channel 4 event, event flag is SYSTIM:MIS.EVT4*/\nexport const EVTSVT_DMACH7SEL_PUBID_SYSTIM4: any = '31'\n\n/**\nSYSTIM Channel 3 event, event flag is SYSTIM:MIS.EVT3*/\nexport const EVTSVT_DMACH7SEL_PUBID_SYSTIM3: any = '30'\n\n/**\nSYSTIM Channel 2 event, event flag is SYSTIM:MIS.EVT2*/\nexport const EVTSVT_DMACH7SEL_PUBID_SYSTIM2: any = '29'\n\n/**\nSYSTIM Channel 1 event, event flag is  SYSTIM:MIS.EVT1*/\nexport const EVTSVT_DMACH7SEL_PUBID_SYSTIM1: any = '28'\n\n/**\nSYSTIM Channel 0 event, event flag is SYSTIM:MIS.EVT0*/\nexport const EVTSVT_DMACH7SEL_PUBID_SYSTIM0: any = '27'\n\n/**\nSYSTIM interrupt driven by synchronizing LFTICK signal to SVT clock*/\nexport const EVTSVT_DMACH7SEL_PUBID_SYSTIM_LT: any = '26'\n\n/**\nSYSTIM heartbeat, can be set by SYSTIM:TIMEBIT*/\nexport const EVTSVT_DMACH7SEL_PUBID_SYSTIM_HB: any = '25'\n\n/**\nInterrupt event from I2C0, interrupt flags can be found here I2C0:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_I2C0_IRQ: any = '24'\n\n/**\nUART0 combined interrupt, interrupt flags are found here UART0:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_UART0_COMB: any = '23'\n\n/**\nAES accelerator combined interrupt request, interrupt flags can be found here AES:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_AES_COMB: any = '22'\n\n/**\nDMA bus error, corresponds to DMA:ERROR.STATUS*/\nexport const EVTSVT_DMACH7SEL_PUBID_DMA_ERR: any = '21'\n\n/**\nDMA combined done interrupt, corresponding flags can be found here DMA:REQDONE*/\nexport const EVTSVT_DMACH7SEL_PUBID_DMA_DONE_COMB: any = '20'\n\n/**\nLGPT1 combined interrupt, interrupt flags are found here LGPT1:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT1_COMB: any = '19'\n\n/**\nLGPT0 combined interrupt, interrupt flags are found here LGPT0:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_LGPT0_COMB: any = '18'\n\n/**\nADC general published event, interrupt flags can be found here ADC:MIS1 */\nexport const EVTSVT_DMACH7SEL_PUBID_ADC_EVT: any = '17'\n\n/**\nADC combined interrupt request, interrupt flags can be found here ADC:MIS0*/\nexport const EVTSVT_DMACH7SEL_PUBID_ADC_COMB: any = '16'\n\n/**\nSPI0 combined interrupt request, interrupt flags can be found here SPI0:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_SPI0_COMB: any = '15'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS2*/\nexport const EVTSVT_DMACH7SEL_PUBID_LRFD_IRQ2: any = '14'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS1*/\nexport const EVTSVT_DMACH7SEL_PUBID_LRFD_IRQ1: any = '13'\n\n/**\nLRFD combined event, interrupt flags can be found here LRFDDBELL:MIS0*/\nexport const EVTSVT_DMACH7SEL_PUBID_LRFD_IRQ0: any = '12'\n\n/**\nNoWrapper Flash interrupt indicating that the flash operation has completed, interrupt flags can be found here FLASH:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_FLASH_IRQ: any = '11'\n\n/**\nGPIO generic published event, controlled by GPIO:EVTCFG*/\nexport const EVTSVT_DMACH7SEL_PUBID_GPIO_EVT: any = '10'\n\n/**\nGPIO combined wake up interrupt, interrupt flags can be found here GPIO:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_GPIO_COMB: any = '9'\n\n/**\nSYSTIM combined interrupt, interrupt flags are found here SYSTIM:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_SYSTIM_COMB: any = '8'\n\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTSVT_DMACH7SEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTSVT_DMACH7SEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTSVT_DMACH7SEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTSVT_DMACH7SEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTSVT_DMACH7SEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTSVT_DMACH7SEL_PUBID_NONE: any = '0'\n\n\n// -------- MODULE EVTULL -------- //\n\nexport interface EVTULL_t {\n    DESC: em.$Reg\n    DESCEX: em.$Reg\n    DTB: em.$Reg\n    NMISEL: em.$Reg\n    RTCCPTSEL: em.$Reg\n    WKUPMASK: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription\n\n\n          This register provides IP module ID, revision information, instance index and standard MMR registers offset.\n*/\n/**\nModule identifier used to uniquely identify this IP.*/\nexport const EVTULL_DESC_MODID: any = '16'\nexport const EVTULL_DESC_MODID_M: any = '16'\nexport const EVTULL_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set of from aggregated IRQ registers till DTB.\n\n0: Standard IP MMRs do not exist\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)*/\nexport const EVTULL_DESC_STDIPOFF: any = '4'\nexport const EVTULL_DESC_STDIPOFF_M: any = '4'\nexport const EVTULL_DESC_STDIPOFF_S: any = '4'\n/**\nIP Instance ID number. If multiple instances of IP exist in the device, this field can identify the instance number (0-15).*/\nexport const EVTULL_DESC_INSTIDX: any = '4'\nexport const EVTULL_DESC_INSTIDX_M: any = '4'\nexport const EVTULL_DESC_INSTIDX_S: any = '4'\n/**\nMajor revision of IP (0-15).*/\nexport const EVTULL_DESC_MAJREV: any = '4'\nexport const EVTULL_DESC_MAJREV_M: any = '4'\nexport const EVTULL_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP (0-15).*/\nexport const EVTULL_DESC_MINREV: any = '4'\nexport const EVTULL_DESC_MINREV_M: any = '4'\nexport const EVTULL_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER DESCEX -------- //\n\n/**\nExtended Description\n\n\n          This register provides configuration details of the IP to software drivers and end users.\n*/\n/**\nNumber of DMA input channels*/\nexport const EVTULL_DESCEX_IDMA: any = '10'\nexport const EVTULL_DESCEX_IDMA_M: any = '10'\nexport const EVTULL_DESCEX_IDMA_S: any = '10'\n/**\nNumber of DMA output channels*/\nexport const EVTULL_DESCEX_NDMA: any = '5'\nexport const EVTULL_DESCEX_NDMA_M: any = '5'\nexport const EVTULL_DESCEX_NDMA_S: any = '5'\n/**\nPower Domain.\n\n0 : SVT\n 1 : ULL*/\nexport const EVTULL_DESCEX_PD: any = '1'\nexport const EVTULL_DESCEX_PD_M: any = '1'\nexport const EVTULL_DESCEX_PD_S: any = '1'\n/**\nNumber of Subscribers*/\nexport const EVTULL_DESCEX_NSUB: any = '8'\nexport const EVTULL_DESCEX_NSUB_M: any = '8'\nexport const EVTULL_DESCEX_NSUB_S: any = '8'\n/**\nNumber of Publishers*/\nexport const EVTULL_DESCEX_NPUB: any = '8'\nexport const EVTULL_DESCEX_NPUB_M: any = '8'\nexport const EVTULL_DESCEX_NPUB_S: any = '8'\n\n// -------- REGISTER DTB -------- //\n\n/**\nDigital test bus control register\n\n\n            This register can be used to bring out IP internal signals to the pads for observation. 16 signals can be observed per select value.\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTULL_DTB_RESERVED1: any = '31'\nexport const EVTULL_DTB_RESERVED1_M: any = '31'\nexport const EVTULL_DTB_RESERVED1_S: any = '31'\n/**\nDigital test bus selection mux control\n\n\n            Non-zero select values output a 16 bit selected group of signals per value.*/\nexport const EVTULL_DTB_SEL: any = '1'\nexport const EVTULL_DTB_SEL_M: any = '1'\nexport const EVTULL_DTB_SEL_S: any = '1'\n/**\nAll 16 observation signals are set to zero.*/\nexport const EVTULL_DTB_SEL_DIS: any = '0'\n\n\n// -------- REGISTER NMISEL -------- //\n\n/**\nOutput Selection for CPU NMI Exception\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTULL_NMISEL_RESERVED6: any = '26'\nexport const EVTULL_NMISEL_RESERVED6_M: any = '26'\nexport const EVTULL_NMISEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTULL_NMISEL_PUBID: any = '6'\nexport const EVTULL_NMISEL_PUBID_M: any = '6'\nexport const EVTULL_NMISEL_PUBID_S: any = '6'\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTULL_NMISEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTULL_NMISEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTULL_NMISEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTULL_NMISEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTULL_NMISEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTULL_NMISEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTULL_NMISEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER RTCCPTSEL -------- //\n\n/**\nOutput Selection for RTCCPT\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTULL_RTCCPTSEL_RESERVED6: any = '26'\nexport const EVTULL_RTCCPTSEL_RESERVED6_M: any = '26'\nexport const EVTULL_RTCCPTSEL_RESERVED6_S: any = '26'\n/**\nRead/write selection value.\n\nWriting any other value than values defined by a ENUM may result in undefined behavior.*/\nexport const EVTULL_RTCCPTSEL_PUBID: any = '6'\nexport const EVTULL_RTCCPTSEL_PUBID_M: any = '6'\nexport const EVTULL_RTCCPTSEL_PUBID_S: any = '6'\n/**\nIOC synchronous combined event, controlled by IOC:EVTCFG*/\nexport const EVTULL_RTCCPTSEL_PUBID_AON_IOC_COMB: any = '7'\n\n/**\nAON LPCMP interrupt, controlled by SYS0:LPCMPCFG*/\nexport const EVTULL_RTCCPTSEL_PUBID_AON_LPMCMP_IRQ: any = '6'\n\n/**\nDebugSS combined interrupt, interrupt flags can be found here DBGSS:MIS*/\nexport const EVTULL_RTCCPTSEL_PUBID_AON_DBG_COMB: any = '5'\n\n/**\nAON_RTC event, controlled by the RTC:IMASK setting*/\nexport const EVTULL_RTCCPTSEL_PUBID_AON_RTC_COMB: any = '4'\n\n/**\nCKMD combined interrupt request, interrupt flags can be found here CKMD:MIS*/\nexport const EVTULL_RTCCPTSEL_PUBID_AON_CKM_COMB: any = '3'\n\n/**\nPMU combined interrupt request for BATMON, interrupt flags can be found here PMUD:EVENT*/\nexport const EVTULL_RTCCPTSEL_PUBID_AON_PMU_COMB: any = '2'\n\n/**\nAlways inactive*/\nexport const EVTULL_RTCCPTSEL_PUBID_NONE: any = '0'\n\n\n// -------- REGISTER WKUPMASK -------- //\n\n/**\nWAKEUP Mask\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTULL_WKUPMASK_RESERVED8: any = '24'\nexport const EVTULL_WKUPMASK_RESERVED8_M: any = '24'\nexport const EVTULL_WKUPMASK_RESERVED8_S: any = '24'\n/**\nWake-up mask for AON_IOC_COMB.\n\n0 - Wakeup Disabled\n1 - Wakeup Enabled*/\nexport const EVTULL_WKUPMASK_AON_IOC_COMB: any = '1'\nexport const EVTULL_WKUPMASK_AON_IOC_COMB_M: any = '1'\nexport const EVTULL_WKUPMASK_AON_IOC_COMB_S: any = '1'\n/**\nWake-up mask for AON_LPMCMP_IRQ.\n\n0 - Wakeup Disabled\n1 - Wakeup Enabled*/\nexport const EVTULL_WKUPMASK_AON_LPMCMP_IRQ: any = '1'\nexport const EVTULL_WKUPMASK_AON_LPMCMP_IRQ_M: any = '1'\nexport const EVTULL_WKUPMASK_AON_LPMCMP_IRQ_S: any = '1'\n/**\nWake-up mask for AON_DBG_COMB.\n\n0 - Wakeup Disabled\n1 - Wakeup Enabled*/\nexport const EVTULL_WKUPMASK_AON_DBG_COMB: any = '1'\nexport const EVTULL_WKUPMASK_AON_DBG_COMB_M: any = '1'\nexport const EVTULL_WKUPMASK_AON_DBG_COMB_S: any = '1'\n/**\nWake-up mask for AON_RTC_COMB.\n\n0 - Wakeup Disabled\n1 - Wakeup Enabled*/\nexport const EVTULL_WKUPMASK_AON_RTC_COMB: any = '1'\nexport const EVTULL_WKUPMASK_AON_RTC_COMB_M: any = '1'\nexport const EVTULL_WKUPMASK_AON_RTC_COMB_S: any = '1'\n/**\nWake-up mask for AON_CKM_COMB.\n\n0 - Wakeup Disabled\n1 - Wakeup Enabled*/\nexport const EVTULL_WKUPMASK_AON_CKM_COMB: any = '1'\nexport const EVTULL_WKUPMASK_AON_CKM_COMB_M: any = '1'\nexport const EVTULL_WKUPMASK_AON_CKM_COMB_S: any = '1'\n/**\nWake-up mask for AON_PMU_COMB.\n\n0 - Wakeup Disabled\n1 - Wakeup Enabled*/\nexport const EVTULL_WKUPMASK_AON_PMU_COMB: any = '1'\nexport const EVTULL_WKUPMASK_AON_PMU_COMB_M: any = '1'\nexport const EVTULL_WKUPMASK_AON_PMU_COMB_S: any = '1'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior*/\nexport const EVTULL_WKUPMASK_RESERVED0: any = '2'\nexport const EVTULL_WKUPMASK_RESERVED0_M: any = '2'\nexport const EVTULL_WKUPMASK_RESERVED0_S: any = '2'\n\n// -------- MODULE GPIO -------- //\n\nexport interface GPIO_t {\n    DESC: em.$Reg\n    DESCEX: em.$Reg\n    IMASK: em.$Reg\n    RIS: em.$Reg\n    MIS: em.$Reg\n    ISET: em.$Reg\n    ICLR: em.$Reg\n    IMSET: em.$Reg\n    IMCLR: em.$Reg\n    DOUT3_0: em.$Reg\n    DOUT7_4: em.$Reg\n    DOUT11_8: em.$Reg\n    DOUT15_12: em.$Reg\n    DOUT19_16: em.$Reg\n    DOUT23_20: em.$Reg\n    DOUT27_24: em.$Reg\n    DOUT31_0: em.$Reg\n    DOUTSET31_0: em.$Reg\n    DOUTCLR31_0: em.$Reg\n    DOUTTGL31_0: em.$Reg\n    DOUTTGL3_0: em.$Reg\n    DOUTTGL7_4: em.$Reg\n    DOUTTGL11_8: em.$Reg\n    DOUTTGL15_12: em.$Reg\n    DOUTTGL19_16: em.$Reg\n    DOUTTGL23_20: em.$Reg\n    DOUTTGL27_24: em.$Reg\n    DOE3_0: em.$Reg\n    DOE7_4: em.$Reg\n    DOE11_8: em.$Reg\n    DOE15_12: em.$Reg\n    DOE19_16: em.$Reg\n    DOE23_20: em.$Reg\n    DOE27_24: em.$Reg\n    DOE31_0: em.$Reg\n    DOESET31_0: em.$Reg\n    DOECLR31_0: em.$Reg\n    DOETGL31_0: em.$Reg\n    DIN3_0: em.$Reg\n    DIN7_4: em.$Reg\n    DIN11_8: em.$Reg\n    DIN15_12: em.$Reg\n    DIN19_16: em.$Reg\n    DIN23_20: em.$Reg\n    DIN27_24: em.$Reg\n    DIN31_0: em.$Reg\n    EVTCFG: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription Register. This register provides IP module ID, revision information, instance index and standard MMR registers offset.*/\n/**\nModule identifier used to uniquely identify this IP.*/\nexport const GPIO_DESC_MODID: any = '16'\nexport const GPIO_DESC_MODID_M: any = '16'\nexport const GPIO_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set from aggregated IRQ registers till DTB.\n\n\n0: Standard IP MMRs do not exist\n\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)*/\nexport const GPIO_DESC_STDIPOFF: any = '4'\nexport const GPIO_DESC_STDIPOFF_M: any = '4'\nexport const GPIO_DESC_STDIPOFF_S: any = '4'\n/**\nIP Instance ID number. If multiple instances of IP exist in the device, this field can identify the instance number (0-15).*/\nexport const GPIO_DESC_INSTIDX: any = '4'\nexport const GPIO_DESC_INSTIDX_M: any = '4'\nexport const GPIO_DESC_INSTIDX_S: any = '4'\n/**\nMajor revision of IP (0-15).*/\nexport const GPIO_DESC_MAJREV: any = '4'\nexport const GPIO_DESC_MAJREV_M: any = '4'\nexport const GPIO_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP (0-15).*/\nexport const GPIO_DESC_MINREV: any = '4'\nexport const GPIO_DESC_MINREV_M: any = '4'\nexport const GPIO_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER DESCEX -------- //\n\n/**\nExtended Description Register. This register provides configuration details of the IP to software drivers and end users.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DESCEX_RESERVED6: any = '26'\nexport const GPIO_DESCEX_RESERVED6_M: any = '26'\nexport const GPIO_DESCEX_RESERVED6_S: any = '26'\n/**\nThis provides the total number of DIOs supported by GPIO. The number of DIOs supprted is NUMDIO + 1*/\nexport const GPIO_DESCEX_NUMDIO: any = '6'\nexport const GPIO_DESCEX_NUMDIO_M: any = '6'\nexport const GPIO_DESCEX_NUMDIO_S: any = '6'\n\n// -------- REGISTER IMASK -------- //\n\n/**\nInterrupt mask for DIO pins*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_IMASK_RESERVED26: any = '6'\nexport const GPIO_IMASK_RESERVED26_M: any = '6'\nexport const GPIO_IMASK_RESERVED26_S: any = '6'\n/**\nInterrupt mask for DIO25*/\nexport const GPIO_IMASK_DIO25: any = '1'\nexport const GPIO_IMASK_DIO25_M: any = '1'\nexport const GPIO_IMASK_DIO25_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO25_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO25_CLR: any = '0'\n\n/**\nInterrupt mask for DIO24*/\nexport const GPIO_IMASK_DIO24: any = '1'\nexport const GPIO_IMASK_DIO24_M: any = '1'\nexport const GPIO_IMASK_DIO24_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO24_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO24_CLR: any = '0'\n\n/**\nInterrupt mask for DIO23*/\nexport const GPIO_IMASK_DIO23: any = '1'\nexport const GPIO_IMASK_DIO23_M: any = '1'\nexport const GPIO_IMASK_DIO23_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO23_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO23_CLR: any = '0'\n\n/**\nInterrupt mask for DIO22*/\nexport const GPIO_IMASK_DIO22: any = '1'\nexport const GPIO_IMASK_DIO22_M: any = '1'\nexport const GPIO_IMASK_DIO22_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO22_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO22_CLR: any = '0'\n\n/**\nInterrupt mask for DIO21*/\nexport const GPIO_IMASK_DIO21: any = '1'\nexport const GPIO_IMASK_DIO21_M: any = '1'\nexport const GPIO_IMASK_DIO21_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO21_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO21_CLR: any = '0'\n\n/**\nInterrupt mask for DIO20*/\nexport const GPIO_IMASK_DIO20: any = '1'\nexport const GPIO_IMASK_DIO20_M: any = '1'\nexport const GPIO_IMASK_DIO20_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO20_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO20_CLR: any = '0'\n\n/**\nInterrupt mask for DIO19*/\nexport const GPIO_IMASK_DIO19: any = '1'\nexport const GPIO_IMASK_DIO19_M: any = '1'\nexport const GPIO_IMASK_DIO19_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO19_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO19_CLR: any = '0'\n\n/**\nInterrupt mask for DIO18*/\nexport const GPIO_IMASK_DIO18: any = '1'\nexport const GPIO_IMASK_DIO18_M: any = '1'\nexport const GPIO_IMASK_DIO18_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO18_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO18_CLR: any = '0'\n\n/**\nInterrupt mask for DIO17*/\nexport const GPIO_IMASK_DIO17: any = '1'\nexport const GPIO_IMASK_DIO17_M: any = '1'\nexport const GPIO_IMASK_DIO17_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO17_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO17_CLR: any = '0'\n\n/**\nInterrupt mask for DIO16*/\nexport const GPIO_IMASK_DIO16: any = '1'\nexport const GPIO_IMASK_DIO16_M: any = '1'\nexport const GPIO_IMASK_DIO16_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO16_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO16_CLR: any = '0'\n\n/**\nInterrupt mask for DIO15*/\nexport const GPIO_IMASK_DIO15: any = '1'\nexport const GPIO_IMASK_DIO15_M: any = '1'\nexport const GPIO_IMASK_DIO15_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO15_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO15_CLR: any = '0'\n\n/**\nInterrupt mask for DIO14*/\nexport const GPIO_IMASK_DIO14: any = '1'\nexport const GPIO_IMASK_DIO14_M: any = '1'\nexport const GPIO_IMASK_DIO14_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO14_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO14_CLR: any = '0'\n\n/**\nInterrupt mask for DIO13*/\nexport const GPIO_IMASK_DIO13: any = '1'\nexport const GPIO_IMASK_DIO13_M: any = '1'\nexport const GPIO_IMASK_DIO13_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO13_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO13_CLR: any = '0'\n\n/**\nInterrupt mask for DIO12*/\nexport const GPIO_IMASK_DIO12: any = '1'\nexport const GPIO_IMASK_DIO12_M: any = '1'\nexport const GPIO_IMASK_DIO12_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO12_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO12_CLR: any = '0'\n\n/**\nInterrupt mask for DIO11*/\nexport const GPIO_IMASK_DIO11: any = '1'\nexport const GPIO_IMASK_DIO11_M: any = '1'\nexport const GPIO_IMASK_DIO11_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO11_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO11_CLR: any = '0'\n\n/**\nInterrupt mask for DIO10*/\nexport const GPIO_IMASK_DIO10: any = '1'\nexport const GPIO_IMASK_DIO10_M: any = '1'\nexport const GPIO_IMASK_DIO10_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO10_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO10_CLR: any = '0'\n\n/**\nInterrupt mask for DIO9*/\nexport const GPIO_IMASK_DIO9: any = '1'\nexport const GPIO_IMASK_DIO9_M: any = '1'\nexport const GPIO_IMASK_DIO9_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO9_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO9_CLR: any = '0'\n\n/**\nInterrupt mask for DIO8*/\nexport const GPIO_IMASK_DIO8: any = '1'\nexport const GPIO_IMASK_DIO8_M: any = '1'\nexport const GPIO_IMASK_DIO8_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO8_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO8_CLR: any = '0'\n\n/**\nInterrupt mask for DIO7*/\nexport const GPIO_IMASK_DIO7: any = '1'\nexport const GPIO_IMASK_DIO7_M: any = '1'\nexport const GPIO_IMASK_DIO7_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO7_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO7_CLR: any = '0'\n\n/**\nInterrupt mask for DIO6*/\nexport const GPIO_IMASK_DIO6: any = '1'\nexport const GPIO_IMASK_DIO6_M: any = '1'\nexport const GPIO_IMASK_DIO6_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO6_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO6_CLR: any = '0'\n\n/**\nInterrupt mask for DIO5*/\nexport const GPIO_IMASK_DIO5: any = '1'\nexport const GPIO_IMASK_DIO5_M: any = '1'\nexport const GPIO_IMASK_DIO5_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO5_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO5_CLR: any = '0'\n\n/**\nInterrupt mask for DIO4*/\nexport const GPIO_IMASK_DIO4: any = '1'\nexport const GPIO_IMASK_DIO4_M: any = '1'\nexport const GPIO_IMASK_DIO4_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO4_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO4_CLR: any = '0'\n\n/**\nInterrupt mask for DIO3*/\nexport const GPIO_IMASK_DIO3: any = '1'\nexport const GPIO_IMASK_DIO3_M: any = '1'\nexport const GPIO_IMASK_DIO3_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO3_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO3_CLR: any = '0'\n\n/**\nInterrupt mask for DIO2*/\nexport const GPIO_IMASK_DIO2: any = '1'\nexport const GPIO_IMASK_DIO2_M: any = '1'\nexport const GPIO_IMASK_DIO2_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO2_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO2_CLR: any = '0'\n\n/**\nInterrupt mask for DIO1*/\nexport const GPIO_IMASK_DIO1: any = '1'\nexport const GPIO_IMASK_DIO1_M: any = '1'\nexport const GPIO_IMASK_DIO1_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO1_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO1_CLR: any = '0'\n\n/**\nInterrupt mask for DIO0*/\nexport const GPIO_IMASK_DIO0: any = '1'\nexport const GPIO_IMASK_DIO0_M: any = '1'\nexport const GPIO_IMASK_DIO0_S: any = '1'\n/**\nSet Interrrupt Mask*/\nexport const GPIO_IMASK_DIO0_SET: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const GPIO_IMASK_DIO0_CLR: any = '0'\n\n\n// -------- REGISTER RIS -------- //\n\n/**\nRaw interrupt flag for DIO pins*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_RIS_RESERVED26: any = '6'\nexport const GPIO_RIS_RESERVED26_M: any = '6'\nexport const GPIO_RIS_RESERVED26_S: any = '6'\n/**\nRaw interrupt flag for DIO25*/\nexport const GPIO_RIS_DIO25: any = '1'\nexport const GPIO_RIS_DIO25_M: any = '1'\nexport const GPIO_RIS_DIO25_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO25_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO25_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO24*/\nexport const GPIO_RIS_DIO24: any = '1'\nexport const GPIO_RIS_DIO24_M: any = '1'\nexport const GPIO_RIS_DIO24_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO24_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO24_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO23*/\nexport const GPIO_RIS_DIO23: any = '1'\nexport const GPIO_RIS_DIO23_M: any = '1'\nexport const GPIO_RIS_DIO23_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO23_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO23_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO22*/\nexport const GPIO_RIS_DIO22: any = '1'\nexport const GPIO_RIS_DIO22_M: any = '1'\nexport const GPIO_RIS_DIO22_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO22_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO22_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO21*/\nexport const GPIO_RIS_DIO21: any = '1'\nexport const GPIO_RIS_DIO21_M: any = '1'\nexport const GPIO_RIS_DIO21_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO21_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO21_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO20*/\nexport const GPIO_RIS_DIO20: any = '1'\nexport const GPIO_RIS_DIO20_M: any = '1'\nexport const GPIO_RIS_DIO20_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO20_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO20_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO19*/\nexport const GPIO_RIS_DIO19: any = '1'\nexport const GPIO_RIS_DIO19_M: any = '1'\nexport const GPIO_RIS_DIO19_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO19_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO19_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO18*/\nexport const GPIO_RIS_DIO18: any = '1'\nexport const GPIO_RIS_DIO18_M: any = '1'\nexport const GPIO_RIS_DIO18_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO18_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO18_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO17*/\nexport const GPIO_RIS_DIO17: any = '1'\nexport const GPIO_RIS_DIO17_M: any = '1'\nexport const GPIO_RIS_DIO17_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO17_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO17_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO16*/\nexport const GPIO_RIS_DIO16: any = '1'\nexport const GPIO_RIS_DIO16_M: any = '1'\nexport const GPIO_RIS_DIO16_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO16_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO16_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO15*/\nexport const GPIO_RIS_DIO15: any = '1'\nexport const GPIO_RIS_DIO15_M: any = '1'\nexport const GPIO_RIS_DIO15_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO15_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO15_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO14*/\nexport const GPIO_RIS_DIO14: any = '1'\nexport const GPIO_RIS_DIO14_M: any = '1'\nexport const GPIO_RIS_DIO14_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO14_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO14_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO13*/\nexport const GPIO_RIS_DIO13: any = '1'\nexport const GPIO_RIS_DIO13_M: any = '1'\nexport const GPIO_RIS_DIO13_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO13_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO13_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO12*/\nexport const GPIO_RIS_DIO12: any = '1'\nexport const GPIO_RIS_DIO12_M: any = '1'\nexport const GPIO_RIS_DIO12_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO12_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO12_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO11*/\nexport const GPIO_RIS_DIO11: any = '1'\nexport const GPIO_RIS_DIO11_M: any = '1'\nexport const GPIO_RIS_DIO11_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO11_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO11_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO10*/\nexport const GPIO_RIS_DIO10: any = '1'\nexport const GPIO_RIS_DIO10_M: any = '1'\nexport const GPIO_RIS_DIO10_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO10_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO10_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO9*/\nexport const GPIO_RIS_DIO9: any = '1'\nexport const GPIO_RIS_DIO9_M: any = '1'\nexport const GPIO_RIS_DIO9_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO9_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO9_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO8*/\nexport const GPIO_RIS_DIO8: any = '1'\nexport const GPIO_RIS_DIO8_M: any = '1'\nexport const GPIO_RIS_DIO8_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO8_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO8_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO7*/\nexport const GPIO_RIS_DIO7: any = '1'\nexport const GPIO_RIS_DIO7_M: any = '1'\nexport const GPIO_RIS_DIO7_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO7_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO7_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO6*/\nexport const GPIO_RIS_DIO6: any = '1'\nexport const GPIO_RIS_DIO6_M: any = '1'\nexport const GPIO_RIS_DIO6_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO6_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO6_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO5*/\nexport const GPIO_RIS_DIO5: any = '1'\nexport const GPIO_RIS_DIO5_M: any = '1'\nexport const GPIO_RIS_DIO5_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO5_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO5_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO4*/\nexport const GPIO_RIS_DIO4: any = '1'\nexport const GPIO_RIS_DIO4_M: any = '1'\nexport const GPIO_RIS_DIO4_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO4_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO4_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO3*/\nexport const GPIO_RIS_DIO3: any = '1'\nexport const GPIO_RIS_DIO3_M: any = '1'\nexport const GPIO_RIS_DIO3_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO3_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO3_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO2*/\nexport const GPIO_RIS_DIO2: any = '1'\nexport const GPIO_RIS_DIO2_M: any = '1'\nexport const GPIO_RIS_DIO2_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO2_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO2_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO1*/\nexport const GPIO_RIS_DIO1: any = '1'\nexport const GPIO_RIS_DIO1_M: any = '1'\nexport const GPIO_RIS_DIO1_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO1_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO1_CLR: any = '0'\n\n/**\nRaw interrupt flag for DIO0*/\nexport const GPIO_RIS_DIO0: any = '1'\nexport const GPIO_RIS_DIO0_M: any = '1'\nexport const GPIO_RIS_DIO0_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_RIS_DIO0_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_RIS_DIO0_CLR: any = '0'\n\n\n// -------- REGISTER MIS -------- //\n\n/**\nMasked interrupt flag for DIO pins*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_MIS_RESERVED26: any = '6'\nexport const GPIO_MIS_RESERVED26_M: any = '6'\nexport const GPIO_MIS_RESERVED26_S: any = '6'\n/**\nMasked interrupt flag for DIO25*/\nexport const GPIO_MIS_DIO25: any = '1'\nexport const GPIO_MIS_DIO25_M: any = '1'\nexport const GPIO_MIS_DIO25_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO25_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO25_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO24*/\nexport const GPIO_MIS_DIO24: any = '1'\nexport const GPIO_MIS_DIO24_M: any = '1'\nexport const GPIO_MIS_DIO24_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO24_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO24_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO23*/\nexport const GPIO_MIS_DIO23: any = '1'\nexport const GPIO_MIS_DIO23_M: any = '1'\nexport const GPIO_MIS_DIO23_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO23_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO23_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO22*/\nexport const GPIO_MIS_DIO22: any = '1'\nexport const GPIO_MIS_DIO22_M: any = '1'\nexport const GPIO_MIS_DIO22_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO22_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO22_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO21*/\nexport const GPIO_MIS_DIO21: any = '1'\nexport const GPIO_MIS_DIO21_M: any = '1'\nexport const GPIO_MIS_DIO21_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO21_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO21_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO20*/\nexport const GPIO_MIS_DIO20: any = '1'\nexport const GPIO_MIS_DIO20_M: any = '1'\nexport const GPIO_MIS_DIO20_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO20_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO20_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO19*/\nexport const GPIO_MIS_DIO19: any = '1'\nexport const GPIO_MIS_DIO19_M: any = '1'\nexport const GPIO_MIS_DIO19_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO19_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO19_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO18*/\nexport const GPIO_MIS_DIO18: any = '1'\nexport const GPIO_MIS_DIO18_M: any = '1'\nexport const GPIO_MIS_DIO18_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO18_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO18_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO17*/\nexport const GPIO_MIS_DIO17: any = '1'\nexport const GPIO_MIS_DIO17_M: any = '1'\nexport const GPIO_MIS_DIO17_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO17_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO17_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO16*/\nexport const GPIO_MIS_DIO16: any = '1'\nexport const GPIO_MIS_DIO16_M: any = '1'\nexport const GPIO_MIS_DIO16_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO16_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO16_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO15*/\nexport const GPIO_MIS_DIO15: any = '1'\nexport const GPIO_MIS_DIO15_M: any = '1'\nexport const GPIO_MIS_DIO15_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO15_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO15_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO14*/\nexport const GPIO_MIS_DIO14: any = '1'\nexport const GPIO_MIS_DIO14_M: any = '1'\nexport const GPIO_MIS_DIO14_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO14_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO14_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO13*/\nexport const GPIO_MIS_DIO13: any = '1'\nexport const GPIO_MIS_DIO13_M: any = '1'\nexport const GPIO_MIS_DIO13_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO13_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO13_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO12*/\nexport const GPIO_MIS_DIO12: any = '1'\nexport const GPIO_MIS_DIO12_M: any = '1'\nexport const GPIO_MIS_DIO12_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO12_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO12_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO11*/\nexport const GPIO_MIS_DIO11: any = '1'\nexport const GPIO_MIS_DIO11_M: any = '1'\nexport const GPIO_MIS_DIO11_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO11_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO11_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO10*/\nexport const GPIO_MIS_DIO10: any = '1'\nexport const GPIO_MIS_DIO10_M: any = '1'\nexport const GPIO_MIS_DIO10_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO10_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO10_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO9*/\nexport const GPIO_MIS_DIO9: any = '1'\nexport const GPIO_MIS_DIO9_M: any = '1'\nexport const GPIO_MIS_DIO9_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO9_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO9_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO8*/\nexport const GPIO_MIS_DIO8: any = '1'\nexport const GPIO_MIS_DIO8_M: any = '1'\nexport const GPIO_MIS_DIO8_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO8_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO8_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO7*/\nexport const GPIO_MIS_DIO7: any = '1'\nexport const GPIO_MIS_DIO7_M: any = '1'\nexport const GPIO_MIS_DIO7_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO7_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO7_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO6*/\nexport const GPIO_MIS_DIO6: any = '1'\nexport const GPIO_MIS_DIO6_M: any = '1'\nexport const GPIO_MIS_DIO6_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO6_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO6_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO5*/\nexport const GPIO_MIS_DIO5: any = '1'\nexport const GPIO_MIS_DIO5_M: any = '1'\nexport const GPIO_MIS_DIO5_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO5_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO5_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO4*/\nexport const GPIO_MIS_DIO4: any = '1'\nexport const GPIO_MIS_DIO4_M: any = '1'\nexport const GPIO_MIS_DIO4_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO4_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO4_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO3*/\nexport const GPIO_MIS_DIO3: any = '1'\nexport const GPIO_MIS_DIO3_M: any = '1'\nexport const GPIO_MIS_DIO3_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO3_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO3_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO2*/\nexport const GPIO_MIS_DIO2: any = '1'\nexport const GPIO_MIS_DIO2_M: any = '1'\nexport const GPIO_MIS_DIO2_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO2_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO2_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO1*/\nexport const GPIO_MIS_DIO1: any = '1'\nexport const GPIO_MIS_DIO1_M: any = '1'\nexport const GPIO_MIS_DIO1_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO1_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO1_CLR: any = '0'\n\n/**\nMasked interrupt flag for DIO0*/\nexport const GPIO_MIS_DIO0: any = '1'\nexport const GPIO_MIS_DIO0_M: any = '1'\nexport const GPIO_MIS_DIO0_S: any = '1'\n/**\nInterrupt occured*/\nexport const GPIO_MIS_DIO0_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const GPIO_MIS_DIO0_CLR: any = '0'\n\n\n// -------- REGISTER ISET -------- //\n\n/**\nSet interrupt flag in RIS by writing a one*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_ISET_RESERVED26: any = '6'\nexport const GPIO_ISET_RESERVED26_M: any = '6'\nexport const GPIO_ISET_RESERVED26_S: any = '6'\n/**\nSet DIO25 in RIS*/\nexport const GPIO_ISET_DIO25: any = '1'\nexport const GPIO_ISET_DIO25_M: any = '1'\nexport const GPIO_ISET_DIO25_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO25_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO25_NOEFF: any = '0'\n\n/**\nSet DIO24 in RIS*/\nexport const GPIO_ISET_DIO24: any = '1'\nexport const GPIO_ISET_DIO24_M: any = '1'\nexport const GPIO_ISET_DIO24_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO24_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO24_NOEFF: any = '0'\n\n/**\nSet DIO23 in RIS*/\nexport const GPIO_ISET_DIO23: any = '1'\nexport const GPIO_ISET_DIO23_M: any = '1'\nexport const GPIO_ISET_DIO23_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO23_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO23_NOEFF: any = '0'\n\n/**\nSet DIO22 in RIS*/\nexport const GPIO_ISET_DIO22: any = '1'\nexport const GPIO_ISET_DIO22_M: any = '1'\nexport const GPIO_ISET_DIO22_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO22_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO22_NOEFF: any = '0'\n\n/**\nSet DIO21 in RIS*/\nexport const GPIO_ISET_DIO21: any = '1'\nexport const GPIO_ISET_DIO21_M: any = '1'\nexport const GPIO_ISET_DIO21_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO21_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO21_NOEFF: any = '0'\n\n/**\nSet DIO20 in RIS*/\nexport const GPIO_ISET_DIO20: any = '1'\nexport const GPIO_ISET_DIO20_M: any = '1'\nexport const GPIO_ISET_DIO20_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO20_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO20_NOEFF: any = '0'\n\n/**\nSet DIO19 in RIS*/\nexport const GPIO_ISET_DIO19: any = '1'\nexport const GPIO_ISET_DIO19_M: any = '1'\nexport const GPIO_ISET_DIO19_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO19_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO19_NOEFF: any = '0'\n\n/**\nSet DIO18 in RIS*/\nexport const GPIO_ISET_DIO18: any = '1'\nexport const GPIO_ISET_DIO18_M: any = '1'\nexport const GPIO_ISET_DIO18_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO18_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO18_NOEFF: any = '0'\n\n/**\nSet DIO17 in RIS*/\nexport const GPIO_ISET_DIO17: any = '1'\nexport const GPIO_ISET_DIO17_M: any = '1'\nexport const GPIO_ISET_DIO17_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO17_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO17_NOEFF: any = '0'\n\n/**\nSet DIO16 in RIS*/\nexport const GPIO_ISET_DIO16: any = '1'\nexport const GPIO_ISET_DIO16_M: any = '1'\nexport const GPIO_ISET_DIO16_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO16_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO16_NOEFF: any = '0'\n\n/**\nSet DIO15 in RIS*/\nexport const GPIO_ISET_DIO15: any = '1'\nexport const GPIO_ISET_DIO15_M: any = '1'\nexport const GPIO_ISET_DIO15_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO15_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO15_NOEFF: any = '0'\n\n/**\nSet DIO14 in RIS*/\nexport const GPIO_ISET_DIO14: any = '1'\nexport const GPIO_ISET_DIO14_M: any = '1'\nexport const GPIO_ISET_DIO14_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO14_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO14_NOEFF: any = '0'\n\n/**\nSet DIO13 in RIS*/\nexport const GPIO_ISET_DIO13: any = '1'\nexport const GPIO_ISET_DIO13_M: any = '1'\nexport const GPIO_ISET_DIO13_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO13_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO13_NOEFF: any = '0'\n\n/**\nSet DIO12 in RIS*/\nexport const GPIO_ISET_DIO12: any = '1'\nexport const GPIO_ISET_DIO12_M: any = '1'\nexport const GPIO_ISET_DIO12_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO12_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO12_NOEFF: any = '0'\n\n/**\nSet DIO11 in RIS*/\nexport const GPIO_ISET_DIO11: any = '1'\nexport const GPIO_ISET_DIO11_M: any = '1'\nexport const GPIO_ISET_DIO11_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO11_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO11_NOEFF: any = '0'\n\n/**\nSet DIO10 in RIS*/\nexport const GPIO_ISET_DIO10: any = '1'\nexport const GPIO_ISET_DIO10_M: any = '1'\nexport const GPIO_ISET_DIO10_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO10_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO10_NOEFF: any = '0'\n\n/**\nSet DIO9 in RIS*/\nexport const GPIO_ISET_DIO9: any = '1'\nexport const GPIO_ISET_DIO9_M: any = '1'\nexport const GPIO_ISET_DIO9_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO9_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO9_NOEFF: any = '0'\n\n/**\nSet DIO8 in RIS*/\nexport const GPIO_ISET_DIO8: any = '1'\nexport const GPIO_ISET_DIO8_M: any = '1'\nexport const GPIO_ISET_DIO8_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO8_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO8_NOEFF: any = '0'\n\n/**\nSet DIO7 in RIS*/\nexport const GPIO_ISET_DIO7: any = '1'\nexport const GPIO_ISET_DIO7_M: any = '1'\nexport const GPIO_ISET_DIO7_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO7_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO7_NOEFF: any = '0'\n\n/**\nSet DIO6 in RIS*/\nexport const GPIO_ISET_DIO6: any = '1'\nexport const GPIO_ISET_DIO6_M: any = '1'\nexport const GPIO_ISET_DIO6_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO6_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO6_NOEFF: any = '0'\n\n/**\nSet DIO5 in RIS*/\nexport const GPIO_ISET_DIO5: any = '1'\nexport const GPIO_ISET_DIO5_M: any = '1'\nexport const GPIO_ISET_DIO5_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO5_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO5_NOEFF: any = '0'\n\n/**\nSet DIO4 in RIS*/\nexport const GPIO_ISET_DIO4: any = '1'\nexport const GPIO_ISET_DIO4_M: any = '1'\nexport const GPIO_ISET_DIO4_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO4_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO4_NOEFF: any = '0'\n\n/**\nSet DIO3 in RIS*/\nexport const GPIO_ISET_DIO3: any = '1'\nexport const GPIO_ISET_DIO3_M: any = '1'\nexport const GPIO_ISET_DIO3_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO3_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO3_NOEFF: any = '0'\n\n/**\nSet DIO2 in RIS*/\nexport const GPIO_ISET_DIO2: any = '1'\nexport const GPIO_ISET_DIO2_M: any = '1'\nexport const GPIO_ISET_DIO2_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO2_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO2_NOEFF: any = '0'\n\n/**\nSet DIO1 in RIS*/\nexport const GPIO_ISET_DIO1: any = '1'\nexport const GPIO_ISET_DIO1_M: any = '1'\nexport const GPIO_ISET_DIO1_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO1_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO1_NOEFF: any = '0'\n\n/**\nSet DIO0 in RIS*/\nexport const GPIO_ISET_DIO0: any = '1'\nexport const GPIO_ISET_DIO0_M: any = '1'\nexport const GPIO_ISET_DIO0_S: any = '1'\n/**\nSet Interrupt*/\nexport const GPIO_ISET_DIO0_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ISET_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER ICLR -------- //\n\n/**\nClear interrupt flag in RIS by writing a one*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_ICLR_RESERVED26: any = '6'\nexport const GPIO_ICLR_RESERVED26_M: any = '6'\nexport const GPIO_ICLR_RESERVED26_S: any = '6'\n/**\nClears DIO25 in RIS*/\nexport const GPIO_ICLR_DIO25: any = '1'\nexport const GPIO_ICLR_DIO25_M: any = '1'\nexport const GPIO_ICLR_DIO25_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO25_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO25_NOEFF: any = '0'\n\n/**\nClears DIO24 in RIS*/\nexport const GPIO_ICLR_DIO24: any = '1'\nexport const GPIO_ICLR_DIO24_M: any = '1'\nexport const GPIO_ICLR_DIO24_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO24_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO24_NOEFF: any = '0'\n\n/**\nClears DIO23 in RIS*/\nexport const GPIO_ICLR_DIO23: any = '1'\nexport const GPIO_ICLR_DIO23_M: any = '1'\nexport const GPIO_ICLR_DIO23_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO23_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO23_NOEFF: any = '0'\n\n/**\nClears DIO22 in RIS*/\nexport const GPIO_ICLR_DIO22: any = '1'\nexport const GPIO_ICLR_DIO22_M: any = '1'\nexport const GPIO_ICLR_DIO22_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO22_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO22_NOEFF: any = '0'\n\n/**\nClears DIO21 in RIS*/\nexport const GPIO_ICLR_DIO21: any = '1'\nexport const GPIO_ICLR_DIO21_M: any = '1'\nexport const GPIO_ICLR_DIO21_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO21_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO21_NOEFF: any = '0'\n\n/**\nClears DIO20 in RIS*/\nexport const GPIO_ICLR_DIO20: any = '1'\nexport const GPIO_ICLR_DIO20_M: any = '1'\nexport const GPIO_ICLR_DIO20_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO20_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO20_NOEFF: any = '0'\n\n/**\nClears DIO19 in RIS*/\nexport const GPIO_ICLR_DIO19: any = '1'\nexport const GPIO_ICLR_DIO19_M: any = '1'\nexport const GPIO_ICLR_DIO19_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO19_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO19_NOEFF: any = '0'\n\n/**\nClears DIO18 in RIS*/\nexport const GPIO_ICLR_DIO18: any = '1'\nexport const GPIO_ICLR_DIO18_M: any = '1'\nexport const GPIO_ICLR_DIO18_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO18_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO18_NOEFF: any = '0'\n\n/**\nClears DIO17 in RIS*/\nexport const GPIO_ICLR_DIO17: any = '1'\nexport const GPIO_ICLR_DIO17_M: any = '1'\nexport const GPIO_ICLR_DIO17_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO17_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO17_NOEFF: any = '0'\n\n/**\nClears DIO16 in RIS*/\nexport const GPIO_ICLR_DIO16: any = '1'\nexport const GPIO_ICLR_DIO16_M: any = '1'\nexport const GPIO_ICLR_DIO16_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO16_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO16_NOEFF: any = '0'\n\n/**\nClears DIO15 in RIS*/\nexport const GPIO_ICLR_DIO15: any = '1'\nexport const GPIO_ICLR_DIO15_M: any = '1'\nexport const GPIO_ICLR_DIO15_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO15_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO15_NOEFF: any = '0'\n\n/**\nClears DIO14 in RIS*/\nexport const GPIO_ICLR_DIO14: any = '1'\nexport const GPIO_ICLR_DIO14_M: any = '1'\nexport const GPIO_ICLR_DIO14_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO14_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO14_NOEFF: any = '0'\n\n/**\nClears DIO13 in RIS*/\nexport const GPIO_ICLR_DIO13: any = '1'\nexport const GPIO_ICLR_DIO13_M: any = '1'\nexport const GPIO_ICLR_DIO13_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO13_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO13_NOEFF: any = '0'\n\n/**\nClears DIO12 in RIS*/\nexport const GPIO_ICLR_DIO12: any = '1'\nexport const GPIO_ICLR_DIO12_M: any = '1'\nexport const GPIO_ICLR_DIO12_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO12_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO12_NOEFF: any = '0'\n\n/**\nClears DIO11 in RIS*/\nexport const GPIO_ICLR_DIO11: any = '1'\nexport const GPIO_ICLR_DIO11_M: any = '1'\nexport const GPIO_ICLR_DIO11_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO11_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO11_NOEFF: any = '0'\n\n/**\nClears DIO10 in RIS*/\nexport const GPIO_ICLR_DIO10: any = '1'\nexport const GPIO_ICLR_DIO10_M: any = '1'\nexport const GPIO_ICLR_DIO10_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO10_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO10_NOEFF: any = '0'\n\n/**\nClears DIO9 in RIS*/\nexport const GPIO_ICLR_DIO9: any = '1'\nexport const GPIO_ICLR_DIO9_M: any = '1'\nexport const GPIO_ICLR_DIO9_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO9_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO9_NOEFF: any = '0'\n\n/**\nClears DIO8 in RIS*/\nexport const GPIO_ICLR_DIO8: any = '1'\nexport const GPIO_ICLR_DIO8_M: any = '1'\nexport const GPIO_ICLR_DIO8_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO8_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO8_NOEFF: any = '0'\n\n/**\nClears DIO7 in RIS*/\nexport const GPIO_ICLR_DIO7: any = '1'\nexport const GPIO_ICLR_DIO7_M: any = '1'\nexport const GPIO_ICLR_DIO7_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO7_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO7_NOEFF: any = '0'\n\n/**\nClears DIO6 in RIS*/\nexport const GPIO_ICLR_DIO6: any = '1'\nexport const GPIO_ICLR_DIO6_M: any = '1'\nexport const GPIO_ICLR_DIO6_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO6_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO6_NOEFF: any = '0'\n\n/**\nClears DIO5 in RIS*/\nexport const GPIO_ICLR_DIO5: any = '1'\nexport const GPIO_ICLR_DIO5_M: any = '1'\nexport const GPIO_ICLR_DIO5_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO5_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO5_NOEFF: any = '0'\n\n/**\nClears DIO4 in RIS*/\nexport const GPIO_ICLR_DIO4: any = '1'\nexport const GPIO_ICLR_DIO4_M: any = '1'\nexport const GPIO_ICLR_DIO4_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO4_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO4_NOEFF: any = '0'\n\n/**\nClears DIO3 in RIS*/\nexport const GPIO_ICLR_DIO3: any = '1'\nexport const GPIO_ICLR_DIO3_M: any = '1'\nexport const GPIO_ICLR_DIO3_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO3_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO3_NOEFF: any = '0'\n\n/**\nClears DIO2 in RIS*/\nexport const GPIO_ICLR_DIO2: any = '1'\nexport const GPIO_ICLR_DIO2_M: any = '1'\nexport const GPIO_ICLR_DIO2_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO2_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO2_NOEFF: any = '0'\n\n/**\nClears DIO1 in RIS*/\nexport const GPIO_ICLR_DIO1: any = '1'\nexport const GPIO_ICLR_DIO1_M: any = '1'\nexport const GPIO_ICLR_DIO1_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO1_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO1_NOEFF: any = '0'\n\n/**\nClears DIO0 in RIS*/\nexport const GPIO_ICLR_DIO0: any = '1'\nexport const GPIO_ICLR_DIO0_M: any = '1'\nexport const GPIO_ICLR_DIO0_S: any = '1'\n/**\nClear Interrupt*/\nexport const GPIO_ICLR_DIO0_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_ICLR_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER IMSET -------- //\n\n/**\nSet interrupt mask in IMASK by writing a one*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_IMSET_RESERVED26: any = '6'\nexport const GPIO_IMSET_RESERVED26_M: any = '6'\nexport const GPIO_IMSET_RESERVED26_S: any = '6'\n/**\nSets DIO25 in IMASK*/\nexport const GPIO_IMSET_DIO25: any = '1'\nexport const GPIO_IMSET_DIO25_M: any = '1'\nexport const GPIO_IMSET_DIO25_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO25_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO25_NOEFF: any = '0'\n\n/**\nSets DIO24 in IMASK*/\nexport const GPIO_IMSET_DIO24: any = '1'\nexport const GPIO_IMSET_DIO24_M: any = '1'\nexport const GPIO_IMSET_DIO24_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO24_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO24_NOEFF: any = '0'\n\n/**\nSets DIO23 in IMASK*/\nexport const GPIO_IMSET_DIO23: any = '1'\nexport const GPIO_IMSET_DIO23_M: any = '1'\nexport const GPIO_IMSET_DIO23_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO23_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO23_NOEFF: any = '0'\n\n/**\nSets DIO22 in IMASK*/\nexport const GPIO_IMSET_DIO22: any = '1'\nexport const GPIO_IMSET_DIO22_M: any = '1'\nexport const GPIO_IMSET_DIO22_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO22_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO22_NOEFF: any = '0'\n\n/**\nSets DIO21 in IMASK*/\nexport const GPIO_IMSET_DIO21: any = '1'\nexport const GPIO_IMSET_DIO21_M: any = '1'\nexport const GPIO_IMSET_DIO21_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO21_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO21_NOEFF: any = '0'\n\n/**\nSets DIO20 in IMASK*/\nexport const GPIO_IMSET_DIO20: any = '1'\nexport const GPIO_IMSET_DIO20_M: any = '1'\nexport const GPIO_IMSET_DIO20_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO20_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO20_NOEFF: any = '0'\n\n/**\nSets DIO19 in IMASK*/\nexport const GPIO_IMSET_DIO19: any = '1'\nexport const GPIO_IMSET_DIO19_M: any = '1'\nexport const GPIO_IMSET_DIO19_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO19_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO19_NOEFF: any = '0'\n\n/**\nSets DIO18 in IMASK*/\nexport const GPIO_IMSET_DIO18: any = '1'\nexport const GPIO_IMSET_DIO18_M: any = '1'\nexport const GPIO_IMSET_DIO18_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO18_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO18_NOEFF: any = '0'\n\n/**\nSets DIO17 in IMASK*/\nexport const GPIO_IMSET_DIO17: any = '1'\nexport const GPIO_IMSET_DIO17_M: any = '1'\nexport const GPIO_IMSET_DIO17_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO17_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO17_NOEFF: any = '0'\n\n/**\nSets DIO16 in IMASK*/\nexport const GPIO_IMSET_DIO16: any = '1'\nexport const GPIO_IMSET_DIO16_M: any = '1'\nexport const GPIO_IMSET_DIO16_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO16_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO16_NOEFF: any = '0'\n\n/**\nSets DIO15 in IMASK*/\nexport const GPIO_IMSET_DIO15: any = '1'\nexport const GPIO_IMSET_DIO15_M: any = '1'\nexport const GPIO_IMSET_DIO15_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO15_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO15_NOEFF: any = '0'\n\n/**\nSets DIO14 in IMASK*/\nexport const GPIO_IMSET_DIO14: any = '1'\nexport const GPIO_IMSET_DIO14_M: any = '1'\nexport const GPIO_IMSET_DIO14_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO14_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO14_NOEFF: any = '0'\n\n/**\nSets DIO13 in IMASK*/\nexport const GPIO_IMSET_DIO13: any = '1'\nexport const GPIO_IMSET_DIO13_M: any = '1'\nexport const GPIO_IMSET_DIO13_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO13_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO13_NOEFF: any = '0'\n\n/**\nSets DIO12 in IMASK*/\nexport const GPIO_IMSET_DIO12: any = '1'\nexport const GPIO_IMSET_DIO12_M: any = '1'\nexport const GPIO_IMSET_DIO12_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO12_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO12_NOEFF: any = '0'\n\n/**\nSets DIO11 in IMASK*/\nexport const GPIO_IMSET_DIO11: any = '1'\nexport const GPIO_IMSET_DIO11_M: any = '1'\nexport const GPIO_IMSET_DIO11_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO11_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO11_NOEFF: any = '0'\n\n/**\nSets DIO10 in IMASK*/\nexport const GPIO_IMSET_DIO10: any = '1'\nexport const GPIO_IMSET_DIO10_M: any = '1'\nexport const GPIO_IMSET_DIO10_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO10_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO10_NOEFF: any = '0'\n\n/**\nSets DIO9 in IMASK*/\nexport const GPIO_IMSET_DIO9: any = '1'\nexport const GPIO_IMSET_DIO9_M: any = '1'\nexport const GPIO_IMSET_DIO9_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO9_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO9_NOEFF: any = '0'\n\n/**\nSets DIO8 in IMASK*/\nexport const GPIO_IMSET_DIO8: any = '1'\nexport const GPIO_IMSET_DIO8_M: any = '1'\nexport const GPIO_IMSET_DIO8_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO8_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO8_NOEFF: any = '0'\n\n/**\nSets DIO7 in IMASK*/\nexport const GPIO_IMSET_DIO7: any = '1'\nexport const GPIO_IMSET_DIO7_M: any = '1'\nexport const GPIO_IMSET_DIO7_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO7_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO7_NOEFF: any = '0'\n\n/**\nSets DIO6 in IMASK*/\nexport const GPIO_IMSET_DIO6: any = '1'\nexport const GPIO_IMSET_DIO6_M: any = '1'\nexport const GPIO_IMSET_DIO6_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO6_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO6_NOEFF: any = '0'\n\n/**\nSets DIO5 in IMASK*/\nexport const GPIO_IMSET_DIO5: any = '1'\nexport const GPIO_IMSET_DIO5_M: any = '1'\nexport const GPIO_IMSET_DIO5_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO5_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO5_NOEFF: any = '0'\n\n/**\nSets DIO4 in IMASK*/\nexport const GPIO_IMSET_DIO4: any = '1'\nexport const GPIO_IMSET_DIO4_M: any = '1'\nexport const GPIO_IMSET_DIO4_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO4_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO4_NOEFF: any = '0'\n\n/**\nSets DIO3 in IMASK*/\nexport const GPIO_IMSET_DIO3: any = '1'\nexport const GPIO_IMSET_DIO3_M: any = '1'\nexport const GPIO_IMSET_DIO3_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO3_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO3_NOEFF: any = '0'\n\n/**\nSets DIO2 in IMASK*/\nexport const GPIO_IMSET_DIO2: any = '1'\nexport const GPIO_IMSET_DIO2_M: any = '1'\nexport const GPIO_IMSET_DIO2_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO2_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO2_NOEFF: any = '0'\n\n/**\nSets DIO1 in IMASK*/\nexport const GPIO_IMSET_DIO1: any = '1'\nexport const GPIO_IMSET_DIO1_M: any = '1'\nexport const GPIO_IMSET_DIO1_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO1_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO1_NOEFF: any = '0'\n\n/**\nSets DIO0 in IMASK*/\nexport const GPIO_IMSET_DIO0: any = '1'\nexport const GPIO_IMSET_DIO0_M: any = '1'\nexport const GPIO_IMSET_DIO0_S: any = '1'\n/**\nSet interrupt mask*/\nexport const GPIO_IMSET_DIO0_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMSET_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER IMCLR -------- //\n\n/**\nClear interrupt mask in IMASK by writing a one*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_IMCLR_RESERVED26: any = '6'\nexport const GPIO_IMCLR_RESERVED26_M: any = '6'\nexport const GPIO_IMCLR_RESERVED26_S: any = '6'\n/**\nClears DIO25 in IMASK*/\nexport const GPIO_IMCLR_DIO25: any = '1'\nexport const GPIO_IMCLR_DIO25_M: any = '1'\nexport const GPIO_IMCLR_DIO25_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO25_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO25_NOEFF: any = '0'\n\n/**\nClears DIO24 in IMASK*/\nexport const GPIO_IMCLR_DIO24: any = '1'\nexport const GPIO_IMCLR_DIO24_M: any = '1'\nexport const GPIO_IMCLR_DIO24_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO24_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO24_NOEFF: any = '0'\n\n/**\nClears DIO23 in IMASK*/\nexport const GPIO_IMCLR_DIO23: any = '1'\nexport const GPIO_IMCLR_DIO23_M: any = '1'\nexport const GPIO_IMCLR_DIO23_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO23_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO23_NOEFF: any = '0'\n\n/**\nClears DIO22 in IMASK*/\nexport const GPIO_IMCLR_DIO22: any = '1'\nexport const GPIO_IMCLR_DIO22_M: any = '1'\nexport const GPIO_IMCLR_DIO22_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO22_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO22_NOEFF: any = '0'\n\n/**\nClears DIO21 in IMASK*/\nexport const GPIO_IMCLR_DIO21: any = '1'\nexport const GPIO_IMCLR_DIO21_M: any = '1'\nexport const GPIO_IMCLR_DIO21_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO21_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO21_NOEFF: any = '0'\n\n/**\nClears DIO20 in IMASK*/\nexport const GPIO_IMCLR_DIO20: any = '1'\nexport const GPIO_IMCLR_DIO20_M: any = '1'\nexport const GPIO_IMCLR_DIO20_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO20_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO20_NOEFF: any = '0'\n\n/**\nClears DIO19 in IMASK*/\nexport const GPIO_IMCLR_DIO19: any = '1'\nexport const GPIO_IMCLR_DIO19_M: any = '1'\nexport const GPIO_IMCLR_DIO19_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO19_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO19_NOEFF: any = '0'\n\n/**\nClears DIO18 in IMASK*/\nexport const GPIO_IMCLR_DIO18: any = '1'\nexport const GPIO_IMCLR_DIO18_M: any = '1'\nexport const GPIO_IMCLR_DIO18_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO18_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO18_NOEFF: any = '0'\n\n/**\nClears DIO17 in IMASK*/\nexport const GPIO_IMCLR_DIO17: any = '1'\nexport const GPIO_IMCLR_DIO17_M: any = '1'\nexport const GPIO_IMCLR_DIO17_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO17_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO17_NOEFF: any = '0'\n\n/**\nClears DIO16 in IMASK*/\nexport const GPIO_IMCLR_DIO16: any = '1'\nexport const GPIO_IMCLR_DIO16_M: any = '1'\nexport const GPIO_IMCLR_DIO16_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO16_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO16_NOEFF: any = '0'\n\n/**\nClears DIO15 in IMASK*/\nexport const GPIO_IMCLR_DIO15: any = '1'\nexport const GPIO_IMCLR_DIO15_M: any = '1'\nexport const GPIO_IMCLR_DIO15_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO15_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO15_NOEFF: any = '0'\n\n/**\nClears DIO14 in IMASK*/\nexport const GPIO_IMCLR_DIO14: any = '1'\nexport const GPIO_IMCLR_DIO14_M: any = '1'\nexport const GPIO_IMCLR_DIO14_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO14_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO14_NOEFF: any = '0'\n\n/**\nClears DIO13 in IMASK*/\nexport const GPIO_IMCLR_DIO13: any = '1'\nexport const GPIO_IMCLR_DIO13_M: any = '1'\nexport const GPIO_IMCLR_DIO13_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO13_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO13_NOEFF: any = '0'\n\n/**\nClears DIO12 in IMASK*/\nexport const GPIO_IMCLR_DIO12: any = '1'\nexport const GPIO_IMCLR_DIO12_M: any = '1'\nexport const GPIO_IMCLR_DIO12_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO12_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO12_NOEFF: any = '0'\n\n/**\nClears DIO11 in IMASK*/\nexport const GPIO_IMCLR_DIO11: any = '1'\nexport const GPIO_IMCLR_DIO11_M: any = '1'\nexport const GPIO_IMCLR_DIO11_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO11_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO11_NOEFF: any = '0'\n\n/**\nClears DIO10 in IMASK*/\nexport const GPIO_IMCLR_DIO10: any = '1'\nexport const GPIO_IMCLR_DIO10_M: any = '1'\nexport const GPIO_IMCLR_DIO10_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO10_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO10_NOEFF: any = '0'\n\n/**\nClears DIO9 in IMASK*/\nexport const GPIO_IMCLR_DIO9: any = '1'\nexport const GPIO_IMCLR_DIO9_M: any = '1'\nexport const GPIO_IMCLR_DIO9_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO9_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO9_NOEFF: any = '0'\n\n/**\nClears DIO8 in IMASK*/\nexport const GPIO_IMCLR_DIO8: any = '1'\nexport const GPIO_IMCLR_DIO8_M: any = '1'\nexport const GPIO_IMCLR_DIO8_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO8_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO8_NOEFF: any = '0'\n\n/**\nClears DIO7 in IMASK*/\nexport const GPIO_IMCLR_DIO7: any = '1'\nexport const GPIO_IMCLR_DIO7_M: any = '1'\nexport const GPIO_IMCLR_DIO7_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO7_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO7_NOEFF: any = '0'\n\n/**\nClears DIO6 in IMASK*/\nexport const GPIO_IMCLR_DIO6: any = '1'\nexport const GPIO_IMCLR_DIO6_M: any = '1'\nexport const GPIO_IMCLR_DIO6_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO6_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO6_NOEFF: any = '0'\n\n/**\nClears DIO5 in IMASK*/\nexport const GPIO_IMCLR_DIO5: any = '1'\nexport const GPIO_IMCLR_DIO5_M: any = '1'\nexport const GPIO_IMCLR_DIO5_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO5_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO5_NOEFF: any = '0'\n\n/**\nClears DIO4 in IMASK*/\nexport const GPIO_IMCLR_DIO4: any = '1'\nexport const GPIO_IMCLR_DIO4_M: any = '1'\nexport const GPIO_IMCLR_DIO4_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO4_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO4_NOEFF: any = '0'\n\n/**\nClears DIO3 in IMASK*/\nexport const GPIO_IMCLR_DIO3: any = '1'\nexport const GPIO_IMCLR_DIO3_M: any = '1'\nexport const GPIO_IMCLR_DIO3_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO3_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO3_NOEFF: any = '0'\n\n/**\nClears DIO2 in IMASK*/\nexport const GPIO_IMCLR_DIO2: any = '1'\nexport const GPIO_IMCLR_DIO2_M: any = '1'\nexport const GPIO_IMCLR_DIO2_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO2_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO2_NOEFF: any = '0'\n\n/**\nClears DIO1 in IMASK*/\nexport const GPIO_IMCLR_DIO1: any = '1'\nexport const GPIO_IMCLR_DIO1_M: any = '1'\nexport const GPIO_IMCLR_DIO1_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO1_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO1_NOEFF: any = '0'\n\n/**\nClears DIO0 in IMASK*/\nexport const GPIO_IMCLR_DIO0: any = '1'\nexport const GPIO_IMCLR_DIO0_M: any = '1'\nexport const GPIO_IMCLR_DIO0_S: any = '1'\n/**\nClear interrupt mask*/\nexport const GPIO_IMCLR_DIO0_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const GPIO_IMCLR_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER DOUT3_0 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[3:0] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT3_0_RESERVED25: any = '7'\nexport const GPIO_DOUT3_0_RESERVED25_M: any = '7'\nexport const GPIO_DOUT3_0_RESERVED25_S: any = '7'\n/**\nData output for DIO3*/\nexport const GPIO_DOUT3_0_DIO3: any = '1'\nexport const GPIO_DOUT3_0_DIO3_M: any = '1'\nexport const GPIO_DOUT3_0_DIO3_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT3_0_DIO3_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT3_0_DIO3_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT3_0_RESERVED17: any = '7'\nexport const GPIO_DOUT3_0_RESERVED17_M: any = '7'\nexport const GPIO_DOUT3_0_RESERVED17_S: any = '7'\n/**\nData output for DIO2*/\nexport const GPIO_DOUT3_0_DIO2: any = '1'\nexport const GPIO_DOUT3_0_DIO2_M: any = '1'\nexport const GPIO_DOUT3_0_DIO2_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT3_0_DIO2_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT3_0_DIO2_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT3_0_RESERVED9: any = '7'\nexport const GPIO_DOUT3_0_RESERVED9_M: any = '7'\nexport const GPIO_DOUT3_0_RESERVED9_S: any = '7'\n/**\nData output for DIO1*/\nexport const GPIO_DOUT3_0_DIO1: any = '1'\nexport const GPIO_DOUT3_0_DIO1_M: any = '1'\nexport const GPIO_DOUT3_0_DIO1_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT3_0_DIO1_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT3_0_DIO1_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT3_0_RESERVED1: any = '7'\nexport const GPIO_DOUT3_0_RESERVED1_M: any = '7'\nexport const GPIO_DOUT3_0_RESERVED1_S: any = '7'\n/**\nData output for DIO0*/\nexport const GPIO_DOUT3_0_DIO0: any = '1'\nexport const GPIO_DOUT3_0_DIO0_M: any = '1'\nexport const GPIO_DOUT3_0_DIO0_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT3_0_DIO0_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT3_0_DIO0_ZERO: any = '0'\n\n\n// -------- REGISTER DOUT7_4 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[7:4] bits*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT7_4_RESERVED25: any = '7'\nexport const GPIO_DOUT7_4_RESERVED25_M: any = '7'\nexport const GPIO_DOUT7_4_RESERVED25_S: any = '7'\n/**\nData output for DIO7*/\nexport const GPIO_DOUT7_4_DIO7: any = '1'\nexport const GPIO_DOUT7_4_DIO7_M: any = '1'\nexport const GPIO_DOUT7_4_DIO7_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT7_4_DIO7_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT7_4_DIO7_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT7_4_RESERVED17: any = '7'\nexport const GPIO_DOUT7_4_RESERVED17_M: any = '7'\nexport const GPIO_DOUT7_4_RESERVED17_S: any = '7'\n/**\nData output for DIO6*/\nexport const GPIO_DOUT7_4_DIO6: any = '1'\nexport const GPIO_DOUT7_4_DIO6_M: any = '1'\nexport const GPIO_DOUT7_4_DIO6_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT7_4_DIO6_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT7_4_DIO6_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT7_4_RESERVED9: any = '7'\nexport const GPIO_DOUT7_4_RESERVED9_M: any = '7'\nexport const GPIO_DOUT7_4_RESERVED9_S: any = '7'\n/**\nData output for DIO5*/\nexport const GPIO_DOUT7_4_DIO5: any = '1'\nexport const GPIO_DOUT7_4_DIO5_M: any = '1'\nexport const GPIO_DOUT7_4_DIO5_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT7_4_DIO5_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT7_4_DIO5_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT7_4_RESERVED1: any = '7'\nexport const GPIO_DOUT7_4_RESERVED1_M: any = '7'\nexport const GPIO_DOUT7_4_RESERVED1_S: any = '7'\n/**\nData output for DIO4*/\nexport const GPIO_DOUT7_4_DIO4: any = '1'\nexport const GPIO_DOUT7_4_DIO4_M: any = '1'\nexport const GPIO_DOUT7_4_DIO4_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT7_4_DIO4_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT7_4_DIO4_ZERO: any = '0'\n\n\n// -------- REGISTER DOUT11_8 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[11:8] bits*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT11_8_RESERVED25: any = '7'\nexport const GPIO_DOUT11_8_RESERVED25_M: any = '7'\nexport const GPIO_DOUT11_8_RESERVED25_S: any = '7'\n/**\nData output for DIO11*/\nexport const GPIO_DOUT11_8_DIO11: any = '1'\nexport const GPIO_DOUT11_8_DIO11_M: any = '1'\nexport const GPIO_DOUT11_8_DIO11_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT11_8_DIO11_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT11_8_DIO11_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT11_8_RESERVED17: any = '7'\nexport const GPIO_DOUT11_8_RESERVED17_M: any = '7'\nexport const GPIO_DOUT11_8_RESERVED17_S: any = '7'\n/**\nData output for DIO10*/\nexport const GPIO_DOUT11_8_DIO10: any = '1'\nexport const GPIO_DOUT11_8_DIO10_M: any = '1'\nexport const GPIO_DOUT11_8_DIO10_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT11_8_DIO10_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT11_8_DIO10_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT11_8_RESERVED9: any = '7'\nexport const GPIO_DOUT11_8_RESERVED9_M: any = '7'\nexport const GPIO_DOUT11_8_RESERVED9_S: any = '7'\n/**\nData output for DIO9*/\nexport const GPIO_DOUT11_8_DIO9: any = '1'\nexport const GPIO_DOUT11_8_DIO9_M: any = '1'\nexport const GPIO_DOUT11_8_DIO9_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT11_8_DIO9_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT11_8_DIO9_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT11_8_RESERVED1: any = '7'\nexport const GPIO_DOUT11_8_RESERVED1_M: any = '7'\nexport const GPIO_DOUT11_8_RESERVED1_S: any = '7'\n/**\nData output for DIO8*/\nexport const GPIO_DOUT11_8_DIO8: any = '1'\nexport const GPIO_DOUT11_8_DIO8_M: any = '1'\nexport const GPIO_DOUT11_8_DIO8_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT11_8_DIO8_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT11_8_DIO8_ZERO: any = '0'\n\n\n// -------- REGISTER DOUT15_12 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[15:12] bits*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT15_12_RESERVED25: any = '7'\nexport const GPIO_DOUT15_12_RESERVED25_M: any = '7'\nexport const GPIO_DOUT15_12_RESERVED25_S: any = '7'\n/**\nData output for DIO15*/\nexport const GPIO_DOUT15_12_DIO15: any = '1'\nexport const GPIO_DOUT15_12_DIO15_M: any = '1'\nexport const GPIO_DOUT15_12_DIO15_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT15_12_DIO15_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT15_12_DIO15_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT15_12_RESERVED17: any = '7'\nexport const GPIO_DOUT15_12_RESERVED17_M: any = '7'\nexport const GPIO_DOUT15_12_RESERVED17_S: any = '7'\n/**\nData output for DIO14*/\nexport const GPIO_DOUT15_12_DIO14: any = '1'\nexport const GPIO_DOUT15_12_DIO14_M: any = '1'\nexport const GPIO_DOUT15_12_DIO14_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT15_12_DIO14_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT15_12_DIO14_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT15_12_RESERVED9: any = '7'\nexport const GPIO_DOUT15_12_RESERVED9_M: any = '7'\nexport const GPIO_DOUT15_12_RESERVED9_S: any = '7'\n/**\nData output for DIO13*/\nexport const GPIO_DOUT15_12_DIO13: any = '1'\nexport const GPIO_DOUT15_12_DIO13_M: any = '1'\nexport const GPIO_DOUT15_12_DIO13_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT15_12_DIO13_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT15_12_DIO13_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT15_12_RESERVED1: any = '7'\nexport const GPIO_DOUT15_12_RESERVED1_M: any = '7'\nexport const GPIO_DOUT15_12_RESERVED1_S: any = '7'\n/**\nData output for DIO12*/\nexport const GPIO_DOUT15_12_DIO12: any = '1'\nexport const GPIO_DOUT15_12_DIO12_M: any = '1'\nexport const GPIO_DOUT15_12_DIO12_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT15_12_DIO12_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT15_12_DIO12_ZERO: any = '0'\n\n\n// -------- REGISTER DOUT19_16 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[19:16] bits*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT19_16_RESERVED25: any = '7'\nexport const GPIO_DOUT19_16_RESERVED25_M: any = '7'\nexport const GPIO_DOUT19_16_RESERVED25_S: any = '7'\n/**\nData output for DIO19*/\nexport const GPIO_DOUT19_16_DIO19: any = '1'\nexport const GPIO_DOUT19_16_DIO19_M: any = '1'\nexport const GPIO_DOUT19_16_DIO19_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT19_16_DIO19_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT19_16_DIO19_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT19_16_RESERVED17: any = '7'\nexport const GPIO_DOUT19_16_RESERVED17_M: any = '7'\nexport const GPIO_DOUT19_16_RESERVED17_S: any = '7'\n/**\nData output for DIO18*/\nexport const GPIO_DOUT19_16_DIO18: any = '1'\nexport const GPIO_DOUT19_16_DIO18_M: any = '1'\nexport const GPIO_DOUT19_16_DIO18_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT19_16_DIO18_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT19_16_DIO18_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT19_16_RESERVED9: any = '7'\nexport const GPIO_DOUT19_16_RESERVED9_M: any = '7'\nexport const GPIO_DOUT19_16_RESERVED9_S: any = '7'\n/**\nData output for DIO17*/\nexport const GPIO_DOUT19_16_DIO17: any = '1'\nexport const GPIO_DOUT19_16_DIO17_M: any = '1'\nexport const GPIO_DOUT19_16_DIO17_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT19_16_DIO17_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT19_16_DIO17_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT19_16_RESERVED1: any = '7'\nexport const GPIO_DOUT19_16_RESERVED1_M: any = '7'\nexport const GPIO_DOUT19_16_RESERVED1_S: any = '7'\n/**\nData output for DIO16*/\nexport const GPIO_DOUT19_16_DIO16: any = '1'\nexport const GPIO_DOUT19_16_DIO16_M: any = '1'\nexport const GPIO_DOUT19_16_DIO16_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT19_16_DIO16_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT19_16_DIO16_ZERO: any = '0'\n\n\n// -------- REGISTER DOUT23_20 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[23:20] bits*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT23_20_RESERVED25: any = '7'\nexport const GPIO_DOUT23_20_RESERVED25_M: any = '7'\nexport const GPIO_DOUT23_20_RESERVED25_S: any = '7'\n/**\nData output for DIO23*/\nexport const GPIO_DOUT23_20_DIO23: any = '1'\nexport const GPIO_DOUT23_20_DIO23_M: any = '1'\nexport const GPIO_DOUT23_20_DIO23_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT23_20_DIO23_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT23_20_DIO23_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT23_20_RESERVED17: any = '7'\nexport const GPIO_DOUT23_20_RESERVED17_M: any = '7'\nexport const GPIO_DOUT23_20_RESERVED17_S: any = '7'\n/**\nData output for DIO22*/\nexport const GPIO_DOUT23_20_DIO22: any = '1'\nexport const GPIO_DOUT23_20_DIO22_M: any = '1'\nexport const GPIO_DOUT23_20_DIO22_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT23_20_DIO22_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT23_20_DIO22_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT23_20_RESERVED9: any = '7'\nexport const GPIO_DOUT23_20_RESERVED9_M: any = '7'\nexport const GPIO_DOUT23_20_RESERVED9_S: any = '7'\n/**\nData output for DIO21*/\nexport const GPIO_DOUT23_20_DIO21: any = '1'\nexport const GPIO_DOUT23_20_DIO21_M: any = '1'\nexport const GPIO_DOUT23_20_DIO21_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT23_20_DIO21_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT23_20_DIO21_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT23_20_RESERVED1: any = '7'\nexport const GPIO_DOUT23_20_RESERVED1_M: any = '7'\nexport const GPIO_DOUT23_20_RESERVED1_S: any = '7'\n/**\nData output for DIO20*/\nexport const GPIO_DOUT23_20_DIO20: any = '1'\nexport const GPIO_DOUT23_20_DIO20_M: any = '1'\nexport const GPIO_DOUT23_20_DIO20_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT23_20_DIO20_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT23_20_DIO20_ZERO: any = '0'\n\n\n// -------- REGISTER DOUT27_24 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[27:24] bits*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT27_24_RESERVED9: any = '23'\nexport const GPIO_DOUT27_24_RESERVED9_M: any = '23'\nexport const GPIO_DOUT27_24_RESERVED9_S: any = '23'\n/**\nData output for DIO25*/\nexport const GPIO_DOUT27_24_DIO25: any = '1'\nexport const GPIO_DOUT27_24_DIO25_M: any = '1'\nexport const GPIO_DOUT27_24_DIO25_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT27_24_DIO25_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT27_24_DIO25_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT27_24_RESERVED1: any = '7'\nexport const GPIO_DOUT27_24_RESERVED1_M: any = '7'\nexport const GPIO_DOUT27_24_RESERVED1_S: any = '7'\n/**\nData output for DIO24*/\nexport const GPIO_DOUT27_24_DIO24: any = '1'\nexport const GPIO_DOUT27_24_DIO24_M: any = '1'\nexport const GPIO_DOUT27_24_DIO24_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT27_24_DIO24_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT27_24_DIO24_ZERO: any = '0'\n\n\n// -------- REGISTER DOUT31_0 -------- //\n\n/**\nData Output for DIO 31 to 0 pins.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUT31_0_RESERVED26: any = '6'\nexport const GPIO_DOUT31_0_RESERVED26_M: any = '6'\nexport const GPIO_DOUT31_0_RESERVED26_S: any = '6'\n/**\nData output for DIO25*/\nexport const GPIO_DOUT31_0_DIO25: any = '1'\nexport const GPIO_DOUT31_0_DIO25_M: any = '1'\nexport const GPIO_DOUT31_0_DIO25_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO25_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO25_ZERO: any = '0'\n\n/**\nData output for DIO24*/\nexport const GPIO_DOUT31_0_DIO24: any = '1'\nexport const GPIO_DOUT31_0_DIO24_M: any = '1'\nexport const GPIO_DOUT31_0_DIO24_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO24_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO24_ZERO: any = '0'\n\n/**\nData output for DIO23*/\nexport const GPIO_DOUT31_0_DIO23: any = '1'\nexport const GPIO_DOUT31_0_DIO23_M: any = '1'\nexport const GPIO_DOUT31_0_DIO23_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO23_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO23_ZERO: any = '0'\n\n/**\nData output for DIO22*/\nexport const GPIO_DOUT31_0_DIO22: any = '1'\nexport const GPIO_DOUT31_0_DIO22_M: any = '1'\nexport const GPIO_DOUT31_0_DIO22_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO22_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO22_ZERO: any = '0'\n\n/**\nData output for DIO21*/\nexport const GPIO_DOUT31_0_DIO21: any = '1'\nexport const GPIO_DOUT31_0_DIO21_M: any = '1'\nexport const GPIO_DOUT31_0_DIO21_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO21_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO21_ZERO: any = '0'\n\n/**\nData output for DIO20*/\nexport const GPIO_DOUT31_0_DIO20: any = '1'\nexport const GPIO_DOUT31_0_DIO20_M: any = '1'\nexport const GPIO_DOUT31_0_DIO20_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO20_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO20_ZERO: any = '0'\n\n/**\nData output for DIO19*/\nexport const GPIO_DOUT31_0_DIO19: any = '1'\nexport const GPIO_DOUT31_0_DIO19_M: any = '1'\nexport const GPIO_DOUT31_0_DIO19_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO19_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO19_ZERO: any = '0'\n\n/**\nData output for DIO18*/\nexport const GPIO_DOUT31_0_DIO18: any = '1'\nexport const GPIO_DOUT31_0_DIO18_M: any = '1'\nexport const GPIO_DOUT31_0_DIO18_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO18_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO18_ZERO: any = '0'\n\n/**\nData output for DIO17*/\nexport const GPIO_DOUT31_0_DIO17: any = '1'\nexport const GPIO_DOUT31_0_DIO17_M: any = '1'\nexport const GPIO_DOUT31_0_DIO17_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO17_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO17_ZERO: any = '0'\n\n/**\nData output for DIO16*/\nexport const GPIO_DOUT31_0_DIO16: any = '1'\nexport const GPIO_DOUT31_0_DIO16_M: any = '1'\nexport const GPIO_DOUT31_0_DIO16_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO16_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO16_ZERO: any = '0'\n\n/**\nData output for DIO15*/\nexport const GPIO_DOUT31_0_DIO15: any = '1'\nexport const GPIO_DOUT31_0_DIO15_M: any = '1'\nexport const GPIO_DOUT31_0_DIO15_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO15_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO15_ZERO: any = '0'\n\n/**\nData output for DIO14*/\nexport const GPIO_DOUT31_0_DIO14: any = '1'\nexport const GPIO_DOUT31_0_DIO14_M: any = '1'\nexport const GPIO_DOUT31_0_DIO14_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO14_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO14_ZERO: any = '0'\n\n/**\nData output for DIO13*/\nexport const GPIO_DOUT31_0_DIO13: any = '1'\nexport const GPIO_DOUT31_0_DIO13_M: any = '1'\nexport const GPIO_DOUT31_0_DIO13_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO13_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO13_ZERO: any = '0'\n\n/**\nData output for DIO12*/\nexport const GPIO_DOUT31_0_DIO12: any = '1'\nexport const GPIO_DOUT31_0_DIO12_M: any = '1'\nexport const GPIO_DOUT31_0_DIO12_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO12_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO12_ZERO: any = '0'\n\n/**\nData output for DIO11*/\nexport const GPIO_DOUT31_0_DIO11: any = '1'\nexport const GPIO_DOUT31_0_DIO11_M: any = '1'\nexport const GPIO_DOUT31_0_DIO11_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO11_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO11_ZERO: any = '0'\n\n/**\nData output for DIO10*/\nexport const GPIO_DOUT31_0_DIO10: any = '1'\nexport const GPIO_DOUT31_0_DIO10_M: any = '1'\nexport const GPIO_DOUT31_0_DIO10_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO10_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO10_ZERO: any = '0'\n\n/**\nData output for DIO9*/\nexport const GPIO_DOUT31_0_DIO9: any = '1'\nexport const GPIO_DOUT31_0_DIO9_M: any = '1'\nexport const GPIO_DOUT31_0_DIO9_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO9_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO9_ZERO: any = '0'\n\n/**\nData output for DIO8*/\nexport const GPIO_DOUT31_0_DIO8: any = '1'\nexport const GPIO_DOUT31_0_DIO8_M: any = '1'\nexport const GPIO_DOUT31_0_DIO8_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO8_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO8_ZERO: any = '0'\n\n/**\nData output for DIO7*/\nexport const GPIO_DOUT31_0_DIO7: any = '1'\nexport const GPIO_DOUT31_0_DIO7_M: any = '1'\nexport const GPIO_DOUT31_0_DIO7_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO7_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO7_ZERO: any = '0'\n\n/**\nData output for DIO6*/\nexport const GPIO_DOUT31_0_DIO6: any = '1'\nexport const GPIO_DOUT31_0_DIO6_M: any = '1'\nexport const GPIO_DOUT31_0_DIO6_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO6_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO6_ZERO: any = '0'\n\n/**\nData output for DIO5*/\nexport const GPIO_DOUT31_0_DIO5: any = '1'\nexport const GPIO_DOUT31_0_DIO5_M: any = '1'\nexport const GPIO_DOUT31_0_DIO5_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO5_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO5_ZERO: any = '0'\n\n/**\nData output for DIO4*/\nexport const GPIO_DOUT31_0_DIO4: any = '1'\nexport const GPIO_DOUT31_0_DIO4_M: any = '1'\nexport const GPIO_DOUT31_0_DIO4_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO4_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO4_ZERO: any = '0'\n\n/**\nData output for DIO3*/\nexport const GPIO_DOUT31_0_DIO3: any = '1'\nexport const GPIO_DOUT31_0_DIO3_M: any = '1'\nexport const GPIO_DOUT31_0_DIO3_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO3_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO3_ZERO: any = '0'\n\n/**\nData output for DIO2*/\nexport const GPIO_DOUT31_0_DIO2: any = '1'\nexport const GPIO_DOUT31_0_DIO2_M: any = '1'\nexport const GPIO_DOUT31_0_DIO2_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO2_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO2_ZERO: any = '0'\n\n/**\nData output for DIO1*/\nexport const GPIO_DOUT31_0_DIO1: any = '1'\nexport const GPIO_DOUT31_0_DIO1_M: any = '1'\nexport const GPIO_DOUT31_0_DIO1_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO1_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO1_ZERO: any = '0'\n\n/**\nData output for DIO0*/\nexport const GPIO_DOUT31_0_DIO0: any = '1'\nexport const GPIO_DOUT31_0_DIO0_M: any = '1'\nexport const GPIO_DOUT31_0_DIO0_S: any = '1'\n/**\nOutput is set to 1*/\nexport const GPIO_DOUT31_0_DIO0_ONE: any = '1'\n\n/**\nOutput is set to 0*/\nexport const GPIO_DOUT31_0_DIO0_ZERO: any = '0'\n\n\n// -------- REGISTER DOUTSET31_0 -------- //\n\n/**\nAlias regiser to set the corresponding bits of DOUT31_0 register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTSET31_0_RESERVED26: any = '6'\nexport const GPIO_DOUTSET31_0_RESERVED26_M: any = '6'\nexport const GPIO_DOUTSET31_0_RESERVED26_S: any = '6'\n/**\nSet bit DOUT31_0.DIO25*/\nexport const GPIO_DOUTSET31_0_DIO25: any = '1'\nexport const GPIO_DOUTSET31_0_DIO25_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO25_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO25_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO25_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO24*/\nexport const GPIO_DOUTSET31_0_DIO24: any = '1'\nexport const GPIO_DOUTSET31_0_DIO24_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO24_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO24_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO24_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO23*/\nexport const GPIO_DOUTSET31_0_DIO23: any = '1'\nexport const GPIO_DOUTSET31_0_DIO23_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO23_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO23_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO23_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO22*/\nexport const GPIO_DOUTSET31_0_DIO22: any = '1'\nexport const GPIO_DOUTSET31_0_DIO22_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO22_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO22_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO22_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO21*/\nexport const GPIO_DOUTSET31_0_DIO21: any = '1'\nexport const GPIO_DOUTSET31_0_DIO21_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO21_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO21_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO21_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO20*/\nexport const GPIO_DOUTSET31_0_DIO20: any = '1'\nexport const GPIO_DOUTSET31_0_DIO20_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO20_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO20_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO20_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO19*/\nexport const GPIO_DOUTSET31_0_DIO19: any = '1'\nexport const GPIO_DOUTSET31_0_DIO19_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO19_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO19_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO19_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO18*/\nexport const GPIO_DOUTSET31_0_DIO18: any = '1'\nexport const GPIO_DOUTSET31_0_DIO18_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO18_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO18_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO18_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO17*/\nexport const GPIO_DOUTSET31_0_DIO17: any = '1'\nexport const GPIO_DOUTSET31_0_DIO17_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO17_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO17_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO17_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO16*/\nexport const GPIO_DOUTSET31_0_DIO16: any = '1'\nexport const GPIO_DOUTSET31_0_DIO16_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO16_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO16_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO16_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO15*/\nexport const GPIO_DOUTSET31_0_DIO15: any = '1'\nexport const GPIO_DOUTSET31_0_DIO15_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO15_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO15_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO15_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO14*/\nexport const GPIO_DOUTSET31_0_DIO14: any = '1'\nexport const GPIO_DOUTSET31_0_DIO14_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO14_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO14_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO14_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO13 */\nexport const GPIO_DOUTSET31_0_DIO13: any = '1'\nexport const GPIO_DOUTSET31_0_DIO13_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO13_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO13_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO13_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO12*/\nexport const GPIO_DOUTSET31_0_DIO12: any = '1'\nexport const GPIO_DOUTSET31_0_DIO12_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO12_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO12_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO12_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO11*/\nexport const GPIO_DOUTSET31_0_DIO11: any = '1'\nexport const GPIO_DOUTSET31_0_DIO11_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO11_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO11_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO11_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO10*/\nexport const GPIO_DOUTSET31_0_DIO10: any = '1'\nexport const GPIO_DOUTSET31_0_DIO10_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO10_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO10_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO10_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO9*/\nexport const GPIO_DOUTSET31_0_DIO9: any = '1'\nexport const GPIO_DOUTSET31_0_DIO9_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO9_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO9_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO9_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO8*/\nexport const GPIO_DOUTSET31_0_DIO8: any = '1'\nexport const GPIO_DOUTSET31_0_DIO8_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO8_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO8_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO8_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO7*/\nexport const GPIO_DOUTSET31_0_DIO7: any = '1'\nexport const GPIO_DOUTSET31_0_DIO7_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO7_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO7_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO7_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO6*/\nexport const GPIO_DOUTSET31_0_DIO6: any = '1'\nexport const GPIO_DOUTSET31_0_DIO6_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO6_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO6_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO6_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO5*/\nexport const GPIO_DOUTSET31_0_DIO5: any = '1'\nexport const GPIO_DOUTSET31_0_DIO5_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO5_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO5_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO5_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO4*/\nexport const GPIO_DOUTSET31_0_DIO4: any = '1'\nexport const GPIO_DOUTSET31_0_DIO4_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO4_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO4_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO4_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO3*/\nexport const GPIO_DOUTSET31_0_DIO3: any = '1'\nexport const GPIO_DOUTSET31_0_DIO3_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO3_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO3_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO3_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO2*/\nexport const GPIO_DOUTSET31_0_DIO2: any = '1'\nexport const GPIO_DOUTSET31_0_DIO2_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO2_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO2_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO2_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO1 */\nexport const GPIO_DOUTSET31_0_DIO1: any = '1'\nexport const GPIO_DOUTSET31_0_DIO1_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO1_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO1_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO1_NOEFF: any = '0'\n\n/**\nSet bit DOUT31_0.DIO0 */\nexport const GPIO_DOUTSET31_0_DIO0: any = '1'\nexport const GPIO_DOUTSET31_0_DIO0_M: any = '1'\nexport const GPIO_DOUTSET31_0_DIO0_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOUTSET31_0_DIO0_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTSET31_0_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER DOUTCLR31_0 -------- //\n\n/**\nAlias regiser to clear the corresponding bits of DOUT31_0 register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTCLR31_0_RESERVED26: any = '6'\nexport const GPIO_DOUTCLR31_0_RESERVED26_M: any = '6'\nexport const GPIO_DOUTCLR31_0_RESERVED26_S: any = '6'\n/**\nClear bit DOUT31_0.DIO25*/\nexport const GPIO_DOUTCLR31_0_DIO25: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO25_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO25_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO25_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO25_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO24*/\nexport const GPIO_DOUTCLR31_0_DIO24: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO24_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO24_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO24_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO24_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO23*/\nexport const GPIO_DOUTCLR31_0_DIO23: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO23_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO23_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO23_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO23_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO22*/\nexport const GPIO_DOUTCLR31_0_DIO22: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO22_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO22_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO22_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO22_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO21*/\nexport const GPIO_DOUTCLR31_0_DIO21: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO21_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO21_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO21_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO21_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO20*/\nexport const GPIO_DOUTCLR31_0_DIO20: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO20_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO20_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO20_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO20_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO19*/\nexport const GPIO_DOUTCLR31_0_DIO19: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO19_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO19_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO19_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO19_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO18*/\nexport const GPIO_DOUTCLR31_0_DIO18: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO18_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO18_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO18_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO18_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO17*/\nexport const GPIO_DOUTCLR31_0_DIO17: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO17_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO17_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO17_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO17_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO16*/\nexport const GPIO_DOUTCLR31_0_DIO16: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO16_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO16_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO16_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO16_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO15*/\nexport const GPIO_DOUTCLR31_0_DIO15: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO15_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO15_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO15_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO15_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO14*/\nexport const GPIO_DOUTCLR31_0_DIO14: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO14_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO14_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO14_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO14_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO13*/\nexport const GPIO_DOUTCLR31_0_DIO13: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO13_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO13_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO13_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO13_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO12*/\nexport const GPIO_DOUTCLR31_0_DIO12: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO12_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO12_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO12_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO12_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO11*/\nexport const GPIO_DOUTCLR31_0_DIO11: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO11_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO11_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO11_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO11_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO10*/\nexport const GPIO_DOUTCLR31_0_DIO10: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO10_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO10_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO10_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO10_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO9*/\nexport const GPIO_DOUTCLR31_0_DIO9: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO9_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO9_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO9_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO9_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO8*/\nexport const GPIO_DOUTCLR31_0_DIO8: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO8_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO8_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO8_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO8_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO7*/\nexport const GPIO_DOUTCLR31_0_DIO7: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO7_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO7_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO7_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO7_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO6*/\nexport const GPIO_DOUTCLR31_0_DIO6: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO6_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO6_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO6_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO6_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO5*/\nexport const GPIO_DOUTCLR31_0_DIO5: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO5_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO5_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO5_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO5_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO4*/\nexport const GPIO_DOUTCLR31_0_DIO4: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO4_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO4_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO4_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO4_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO3*/\nexport const GPIO_DOUTCLR31_0_DIO3: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO3_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO3_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO3_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO3_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO2*/\nexport const GPIO_DOUTCLR31_0_DIO2: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO2_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO2_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO2_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO2_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO1*/\nexport const GPIO_DOUTCLR31_0_DIO1: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO1_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO1_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO1_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO1_NOEFF: any = '0'\n\n/**\nClear bit DOUT31_0.DIO0*/\nexport const GPIO_DOUTCLR31_0_DIO0: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO0_M: any = '1'\nexport const GPIO_DOUTCLR31_0_DIO0_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOUTCLR31_0_DIO0_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTCLR31_0_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER DOUTTGL31_0 -------- //\n\n/**\nAlias regiser to toggle the corresponding bits of DOUT31_0 register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL31_0_RESERVED26: any = '6'\nexport const GPIO_DOUTTGL31_0_RESERVED26_M: any = '6'\nexport const GPIO_DOUTTGL31_0_RESERVED26_S: any = '6'\n/**\nToggles bit DOUT31_0.DIO25*/\nexport const GPIO_DOUTTGL31_0_DIO25: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO25_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO25_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO25_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO25_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO24*/\nexport const GPIO_DOUTTGL31_0_DIO24: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO24_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO24_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO24_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO24_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO23*/\nexport const GPIO_DOUTTGL31_0_DIO23: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO23_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO23_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO23_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO23_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO22*/\nexport const GPIO_DOUTTGL31_0_DIO22: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO22_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO22_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO22_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO22_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO21*/\nexport const GPIO_DOUTTGL31_0_DIO21: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO21_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO21_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO21_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO21_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO20*/\nexport const GPIO_DOUTTGL31_0_DIO20: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO20_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO20_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO20_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO20_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO19*/\nexport const GPIO_DOUTTGL31_0_DIO19: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO19_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO19_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO19_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO19_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO18*/\nexport const GPIO_DOUTTGL31_0_DIO18: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO18_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO18_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO18_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO18_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO17*/\nexport const GPIO_DOUTTGL31_0_DIO17: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO17_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO17_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO17_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO17_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO16*/\nexport const GPIO_DOUTTGL31_0_DIO16: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO16_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO16_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO16_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO16_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO15*/\nexport const GPIO_DOUTTGL31_0_DIO15: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO15_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO15_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO15_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO15_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO14*/\nexport const GPIO_DOUTTGL31_0_DIO14: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO14_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO14_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO14_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO14_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO13*/\nexport const GPIO_DOUTTGL31_0_DIO13: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO13_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO13_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO13_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO13_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO12*/\nexport const GPIO_DOUTTGL31_0_DIO12: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO12_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO12_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO12_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO12_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO11*/\nexport const GPIO_DOUTTGL31_0_DIO11: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO11_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO11_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO11_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO11_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO10*/\nexport const GPIO_DOUTTGL31_0_DIO10: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO10_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO10_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO10_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO10_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO9*/\nexport const GPIO_DOUTTGL31_0_DIO9: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO9_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO9_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO9_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO9_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO8*/\nexport const GPIO_DOUTTGL31_0_DIO8: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO8_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO8_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO8_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO8_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO7*/\nexport const GPIO_DOUTTGL31_0_DIO7: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO7_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO7_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO7_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO7_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO6*/\nexport const GPIO_DOUTTGL31_0_DIO6: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO6_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO6_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO6_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO6_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO5*/\nexport const GPIO_DOUTTGL31_0_DIO5: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO5_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO5_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO5_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO5_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO4*/\nexport const GPIO_DOUTTGL31_0_DIO4: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO4_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO4_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO4_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO4_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO3*/\nexport const GPIO_DOUTTGL31_0_DIO3: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO3_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO3_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO3_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO3_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO2*/\nexport const GPIO_DOUTTGL31_0_DIO2: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO2_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO2_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO2_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO2_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO1*/\nexport const GPIO_DOUTTGL31_0_DIO1: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO1_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO1_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO1_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO1_NOEFF: any = '0'\n\n/**\nToggles bit DOUT31_0.DIO0*/\nexport const GPIO_DOUTTGL31_0_DIO0: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO0_M: any = '1'\nexport const GPIO_DOUTTGL31_0_DIO0_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL31_0_DIO0_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL31_0_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER DOUTTGL3_0 -------- //\n\n/**\nAlias regiser to toggle the corresponding bits of DOUT31_0[3:0] register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL3_0_RESERVED25: any = '7'\nexport const GPIO_DOUTTGL3_0_RESERVED25_M: any = '7'\nexport const GPIO_DOUTTGL3_0_RESERVED25_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO3*/\nexport const GPIO_DOUTTGL3_0_DIO3: any = '1'\nexport const GPIO_DOUTTGL3_0_DIO3_M: any = '1'\nexport const GPIO_DOUTTGL3_0_DIO3_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL3_0_DIO3_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL3_0_DIO3_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL3_0_RESERVED17: any = '7'\nexport const GPIO_DOUTTGL3_0_RESERVED17_M: any = '7'\nexport const GPIO_DOUTTGL3_0_RESERVED17_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO2*/\nexport const GPIO_DOUTTGL3_0_DIO2: any = '1'\nexport const GPIO_DOUTTGL3_0_DIO2_M: any = '1'\nexport const GPIO_DOUTTGL3_0_DIO2_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL3_0_DIO2_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL3_0_DIO2_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL3_0_RESERVED9: any = '7'\nexport const GPIO_DOUTTGL3_0_RESERVED9_M: any = '7'\nexport const GPIO_DOUTTGL3_0_RESERVED9_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO1*/\nexport const GPIO_DOUTTGL3_0_DIO1: any = '1'\nexport const GPIO_DOUTTGL3_0_DIO1_M: any = '1'\nexport const GPIO_DOUTTGL3_0_DIO1_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL3_0_DIO1_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL3_0_DIO1_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL3_0_RESERVED1: any = '7'\nexport const GPIO_DOUTTGL3_0_RESERVED1_M: any = '7'\nexport const GPIO_DOUTTGL3_0_RESERVED1_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO0*/\nexport const GPIO_DOUTTGL3_0_DIO0: any = '1'\nexport const GPIO_DOUTTGL3_0_DIO0_M: any = '1'\nexport const GPIO_DOUTTGL3_0_DIO0_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL3_0_DIO0_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL3_0_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER DOUTTGL7_4 -------- //\n\n/**\nAlias regiser to toggle the corresponding bits of DOUT31_0[7:4] register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL7_4_RESERVED25: any = '7'\nexport const GPIO_DOUTTGL7_4_RESERVED25_M: any = '7'\nexport const GPIO_DOUTTGL7_4_RESERVED25_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO7*/\nexport const GPIO_DOUTTGL7_4_DIO7: any = '1'\nexport const GPIO_DOUTTGL7_4_DIO7_M: any = '1'\nexport const GPIO_DOUTTGL7_4_DIO7_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL7_4_DIO7_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL7_4_DIO7_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL7_4_RESERVED17: any = '7'\nexport const GPIO_DOUTTGL7_4_RESERVED17_M: any = '7'\nexport const GPIO_DOUTTGL7_4_RESERVED17_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO6*/\nexport const GPIO_DOUTTGL7_4_DIO6: any = '1'\nexport const GPIO_DOUTTGL7_4_DIO6_M: any = '1'\nexport const GPIO_DOUTTGL7_4_DIO6_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL7_4_DIO6_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL7_4_DIO6_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL7_4_RESERVED9: any = '7'\nexport const GPIO_DOUTTGL7_4_RESERVED9_M: any = '7'\nexport const GPIO_DOUTTGL7_4_RESERVED9_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO5*/\nexport const GPIO_DOUTTGL7_4_DIO5: any = '1'\nexport const GPIO_DOUTTGL7_4_DIO5_M: any = '1'\nexport const GPIO_DOUTTGL7_4_DIO5_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL7_4_DIO5_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL7_4_DIO5_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL7_4_RESERVED1: any = '7'\nexport const GPIO_DOUTTGL7_4_RESERVED1_M: any = '7'\nexport const GPIO_DOUTTGL7_4_RESERVED1_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO4*/\nexport const GPIO_DOUTTGL7_4_DIO4: any = '1'\nexport const GPIO_DOUTTGL7_4_DIO4_M: any = '1'\nexport const GPIO_DOUTTGL7_4_DIO4_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL7_4_DIO4_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL7_4_DIO4_NOEFF: any = '0'\n\n\n// -------- REGISTER DOUTTGL11_8 -------- //\n\n/**\nAlias regiser to toggle the corresponding bits of DOUT31_0[11:8] register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL11_8_RESERVED25: any = '7'\nexport const GPIO_DOUTTGL11_8_RESERVED25_M: any = '7'\nexport const GPIO_DOUTTGL11_8_RESERVED25_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO11*/\nexport const GPIO_DOUTTGL11_8_DIO11: any = '1'\nexport const GPIO_DOUTTGL11_8_DIO11_M: any = '1'\nexport const GPIO_DOUTTGL11_8_DIO11_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL11_8_DIO11_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL11_8_DIO11_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL11_8_RESERVED17: any = '7'\nexport const GPIO_DOUTTGL11_8_RESERVED17_M: any = '7'\nexport const GPIO_DOUTTGL11_8_RESERVED17_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO10*/\nexport const GPIO_DOUTTGL11_8_DIO10: any = '1'\nexport const GPIO_DOUTTGL11_8_DIO10_M: any = '1'\nexport const GPIO_DOUTTGL11_8_DIO10_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL11_8_DIO10_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL11_8_DIO10_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL11_8_RESERVED9: any = '7'\nexport const GPIO_DOUTTGL11_8_RESERVED9_M: any = '7'\nexport const GPIO_DOUTTGL11_8_RESERVED9_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO9*/\nexport const GPIO_DOUTTGL11_8_DIO9: any = '1'\nexport const GPIO_DOUTTGL11_8_DIO9_M: any = '1'\nexport const GPIO_DOUTTGL11_8_DIO9_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL11_8_DIO9_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL11_8_DIO9_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL11_8_RESERVED1: any = '7'\nexport const GPIO_DOUTTGL11_8_RESERVED1_M: any = '7'\nexport const GPIO_DOUTTGL11_8_RESERVED1_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO8*/\nexport const GPIO_DOUTTGL11_8_DIO8: any = '1'\nexport const GPIO_DOUTTGL11_8_DIO8_M: any = '1'\nexport const GPIO_DOUTTGL11_8_DIO8_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL11_8_DIO8_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL11_8_DIO8_NOEFF: any = '0'\n\n\n// -------- REGISTER DOUTTGL15_12 -------- //\n\n/**\nAlias regiser to toggle the corresponding bits of DOUT31_0[15:12] register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL15_12_RESERVED25: any = '7'\nexport const GPIO_DOUTTGL15_12_RESERVED25_M: any = '7'\nexport const GPIO_DOUTTGL15_12_RESERVED25_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO15*/\nexport const GPIO_DOUTTGL15_12_DIO15: any = '1'\nexport const GPIO_DOUTTGL15_12_DIO15_M: any = '1'\nexport const GPIO_DOUTTGL15_12_DIO15_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL15_12_DIO15_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL15_12_DIO15_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL15_12_RESERVED17: any = '7'\nexport const GPIO_DOUTTGL15_12_RESERVED17_M: any = '7'\nexport const GPIO_DOUTTGL15_12_RESERVED17_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO14*/\nexport const GPIO_DOUTTGL15_12_DIO14: any = '1'\nexport const GPIO_DOUTTGL15_12_DIO14_M: any = '1'\nexport const GPIO_DOUTTGL15_12_DIO14_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL15_12_DIO14_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL15_12_DIO14_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL15_12_RESERVED9: any = '7'\nexport const GPIO_DOUTTGL15_12_RESERVED9_M: any = '7'\nexport const GPIO_DOUTTGL15_12_RESERVED9_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO13*/\nexport const GPIO_DOUTTGL15_12_DIO13: any = '1'\nexport const GPIO_DOUTTGL15_12_DIO13_M: any = '1'\nexport const GPIO_DOUTTGL15_12_DIO13_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL15_12_DIO13_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL15_12_DIO13_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL15_12_RESERVED1: any = '7'\nexport const GPIO_DOUTTGL15_12_RESERVED1_M: any = '7'\nexport const GPIO_DOUTTGL15_12_RESERVED1_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO12*/\nexport const GPIO_DOUTTGL15_12_DIO12: any = '1'\nexport const GPIO_DOUTTGL15_12_DIO12_M: any = '1'\nexport const GPIO_DOUTTGL15_12_DIO12_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL15_12_DIO12_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL15_12_DIO12_NOEFF: any = '0'\n\n\n// -------- REGISTER DOUTTGL19_16 -------- //\n\n/**\nAlias regiser to toggle the corresponding bits of DOUT31_0[19:16] register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL19_16_RESERVED25: any = '7'\nexport const GPIO_DOUTTGL19_16_RESERVED25_M: any = '7'\nexport const GPIO_DOUTTGL19_16_RESERVED25_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO19*/\nexport const GPIO_DOUTTGL19_16_DIO19: any = '1'\nexport const GPIO_DOUTTGL19_16_DIO19_M: any = '1'\nexport const GPIO_DOUTTGL19_16_DIO19_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL19_16_DIO19_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL19_16_DIO19_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL19_16_RESERVED17: any = '7'\nexport const GPIO_DOUTTGL19_16_RESERVED17_M: any = '7'\nexport const GPIO_DOUTTGL19_16_RESERVED17_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO18*/\nexport const GPIO_DOUTTGL19_16_DIO18: any = '1'\nexport const GPIO_DOUTTGL19_16_DIO18_M: any = '1'\nexport const GPIO_DOUTTGL19_16_DIO18_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL19_16_DIO18_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL19_16_DIO18_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL19_16_RESERVED9: any = '7'\nexport const GPIO_DOUTTGL19_16_RESERVED9_M: any = '7'\nexport const GPIO_DOUTTGL19_16_RESERVED9_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO17*/\nexport const GPIO_DOUTTGL19_16_DIO17: any = '1'\nexport const GPIO_DOUTTGL19_16_DIO17_M: any = '1'\nexport const GPIO_DOUTTGL19_16_DIO17_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL19_16_DIO17_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL19_16_DIO17_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL19_16_RESERVED1: any = '7'\nexport const GPIO_DOUTTGL19_16_RESERVED1_M: any = '7'\nexport const GPIO_DOUTTGL19_16_RESERVED1_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO16*/\nexport const GPIO_DOUTTGL19_16_DIO16: any = '1'\nexport const GPIO_DOUTTGL19_16_DIO16_M: any = '1'\nexport const GPIO_DOUTTGL19_16_DIO16_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL19_16_DIO16_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL19_16_DIO16_NOEFF: any = '0'\n\n\n// -------- REGISTER DOUTTGL23_20 -------- //\n\n/**\nAlias regiser to toggle the corresponding bits of DOUT31_0[23:20] register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL23_20_RESERVED25: any = '7'\nexport const GPIO_DOUTTGL23_20_RESERVED25_M: any = '7'\nexport const GPIO_DOUTTGL23_20_RESERVED25_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO23*/\nexport const GPIO_DOUTTGL23_20_DIO23: any = '1'\nexport const GPIO_DOUTTGL23_20_DIO23_M: any = '1'\nexport const GPIO_DOUTTGL23_20_DIO23_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL23_20_DIO23_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL23_20_DIO23_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL23_20_RESERVED17: any = '7'\nexport const GPIO_DOUTTGL23_20_RESERVED17_M: any = '7'\nexport const GPIO_DOUTTGL23_20_RESERVED17_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO22*/\nexport const GPIO_DOUTTGL23_20_DIO22: any = '1'\nexport const GPIO_DOUTTGL23_20_DIO22_M: any = '1'\nexport const GPIO_DOUTTGL23_20_DIO22_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL23_20_DIO22_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL23_20_DIO22_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL23_20_RESERVED9: any = '7'\nexport const GPIO_DOUTTGL23_20_RESERVED9_M: any = '7'\nexport const GPIO_DOUTTGL23_20_RESERVED9_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO21*/\nexport const GPIO_DOUTTGL23_20_DIO21: any = '1'\nexport const GPIO_DOUTTGL23_20_DIO21_M: any = '1'\nexport const GPIO_DOUTTGL23_20_DIO21_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL23_20_DIO21_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL23_20_DIO21_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL23_20_RESERVED1: any = '7'\nexport const GPIO_DOUTTGL23_20_RESERVED1_M: any = '7'\nexport const GPIO_DOUTTGL23_20_RESERVED1_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO20*/\nexport const GPIO_DOUTTGL23_20_DIO20: any = '1'\nexport const GPIO_DOUTTGL23_20_DIO20_M: any = '1'\nexport const GPIO_DOUTTGL23_20_DIO20_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL23_20_DIO20_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL23_20_DIO20_NOEFF: any = '0'\n\n\n// -------- REGISTER DOUTTGL27_24 -------- //\n\n/**\nAlias regiser to toggle the corresponding bits of DOUT31_0[27:24] register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL27_24_RESERVED9: any = '23'\nexport const GPIO_DOUTTGL27_24_RESERVED9_M: any = '23'\nexport const GPIO_DOUTTGL27_24_RESERVED9_S: any = '23'\n/**\nToggles bit DOUT31_0.DIO25*/\nexport const GPIO_DOUTTGL27_24_DIO25: any = '1'\nexport const GPIO_DOUTTGL27_24_DIO25_M: any = '1'\nexport const GPIO_DOUTTGL27_24_DIO25_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL27_24_DIO25_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL27_24_DIO25_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOUTTGL27_24_RESERVED1: any = '7'\nexport const GPIO_DOUTTGL27_24_RESERVED1_M: any = '7'\nexport const GPIO_DOUTTGL27_24_RESERVED1_S: any = '7'\n/**\nToggles bit DOUT31_0.DIO24*/\nexport const GPIO_DOUTTGL27_24_DIO24: any = '1'\nexport const GPIO_DOUTTGL27_24_DIO24_M: any = '1'\nexport const GPIO_DOUTTGL27_24_DIO24_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOUTTGL27_24_DIO24_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOUTTGL27_24_DIO24_NOEFF: any = '0'\n\n\n// -------- REGISTER DOE3_0 -------- //\n\n/**\nAlias register for byte access to DOE31_0[3:0] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE3_0_RESERVED25: any = '7'\nexport const GPIO_DOE3_0_RESERVED25_M: any = '7'\nexport const GPIO_DOE3_0_RESERVED25_S: any = '7'\n/**\nData output enable for DIO3*/\nexport const GPIO_DOE3_0_DIO3: any = '1'\nexport const GPIO_DOE3_0_DIO3_M: any = '1'\nexport const GPIO_DOE3_0_DIO3_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE3_0_DIO3_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE3_0_DIO3_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE3_0_RESERVED17: any = '7'\nexport const GPIO_DOE3_0_RESERVED17_M: any = '7'\nexport const GPIO_DOE3_0_RESERVED17_S: any = '7'\n/**\nData output enable for DIO2*/\nexport const GPIO_DOE3_0_DIO2: any = '1'\nexport const GPIO_DOE3_0_DIO2_M: any = '1'\nexport const GPIO_DOE3_0_DIO2_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE3_0_DIO2_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE3_0_DIO2_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE3_0_RESERVED9: any = '7'\nexport const GPIO_DOE3_0_RESERVED9_M: any = '7'\nexport const GPIO_DOE3_0_RESERVED9_S: any = '7'\n/**\nData output enable for DIO1*/\nexport const GPIO_DOE3_0_DIO1: any = '1'\nexport const GPIO_DOE3_0_DIO1_M: any = '1'\nexport const GPIO_DOE3_0_DIO1_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE3_0_DIO1_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE3_0_DIO1_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE3_0_RESERVED1: any = '7'\nexport const GPIO_DOE3_0_RESERVED1_M: any = '7'\nexport const GPIO_DOE3_0_RESERVED1_S: any = '7'\n/**\nData output enable for DIO0*/\nexport const GPIO_DOE3_0_DIO0: any = '1'\nexport const GPIO_DOE3_0_DIO0_M: any = '1'\nexport const GPIO_DOE3_0_DIO0_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE3_0_DIO0_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE3_0_DIO0_DIS: any = '0'\n\n\n// -------- REGISTER DOE7_4 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[7:4] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE7_4_RESERVED25: any = '7'\nexport const GPIO_DOE7_4_RESERVED25_M: any = '7'\nexport const GPIO_DOE7_4_RESERVED25_S: any = '7'\n/**\nData output enable for DIO7*/\nexport const GPIO_DOE7_4_DIO7: any = '1'\nexport const GPIO_DOE7_4_DIO7_M: any = '1'\nexport const GPIO_DOE7_4_DIO7_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE7_4_DIO7_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE7_4_DIO7_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE7_4_RESERVED17: any = '7'\nexport const GPIO_DOE7_4_RESERVED17_M: any = '7'\nexport const GPIO_DOE7_4_RESERVED17_S: any = '7'\n/**\nData output enable for DIO6*/\nexport const GPIO_DOE7_4_DIO6: any = '1'\nexport const GPIO_DOE7_4_DIO6_M: any = '1'\nexport const GPIO_DOE7_4_DIO6_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE7_4_DIO6_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE7_4_DIO6_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE7_4_RESERVED9: any = '7'\nexport const GPIO_DOE7_4_RESERVED9_M: any = '7'\nexport const GPIO_DOE7_4_RESERVED9_S: any = '7'\n/**\nData output enable for DIO5*/\nexport const GPIO_DOE7_4_DIO5: any = '1'\nexport const GPIO_DOE7_4_DIO5_M: any = '1'\nexport const GPIO_DOE7_4_DIO5_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE7_4_DIO5_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE7_4_DIO5_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE7_4_RESERVED1: any = '7'\nexport const GPIO_DOE7_4_RESERVED1_M: any = '7'\nexport const GPIO_DOE7_4_RESERVED1_S: any = '7'\n/**\nData output enable for DIO4*/\nexport const GPIO_DOE7_4_DIO4: any = '1'\nexport const GPIO_DOE7_4_DIO4_M: any = '1'\nexport const GPIO_DOE7_4_DIO4_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE7_4_DIO4_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE7_4_DIO4_DIS: any = '0'\n\n\n// -------- REGISTER DOE11_8 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[11:8] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE11_8_RESERVED25: any = '7'\nexport const GPIO_DOE11_8_RESERVED25_M: any = '7'\nexport const GPIO_DOE11_8_RESERVED25_S: any = '7'\n/**\nData output enable for DIO11*/\nexport const GPIO_DOE11_8_DIO11: any = '1'\nexport const GPIO_DOE11_8_DIO11_M: any = '1'\nexport const GPIO_DOE11_8_DIO11_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE11_8_DIO11_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE11_8_DIO11_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE11_8_RESERVED17: any = '7'\nexport const GPIO_DOE11_8_RESERVED17_M: any = '7'\nexport const GPIO_DOE11_8_RESERVED17_S: any = '7'\n/**\nData output enable for DIO10*/\nexport const GPIO_DOE11_8_DIO10: any = '1'\nexport const GPIO_DOE11_8_DIO10_M: any = '1'\nexport const GPIO_DOE11_8_DIO10_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE11_8_DIO10_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE11_8_DIO10_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE11_8_RESERVED9: any = '7'\nexport const GPIO_DOE11_8_RESERVED9_M: any = '7'\nexport const GPIO_DOE11_8_RESERVED9_S: any = '7'\n/**\nData output enable for DIO9*/\nexport const GPIO_DOE11_8_DIO9: any = '1'\nexport const GPIO_DOE11_8_DIO9_M: any = '1'\nexport const GPIO_DOE11_8_DIO9_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE11_8_DIO9_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE11_8_DIO9_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE11_8_RESERVED1: any = '7'\nexport const GPIO_DOE11_8_RESERVED1_M: any = '7'\nexport const GPIO_DOE11_8_RESERVED1_S: any = '7'\n/**\nData output enable for DIO8*/\nexport const GPIO_DOE11_8_DIO8: any = '1'\nexport const GPIO_DOE11_8_DIO8_M: any = '1'\nexport const GPIO_DOE11_8_DIO8_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE11_8_DIO8_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE11_8_DIO8_DIS: any = '0'\n\n\n// -------- REGISTER DOE15_12 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[15:12] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE15_12_RESERVED25: any = '7'\nexport const GPIO_DOE15_12_RESERVED25_M: any = '7'\nexport const GPIO_DOE15_12_RESERVED25_S: any = '7'\n/**\nData output enable for DIO15*/\nexport const GPIO_DOE15_12_DIO15: any = '1'\nexport const GPIO_DOE15_12_DIO15_M: any = '1'\nexport const GPIO_DOE15_12_DIO15_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE15_12_DIO15_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE15_12_DIO15_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE15_12_RESERVED17: any = '7'\nexport const GPIO_DOE15_12_RESERVED17_M: any = '7'\nexport const GPIO_DOE15_12_RESERVED17_S: any = '7'\n/**\nData output enable for DIO14*/\nexport const GPIO_DOE15_12_DIO14: any = '1'\nexport const GPIO_DOE15_12_DIO14_M: any = '1'\nexport const GPIO_DOE15_12_DIO14_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE15_12_DIO14_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE15_12_DIO14_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE15_12_RESERVED9: any = '7'\nexport const GPIO_DOE15_12_RESERVED9_M: any = '7'\nexport const GPIO_DOE15_12_RESERVED9_S: any = '7'\n/**\nData output enable for DIO13*/\nexport const GPIO_DOE15_12_DIO13: any = '1'\nexport const GPIO_DOE15_12_DIO13_M: any = '1'\nexport const GPIO_DOE15_12_DIO13_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE15_12_DIO13_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE15_12_DIO13_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE15_12_RESERVED1: any = '7'\nexport const GPIO_DOE15_12_RESERVED1_M: any = '7'\nexport const GPIO_DOE15_12_RESERVED1_S: any = '7'\n/**\nData output enable for DIO12*/\nexport const GPIO_DOE15_12_DIO12: any = '1'\nexport const GPIO_DOE15_12_DIO12_M: any = '1'\nexport const GPIO_DOE15_12_DIO12_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE15_12_DIO12_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE15_12_DIO12_DIS: any = '0'\n\n\n// -------- REGISTER DOE19_16 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[19:16] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE19_16_RESERVED25: any = '7'\nexport const GPIO_DOE19_16_RESERVED25_M: any = '7'\nexport const GPIO_DOE19_16_RESERVED25_S: any = '7'\n/**\nData output enable for DIO19*/\nexport const GPIO_DOE19_16_DIO19: any = '1'\nexport const GPIO_DOE19_16_DIO19_M: any = '1'\nexport const GPIO_DOE19_16_DIO19_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE19_16_DIO19_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE19_16_DIO19_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE19_16_RESERVED17: any = '7'\nexport const GPIO_DOE19_16_RESERVED17_M: any = '7'\nexport const GPIO_DOE19_16_RESERVED17_S: any = '7'\n/**\nData output enable for DIO18*/\nexport const GPIO_DOE19_16_DIO18: any = '1'\nexport const GPIO_DOE19_16_DIO18_M: any = '1'\nexport const GPIO_DOE19_16_DIO18_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE19_16_DIO18_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE19_16_DIO18_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE19_16_RESERVED9: any = '7'\nexport const GPIO_DOE19_16_RESERVED9_M: any = '7'\nexport const GPIO_DOE19_16_RESERVED9_S: any = '7'\n/**\nData output enable for DIO17*/\nexport const GPIO_DOE19_16_DIO17: any = '1'\nexport const GPIO_DOE19_16_DIO17_M: any = '1'\nexport const GPIO_DOE19_16_DIO17_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE19_16_DIO17_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE19_16_DIO17_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE19_16_RESERVED1: any = '7'\nexport const GPIO_DOE19_16_RESERVED1_M: any = '7'\nexport const GPIO_DOE19_16_RESERVED1_S: any = '7'\n/**\nData output enable for DIO16*/\nexport const GPIO_DOE19_16_DIO16: any = '1'\nexport const GPIO_DOE19_16_DIO16_M: any = '1'\nexport const GPIO_DOE19_16_DIO16_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE19_16_DIO16_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE19_16_DIO16_DIS: any = '0'\n\n\n// -------- REGISTER DOE23_20 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[23:20] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE23_20_RESERVED25: any = '7'\nexport const GPIO_DOE23_20_RESERVED25_M: any = '7'\nexport const GPIO_DOE23_20_RESERVED25_S: any = '7'\n/**\nData output enable for DIO23*/\nexport const GPIO_DOE23_20_DIO23: any = '1'\nexport const GPIO_DOE23_20_DIO23_M: any = '1'\nexport const GPIO_DOE23_20_DIO23_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE23_20_DIO23_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE23_20_DIO23_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE23_20_RESERVED17: any = '7'\nexport const GPIO_DOE23_20_RESERVED17_M: any = '7'\nexport const GPIO_DOE23_20_RESERVED17_S: any = '7'\n/**\nData output enable for DIO22*/\nexport const GPIO_DOE23_20_DIO22: any = '1'\nexport const GPIO_DOE23_20_DIO22_M: any = '1'\nexport const GPIO_DOE23_20_DIO22_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE23_20_DIO22_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE23_20_DIO22_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE23_20_RESERVED9: any = '7'\nexport const GPIO_DOE23_20_RESERVED9_M: any = '7'\nexport const GPIO_DOE23_20_RESERVED9_S: any = '7'\n/**\nData output enable for DIO21*/\nexport const GPIO_DOE23_20_DIO21: any = '1'\nexport const GPIO_DOE23_20_DIO21_M: any = '1'\nexport const GPIO_DOE23_20_DIO21_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE23_20_DIO21_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE23_20_DIO21_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE23_20_RESERVED1: any = '7'\nexport const GPIO_DOE23_20_RESERVED1_M: any = '7'\nexport const GPIO_DOE23_20_RESERVED1_S: any = '7'\n/**\nData output enable for DIO20*/\nexport const GPIO_DOE23_20_DIO20: any = '1'\nexport const GPIO_DOE23_20_DIO20_M: any = '1'\nexport const GPIO_DOE23_20_DIO20_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE23_20_DIO20_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE23_20_DIO20_DIS: any = '0'\n\n\n// -------- REGISTER DOE27_24 -------- //\n\n/**\nAlias register for byte access to DOUT31_0[27:24] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE27_24_RESERVED9: any = '23'\nexport const GPIO_DOE27_24_RESERVED9_M: any = '23'\nexport const GPIO_DOE27_24_RESERVED9_S: any = '23'\n/**\nData output enable for DIO25*/\nexport const GPIO_DOE27_24_DIO25: any = '1'\nexport const GPIO_DOE27_24_DIO25_M: any = '1'\nexport const GPIO_DOE27_24_DIO25_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE27_24_DIO25_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE27_24_DIO25_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE27_24_RESERVED1: any = '7'\nexport const GPIO_DOE27_24_RESERVED1_M: any = '7'\nexport const GPIO_DOE27_24_RESERVED1_S: any = '7'\n/**\nData output enable for DIO24*/\nexport const GPIO_DOE27_24_DIO24: any = '1'\nexport const GPIO_DOE27_24_DIO24_M: any = '1'\nexport const GPIO_DOE27_24_DIO24_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE27_24_DIO24_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE27_24_DIO24_DIS: any = '0'\n\n\n// -------- REGISTER DOE31_0 -------- //\n\n/**\nData output control for DIO 31 to 0 pins.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOE31_0_RESERVED26: any = '6'\nexport const GPIO_DOE31_0_RESERVED26_M: any = '6'\nexport const GPIO_DOE31_0_RESERVED26_S: any = '6'\n/**\nData output enable for DIO25*/\nexport const GPIO_DOE31_0_DIO25: any = '1'\nexport const GPIO_DOE31_0_DIO25_M: any = '1'\nexport const GPIO_DOE31_0_DIO25_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO25_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO25_DIS: any = '0'\n\n/**\nData output enable for DIO24*/\nexport const GPIO_DOE31_0_DIO24: any = '1'\nexport const GPIO_DOE31_0_DIO24_M: any = '1'\nexport const GPIO_DOE31_0_DIO24_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO24_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO24_DIS: any = '0'\n\n/**\nData output enable for DIO23*/\nexport const GPIO_DOE31_0_DIO23: any = '1'\nexport const GPIO_DOE31_0_DIO23_M: any = '1'\nexport const GPIO_DOE31_0_DIO23_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO23_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO23_DIS: any = '0'\n\n/**\nData output enable for DIO22*/\nexport const GPIO_DOE31_0_DIO22: any = '1'\nexport const GPIO_DOE31_0_DIO22_M: any = '1'\nexport const GPIO_DOE31_0_DIO22_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO22_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO22_DIS: any = '0'\n\n/**\nData output enable for DIO21*/\nexport const GPIO_DOE31_0_DIO21: any = '1'\nexport const GPIO_DOE31_0_DIO21_M: any = '1'\nexport const GPIO_DOE31_0_DIO21_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO21_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO21_DIS: any = '0'\n\n/**\nData output enable for DIO20*/\nexport const GPIO_DOE31_0_DIO20: any = '1'\nexport const GPIO_DOE31_0_DIO20_M: any = '1'\nexport const GPIO_DOE31_0_DIO20_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO20_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO20_DIS: any = '0'\n\n/**\nData output enable for DIO19*/\nexport const GPIO_DOE31_0_DIO19: any = '1'\nexport const GPIO_DOE31_0_DIO19_M: any = '1'\nexport const GPIO_DOE31_0_DIO19_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO19_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO19_DIS: any = '0'\n\n/**\nData output enable for DIO18*/\nexport const GPIO_DOE31_0_DIO18: any = '1'\nexport const GPIO_DOE31_0_DIO18_M: any = '1'\nexport const GPIO_DOE31_0_DIO18_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO18_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO18_DIS: any = '0'\n\n/**\nData output enable for DIO17*/\nexport const GPIO_DOE31_0_DIO17: any = '1'\nexport const GPIO_DOE31_0_DIO17_M: any = '1'\nexport const GPIO_DOE31_0_DIO17_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO17_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO17_DIS: any = '0'\n\n/**\nData output enable for DIO16*/\nexport const GPIO_DOE31_0_DIO16: any = '1'\nexport const GPIO_DOE31_0_DIO16_M: any = '1'\nexport const GPIO_DOE31_0_DIO16_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO16_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO16_DIS: any = '0'\n\n/**\nData output enable for DIO15*/\nexport const GPIO_DOE31_0_DIO15: any = '1'\nexport const GPIO_DOE31_0_DIO15_M: any = '1'\nexport const GPIO_DOE31_0_DIO15_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO15_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO15_DIS: any = '0'\n\n/**\nData output enable for DIO14*/\nexport const GPIO_DOE31_0_DIO14: any = '1'\nexport const GPIO_DOE31_0_DIO14_M: any = '1'\nexport const GPIO_DOE31_0_DIO14_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO14_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO14_DIS: any = '0'\n\n/**\nData output enable for DIO13*/\nexport const GPIO_DOE31_0_DIO13: any = '1'\nexport const GPIO_DOE31_0_DIO13_M: any = '1'\nexport const GPIO_DOE31_0_DIO13_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO13_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO13_DIS: any = '0'\n\n/**\nData output enable for DIO12*/\nexport const GPIO_DOE31_0_DIO12: any = '1'\nexport const GPIO_DOE31_0_DIO12_M: any = '1'\nexport const GPIO_DOE31_0_DIO12_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO12_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO12_DIS: any = '0'\n\n/**\nData output enable for DIO11*/\nexport const GPIO_DOE31_0_DIO11: any = '1'\nexport const GPIO_DOE31_0_DIO11_M: any = '1'\nexport const GPIO_DOE31_0_DIO11_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO11_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO11_DIS: any = '0'\n\n/**\nData output enable for DIO10*/\nexport const GPIO_DOE31_0_DIO10: any = '1'\nexport const GPIO_DOE31_0_DIO10_M: any = '1'\nexport const GPIO_DOE31_0_DIO10_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO10_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO10_DIS: any = '0'\n\n/**\nData output enable for DIO9*/\nexport const GPIO_DOE31_0_DIO9: any = '1'\nexport const GPIO_DOE31_0_DIO9_M: any = '1'\nexport const GPIO_DOE31_0_DIO9_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO9_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO9_DIS: any = '0'\n\n/**\nData output enable for DIO8*/\nexport const GPIO_DOE31_0_DIO8: any = '1'\nexport const GPIO_DOE31_0_DIO8_M: any = '1'\nexport const GPIO_DOE31_0_DIO8_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO8_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO8_DIS: any = '0'\n\n/**\nData output enable for DIO7*/\nexport const GPIO_DOE31_0_DIO7: any = '1'\nexport const GPIO_DOE31_0_DIO7_M: any = '1'\nexport const GPIO_DOE31_0_DIO7_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO7_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO7_DIS: any = '0'\n\n/**\nData output enable for DIO6*/\nexport const GPIO_DOE31_0_DIO6: any = '1'\nexport const GPIO_DOE31_0_DIO6_M: any = '1'\nexport const GPIO_DOE31_0_DIO6_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO6_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO6_DIS: any = '0'\n\n/**\nData output enable for DIO5*/\nexport const GPIO_DOE31_0_DIO5: any = '1'\nexport const GPIO_DOE31_0_DIO5_M: any = '1'\nexport const GPIO_DOE31_0_DIO5_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO5_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO5_DIS: any = '0'\n\n/**\nData output enable for DIO4*/\nexport const GPIO_DOE31_0_DIO4: any = '1'\nexport const GPIO_DOE31_0_DIO4_M: any = '1'\nexport const GPIO_DOE31_0_DIO4_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO4_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO4_DIS: any = '0'\n\n/**\nData output enable for DIO3*/\nexport const GPIO_DOE31_0_DIO3: any = '1'\nexport const GPIO_DOE31_0_DIO3_M: any = '1'\nexport const GPIO_DOE31_0_DIO3_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO3_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO3_DIS: any = '0'\n\n/**\nData output enable for DIO2*/\nexport const GPIO_DOE31_0_DIO2: any = '1'\nexport const GPIO_DOE31_0_DIO2_M: any = '1'\nexport const GPIO_DOE31_0_DIO2_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO2_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO2_DIS: any = '0'\n\n/**\nData output enable for DIO1*/\nexport const GPIO_DOE31_0_DIO1: any = '1'\nexport const GPIO_DOE31_0_DIO1_M: any = '1'\nexport const GPIO_DOE31_0_DIO1_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO1_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO1_DIS: any = '0'\n\n/**\nData output enable for DIO0*/\nexport const GPIO_DOE31_0_DIO0: any = '1'\nexport const GPIO_DOE31_0_DIO0_M: any = '1'\nexport const GPIO_DOE31_0_DIO0_S: any = '1'\n/**\nOutput enabled*/\nexport const GPIO_DOE31_0_DIO0_EN: any = '1'\n\n/**\nOutput disabled*/\nexport const GPIO_DOE31_0_DIO0_DIS: any = '0'\n\n\n// -------- REGISTER DOESET31_0 -------- //\n\n/**\nAlias regiser to set the corresponding bits of DOE31_0 register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOESET31_0_RESERVED26: any = '6'\nexport const GPIO_DOESET31_0_RESERVED26_M: any = '6'\nexport const GPIO_DOESET31_0_RESERVED26_S: any = '6'\n/**\nSets bit DOE31_0.DIO25*/\nexport const GPIO_DOESET31_0_DIO25: any = '1'\nexport const GPIO_DOESET31_0_DIO25_M: any = '1'\nexport const GPIO_DOESET31_0_DIO25_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO25_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO25_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO24*/\nexport const GPIO_DOESET31_0_DIO24: any = '1'\nexport const GPIO_DOESET31_0_DIO24_M: any = '1'\nexport const GPIO_DOESET31_0_DIO24_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO24_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO24_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO23*/\nexport const GPIO_DOESET31_0_DIO23: any = '1'\nexport const GPIO_DOESET31_0_DIO23_M: any = '1'\nexport const GPIO_DOESET31_0_DIO23_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO23_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO23_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO22*/\nexport const GPIO_DOESET31_0_DIO22: any = '1'\nexport const GPIO_DOESET31_0_DIO22_M: any = '1'\nexport const GPIO_DOESET31_0_DIO22_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO22_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO22_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO21 */\nexport const GPIO_DOESET31_0_DIO21: any = '1'\nexport const GPIO_DOESET31_0_DIO21_M: any = '1'\nexport const GPIO_DOESET31_0_DIO21_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO21_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO21_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO20 */\nexport const GPIO_DOESET31_0_DIO20: any = '1'\nexport const GPIO_DOESET31_0_DIO20_M: any = '1'\nexport const GPIO_DOESET31_0_DIO20_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO20_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO20_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO19 */\nexport const GPIO_DOESET31_0_DIO19: any = '1'\nexport const GPIO_DOESET31_0_DIO19_M: any = '1'\nexport const GPIO_DOESET31_0_DIO19_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO19_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO19_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO18 */\nexport const GPIO_DOESET31_0_DIO18: any = '1'\nexport const GPIO_DOESET31_0_DIO18_M: any = '1'\nexport const GPIO_DOESET31_0_DIO18_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO18_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO18_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO17 */\nexport const GPIO_DOESET31_0_DIO17: any = '1'\nexport const GPIO_DOESET31_0_DIO17_M: any = '1'\nexport const GPIO_DOESET31_0_DIO17_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO17_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO17_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO16 */\nexport const GPIO_DOESET31_0_DIO16: any = '1'\nexport const GPIO_DOESET31_0_DIO16_M: any = '1'\nexport const GPIO_DOESET31_0_DIO16_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO16_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO16_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO15 */\nexport const GPIO_DOESET31_0_DIO15: any = '1'\nexport const GPIO_DOESET31_0_DIO15_M: any = '1'\nexport const GPIO_DOESET31_0_DIO15_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO15_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO15_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO14 */\nexport const GPIO_DOESET31_0_DIO14: any = '1'\nexport const GPIO_DOESET31_0_DIO14_M: any = '1'\nexport const GPIO_DOESET31_0_DIO14_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO14_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO14_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO13 */\nexport const GPIO_DOESET31_0_DIO13: any = '1'\nexport const GPIO_DOESET31_0_DIO13_M: any = '1'\nexport const GPIO_DOESET31_0_DIO13_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO13_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO13_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO12 */\nexport const GPIO_DOESET31_0_DIO12: any = '1'\nexport const GPIO_DOESET31_0_DIO12_M: any = '1'\nexport const GPIO_DOESET31_0_DIO12_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO12_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO12_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO11 */\nexport const GPIO_DOESET31_0_DIO11: any = '1'\nexport const GPIO_DOESET31_0_DIO11_M: any = '1'\nexport const GPIO_DOESET31_0_DIO11_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO11_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO11_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO10 */\nexport const GPIO_DOESET31_0_DIO10: any = '1'\nexport const GPIO_DOESET31_0_DIO10_M: any = '1'\nexport const GPIO_DOESET31_0_DIO10_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO10_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO10_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO9 */\nexport const GPIO_DOESET31_0_DIO9: any = '1'\nexport const GPIO_DOESET31_0_DIO9_M: any = '1'\nexport const GPIO_DOESET31_0_DIO9_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO9_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO9_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO8*/\nexport const GPIO_DOESET31_0_DIO8: any = '1'\nexport const GPIO_DOESET31_0_DIO8_M: any = '1'\nexport const GPIO_DOESET31_0_DIO8_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO8_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO8_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO7 */\nexport const GPIO_DOESET31_0_DIO7: any = '1'\nexport const GPIO_DOESET31_0_DIO7_M: any = '1'\nexport const GPIO_DOESET31_0_DIO7_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO7_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO7_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO6 */\nexport const GPIO_DOESET31_0_DIO6: any = '1'\nexport const GPIO_DOESET31_0_DIO6_M: any = '1'\nexport const GPIO_DOESET31_0_DIO6_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO6_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO6_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO5 */\nexport const GPIO_DOESET31_0_DIO5: any = '1'\nexport const GPIO_DOESET31_0_DIO5_M: any = '1'\nexport const GPIO_DOESET31_0_DIO5_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO5_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO5_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO4 */\nexport const GPIO_DOESET31_0_DIO4: any = '1'\nexport const GPIO_DOESET31_0_DIO4_M: any = '1'\nexport const GPIO_DOESET31_0_DIO4_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO4_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO4_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO3 */\nexport const GPIO_DOESET31_0_DIO3: any = '1'\nexport const GPIO_DOESET31_0_DIO3_M: any = '1'\nexport const GPIO_DOESET31_0_DIO3_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO3_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO3_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO2 */\nexport const GPIO_DOESET31_0_DIO2: any = '1'\nexport const GPIO_DOESET31_0_DIO2_M: any = '1'\nexport const GPIO_DOESET31_0_DIO2_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO2_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO2_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO1 */\nexport const GPIO_DOESET31_0_DIO1: any = '1'\nexport const GPIO_DOESET31_0_DIO1_M: any = '1'\nexport const GPIO_DOESET31_0_DIO1_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO1_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO1_NOEFF: any = '0'\n\n/**\nSets bit DOE31_0.DIO0 */\nexport const GPIO_DOESET31_0_DIO0: any = '1'\nexport const GPIO_DOESET31_0_DIO0_M: any = '1'\nexport const GPIO_DOESET31_0_DIO0_S: any = '1'\n/**\nSet*/\nexport const GPIO_DOESET31_0_DIO0_SET: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOESET31_0_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER DOECLR31_0 -------- //\n\n/**\nAlias regiser to clear the corresponding bits of DOE31_0 register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOECLR31_0_RESERVED26: any = '6'\nexport const GPIO_DOECLR31_0_RESERVED26_M: any = '6'\nexport const GPIO_DOECLR31_0_RESERVED26_S: any = '6'\n/**\nClears bit DOE31_0.DIO25*/\nexport const GPIO_DOECLR31_0_DIO25: any = '1'\nexport const GPIO_DOECLR31_0_DIO25_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO25_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO25_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO25_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO24*/\nexport const GPIO_DOECLR31_0_DIO24: any = '1'\nexport const GPIO_DOECLR31_0_DIO24_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO24_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO24_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO24_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO23*/\nexport const GPIO_DOECLR31_0_DIO23: any = '1'\nexport const GPIO_DOECLR31_0_DIO23_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO23_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO23_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO23_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO22*/\nexport const GPIO_DOECLR31_0_DIO22: any = '1'\nexport const GPIO_DOECLR31_0_DIO22_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO22_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO22_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO22_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO21*/\nexport const GPIO_DOECLR31_0_DIO21: any = '1'\nexport const GPIO_DOECLR31_0_DIO21_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO21_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO21_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO21_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO20*/\nexport const GPIO_DOECLR31_0_DIO20: any = '1'\nexport const GPIO_DOECLR31_0_DIO20_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO20_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO20_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO20_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO19*/\nexport const GPIO_DOECLR31_0_DIO19: any = '1'\nexport const GPIO_DOECLR31_0_DIO19_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO19_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO19_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO19_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO18*/\nexport const GPIO_DOECLR31_0_DIO18: any = '1'\nexport const GPIO_DOECLR31_0_DIO18_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO18_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO18_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO18_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO17*/\nexport const GPIO_DOECLR31_0_DIO17: any = '1'\nexport const GPIO_DOECLR31_0_DIO17_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO17_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO17_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO17_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO16*/\nexport const GPIO_DOECLR31_0_DIO16: any = '1'\nexport const GPIO_DOECLR31_0_DIO16_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO16_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO16_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO16_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO15*/\nexport const GPIO_DOECLR31_0_DIO15: any = '1'\nexport const GPIO_DOECLR31_0_DIO15_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO15_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO15_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO15_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO14*/\nexport const GPIO_DOECLR31_0_DIO14: any = '1'\nexport const GPIO_DOECLR31_0_DIO14_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO14_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO14_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO14_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO13*/\nexport const GPIO_DOECLR31_0_DIO13: any = '1'\nexport const GPIO_DOECLR31_0_DIO13_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO13_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO13_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO13_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO12*/\nexport const GPIO_DOECLR31_0_DIO12: any = '1'\nexport const GPIO_DOECLR31_0_DIO12_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO12_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO12_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO12_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO11*/\nexport const GPIO_DOECLR31_0_DIO11: any = '1'\nexport const GPIO_DOECLR31_0_DIO11_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO11_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO11_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO11_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO10*/\nexport const GPIO_DOECLR31_0_DIO10: any = '1'\nexport const GPIO_DOECLR31_0_DIO10_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO10_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO10_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO10_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO9*/\nexport const GPIO_DOECLR31_0_DIO9: any = '1'\nexport const GPIO_DOECLR31_0_DIO9_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO9_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO9_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO9_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO8*/\nexport const GPIO_DOECLR31_0_DIO8: any = '1'\nexport const GPIO_DOECLR31_0_DIO8_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO8_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO8_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO8_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO7*/\nexport const GPIO_DOECLR31_0_DIO7: any = '1'\nexport const GPIO_DOECLR31_0_DIO7_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO7_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO7_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO7_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO6*/\nexport const GPIO_DOECLR31_0_DIO6: any = '1'\nexport const GPIO_DOECLR31_0_DIO6_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO6_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO6_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO6_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO5*/\nexport const GPIO_DOECLR31_0_DIO5: any = '1'\nexport const GPIO_DOECLR31_0_DIO5_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO5_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO5_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO5_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO4*/\nexport const GPIO_DOECLR31_0_DIO4: any = '1'\nexport const GPIO_DOECLR31_0_DIO4_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO4_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO4_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO4_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO3*/\nexport const GPIO_DOECLR31_0_DIO3: any = '1'\nexport const GPIO_DOECLR31_0_DIO3_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO3_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO3_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO3_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO2*/\nexport const GPIO_DOECLR31_0_DIO2: any = '1'\nexport const GPIO_DOECLR31_0_DIO2_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO2_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO2_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO2_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO1*/\nexport const GPIO_DOECLR31_0_DIO1: any = '1'\nexport const GPIO_DOECLR31_0_DIO1_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO1_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO1_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO1_NOEFF: any = '0'\n\n/**\nClears bit DOE31_0.DIO0*/\nexport const GPIO_DOECLR31_0_DIO0: any = '1'\nexport const GPIO_DOECLR31_0_DIO0_M: any = '1'\nexport const GPIO_DOECLR31_0_DIO0_S: any = '1'\n/**\nClear*/\nexport const GPIO_DOECLR31_0_DIO0_CLR: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOECLR31_0_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER DOETGL31_0 -------- //\n\n/**\nAlias regiser to toggle the corresponding bits of DOE31_0 register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DOETGL31_0_RESERVED26: any = '6'\nexport const GPIO_DOETGL31_0_RESERVED26_M: any = '6'\nexport const GPIO_DOETGL31_0_RESERVED26_S: any = '6'\n/**\nToggles bit DOE31_0.DIO25*/\nexport const GPIO_DOETGL31_0_DIO25: any = '1'\nexport const GPIO_DOETGL31_0_DIO25_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO25_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO25_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO25_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO24*/\nexport const GPIO_DOETGL31_0_DIO24: any = '1'\nexport const GPIO_DOETGL31_0_DIO24_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO24_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO24_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO24_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO23*/\nexport const GPIO_DOETGL31_0_DIO23: any = '1'\nexport const GPIO_DOETGL31_0_DIO23_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO23_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO23_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO23_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO22*/\nexport const GPIO_DOETGL31_0_DIO22: any = '1'\nexport const GPIO_DOETGL31_0_DIO22_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO22_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO22_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO22_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO21*/\nexport const GPIO_DOETGL31_0_DIO21: any = '1'\nexport const GPIO_DOETGL31_0_DIO21_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO21_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO21_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO21_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO20*/\nexport const GPIO_DOETGL31_0_DIO20: any = '1'\nexport const GPIO_DOETGL31_0_DIO20_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO20_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO20_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO20_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO19*/\nexport const GPIO_DOETGL31_0_DIO19: any = '1'\nexport const GPIO_DOETGL31_0_DIO19_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO19_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO19_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO19_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO18*/\nexport const GPIO_DOETGL31_0_DIO18: any = '1'\nexport const GPIO_DOETGL31_0_DIO18_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO18_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO18_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO18_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO17*/\nexport const GPIO_DOETGL31_0_DIO17: any = '1'\nexport const GPIO_DOETGL31_0_DIO17_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO17_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO17_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO17_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO16*/\nexport const GPIO_DOETGL31_0_DIO16: any = '1'\nexport const GPIO_DOETGL31_0_DIO16_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO16_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO16_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO16_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO15*/\nexport const GPIO_DOETGL31_0_DIO15: any = '1'\nexport const GPIO_DOETGL31_0_DIO15_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO15_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO15_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO15_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO14*/\nexport const GPIO_DOETGL31_0_DIO14: any = '1'\nexport const GPIO_DOETGL31_0_DIO14_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO14_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO14_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO14_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO13*/\nexport const GPIO_DOETGL31_0_DIO13: any = '1'\nexport const GPIO_DOETGL31_0_DIO13_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO13_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO13_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO13_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO12*/\nexport const GPIO_DOETGL31_0_DIO12: any = '1'\nexport const GPIO_DOETGL31_0_DIO12_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO12_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO12_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO12_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO11*/\nexport const GPIO_DOETGL31_0_DIO11: any = '1'\nexport const GPIO_DOETGL31_0_DIO11_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO11_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO11_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO11_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO10*/\nexport const GPIO_DOETGL31_0_DIO10: any = '1'\nexport const GPIO_DOETGL31_0_DIO10_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO10_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO10_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO10_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO9*/\nexport const GPIO_DOETGL31_0_DIO9: any = '1'\nexport const GPIO_DOETGL31_0_DIO9_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO9_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO9_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO9_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO8*/\nexport const GPIO_DOETGL31_0_DIO8: any = '1'\nexport const GPIO_DOETGL31_0_DIO8_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO8_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO8_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO8_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO7*/\nexport const GPIO_DOETGL31_0_DIO7: any = '1'\nexport const GPIO_DOETGL31_0_DIO7_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO7_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO7_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO7_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO6*/\nexport const GPIO_DOETGL31_0_DIO6: any = '1'\nexport const GPIO_DOETGL31_0_DIO6_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO6_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO6_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO6_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO5*/\nexport const GPIO_DOETGL31_0_DIO5: any = '1'\nexport const GPIO_DOETGL31_0_DIO5_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO5_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO5_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO5_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO4*/\nexport const GPIO_DOETGL31_0_DIO4: any = '1'\nexport const GPIO_DOETGL31_0_DIO4_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO4_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO4_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO4_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO3*/\nexport const GPIO_DOETGL31_0_DIO3: any = '1'\nexport const GPIO_DOETGL31_0_DIO3_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO3_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO3_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO3_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO2*/\nexport const GPIO_DOETGL31_0_DIO2: any = '1'\nexport const GPIO_DOETGL31_0_DIO2_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO2_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO2_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO2_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO1*/\nexport const GPIO_DOETGL31_0_DIO1: any = '1'\nexport const GPIO_DOETGL31_0_DIO1_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO1_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO1_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO1_NOEFF: any = '0'\n\n/**\nToggles bit DOE31_0.DIO0*/\nexport const GPIO_DOETGL31_0_DIO0: any = '1'\nexport const GPIO_DOETGL31_0_DIO0_M: any = '1'\nexport const GPIO_DOETGL31_0_DIO0_S: any = '1'\n/**\nToggle*/\nexport const GPIO_DOETGL31_0_DIO0_TOGGLE: any = '1'\n\n/**\nNo effect*/\nexport const GPIO_DOETGL31_0_DIO0_NOEFF: any = '0'\n\n\n// -------- REGISTER DIN3_0 -------- //\n\n/**\nAlias register for byte access to DIN31_0[3:0] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN3_0_RESERVED25: any = '7'\nexport const GPIO_DIN3_0_RESERVED25_M: any = '7'\nexport const GPIO_DIN3_0_RESERVED25_S: any = '7'\n/**\nData input from DIO3*/\nexport const GPIO_DIN3_0_DIO3: any = '1'\nexport const GPIO_DIN3_0_DIO3_M: any = '1'\nexport const GPIO_DIN3_0_DIO3_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN3_0_DIO3_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN3_0_DIO3_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN3_0_RESERVED17: any = '7'\nexport const GPIO_DIN3_0_RESERVED17_M: any = '7'\nexport const GPIO_DIN3_0_RESERVED17_S: any = '7'\n/**\nData input from DIO2*/\nexport const GPIO_DIN3_0_DIO2: any = '1'\nexport const GPIO_DIN3_0_DIO2_M: any = '1'\nexport const GPIO_DIN3_0_DIO2_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN3_0_DIO2_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN3_0_DIO2_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN3_0_RESERVED9: any = '7'\nexport const GPIO_DIN3_0_RESERVED9_M: any = '7'\nexport const GPIO_DIN3_0_RESERVED9_S: any = '7'\n/**\nData input from DIO1*/\nexport const GPIO_DIN3_0_DIO1: any = '1'\nexport const GPIO_DIN3_0_DIO1_M: any = '1'\nexport const GPIO_DIN3_0_DIO1_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN3_0_DIO1_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN3_0_DIO1_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN3_0_RESERVED1: any = '7'\nexport const GPIO_DIN3_0_RESERVED1_M: any = '7'\nexport const GPIO_DIN3_0_RESERVED1_S: any = '7'\n/**\nData input from DIO0*/\nexport const GPIO_DIN3_0_DIO0: any = '1'\nexport const GPIO_DIN3_0_DIO0_M: any = '1'\nexport const GPIO_DIN3_0_DIO0_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN3_0_DIO0_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN3_0_DIO0_ZERO: any = '0'\n\n\n// -------- REGISTER DIN7_4 -------- //\n\n/**\nAlias register for byte access to DIN31_0[7:4] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN7_4_RESERVED25: any = '7'\nexport const GPIO_DIN7_4_RESERVED25_M: any = '7'\nexport const GPIO_DIN7_4_RESERVED25_S: any = '7'\n/**\nData input from DIO7*/\nexport const GPIO_DIN7_4_DIO7: any = '1'\nexport const GPIO_DIN7_4_DIO7_M: any = '1'\nexport const GPIO_DIN7_4_DIO7_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN7_4_DIO7_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN7_4_DIO7_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN7_4_RESERVED17: any = '7'\nexport const GPIO_DIN7_4_RESERVED17_M: any = '7'\nexport const GPIO_DIN7_4_RESERVED17_S: any = '7'\n/**\nData input from DIO6*/\nexport const GPIO_DIN7_4_DIO6: any = '1'\nexport const GPIO_DIN7_4_DIO6_M: any = '1'\nexport const GPIO_DIN7_4_DIO6_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN7_4_DIO6_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN7_4_DIO6_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN7_4_RESERVED9: any = '7'\nexport const GPIO_DIN7_4_RESERVED9_M: any = '7'\nexport const GPIO_DIN7_4_RESERVED9_S: any = '7'\n/**\nData input from DIO5*/\nexport const GPIO_DIN7_4_DIO5: any = '1'\nexport const GPIO_DIN7_4_DIO5_M: any = '1'\nexport const GPIO_DIN7_4_DIO5_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN7_4_DIO5_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN7_4_DIO5_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN7_4_RESERVED1: any = '7'\nexport const GPIO_DIN7_4_RESERVED1_M: any = '7'\nexport const GPIO_DIN7_4_RESERVED1_S: any = '7'\n/**\nData input from DIO4*/\nexport const GPIO_DIN7_4_DIO4: any = '1'\nexport const GPIO_DIN7_4_DIO4_M: any = '1'\nexport const GPIO_DIN7_4_DIO4_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN7_4_DIO4_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN7_4_DIO4_ZERO: any = '0'\n\n\n// -------- REGISTER DIN11_8 -------- //\n\n/**\nAlias register for byte access to DIN31_0[11:8] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN11_8_RESERVED25: any = '7'\nexport const GPIO_DIN11_8_RESERVED25_M: any = '7'\nexport const GPIO_DIN11_8_RESERVED25_S: any = '7'\n/**\nData input from DIO11*/\nexport const GPIO_DIN11_8_DIO11: any = '1'\nexport const GPIO_DIN11_8_DIO11_M: any = '1'\nexport const GPIO_DIN11_8_DIO11_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN11_8_DIO11_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN11_8_DIO11_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN11_8_RESERVED17: any = '7'\nexport const GPIO_DIN11_8_RESERVED17_M: any = '7'\nexport const GPIO_DIN11_8_RESERVED17_S: any = '7'\n/**\nData input from DIO10*/\nexport const GPIO_DIN11_8_DIO10: any = '1'\nexport const GPIO_DIN11_8_DIO10_M: any = '1'\nexport const GPIO_DIN11_8_DIO10_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN11_8_DIO10_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN11_8_DIO10_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN11_8_RESERVED9: any = '7'\nexport const GPIO_DIN11_8_RESERVED9_M: any = '7'\nexport const GPIO_DIN11_8_RESERVED9_S: any = '7'\n/**\nData input from DIO9*/\nexport const GPIO_DIN11_8_DIO9: any = '1'\nexport const GPIO_DIN11_8_DIO9_M: any = '1'\nexport const GPIO_DIN11_8_DIO9_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN11_8_DIO9_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN11_8_DIO9_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN11_8_RESERVED1: any = '7'\nexport const GPIO_DIN11_8_RESERVED1_M: any = '7'\nexport const GPIO_DIN11_8_RESERVED1_S: any = '7'\n/**\nData input from DIO8*/\nexport const GPIO_DIN11_8_DIO8: any = '1'\nexport const GPIO_DIN11_8_DIO8_M: any = '1'\nexport const GPIO_DIN11_8_DIO8_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN11_8_DIO8_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN11_8_DIO8_ZERO: any = '0'\n\n\n// -------- REGISTER DIN15_12 -------- //\n\n/**\nAlias register for byte access to DIN31_0[15:12] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN15_12_RESERVED25: any = '7'\nexport const GPIO_DIN15_12_RESERVED25_M: any = '7'\nexport const GPIO_DIN15_12_RESERVED25_S: any = '7'\n/**\nData input from DIO15*/\nexport const GPIO_DIN15_12_DIO15: any = '1'\nexport const GPIO_DIN15_12_DIO15_M: any = '1'\nexport const GPIO_DIN15_12_DIO15_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN15_12_DIO15_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN15_12_DIO15_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN15_12_RESERVED17: any = '7'\nexport const GPIO_DIN15_12_RESERVED17_M: any = '7'\nexport const GPIO_DIN15_12_RESERVED17_S: any = '7'\n/**\nData input from DIO14*/\nexport const GPIO_DIN15_12_DIO14: any = '1'\nexport const GPIO_DIN15_12_DIO14_M: any = '1'\nexport const GPIO_DIN15_12_DIO14_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN15_12_DIO14_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN15_12_DIO14_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN15_12_RESERVED9: any = '7'\nexport const GPIO_DIN15_12_RESERVED9_M: any = '7'\nexport const GPIO_DIN15_12_RESERVED9_S: any = '7'\n/**\nData input from DIO13*/\nexport const GPIO_DIN15_12_DIO13: any = '1'\nexport const GPIO_DIN15_12_DIO13_M: any = '1'\nexport const GPIO_DIN15_12_DIO13_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN15_12_DIO13_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN15_12_DIO13_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN15_12_RESERVED1: any = '7'\nexport const GPIO_DIN15_12_RESERVED1_M: any = '7'\nexport const GPIO_DIN15_12_RESERVED1_S: any = '7'\n/**\nData input from DIO12*/\nexport const GPIO_DIN15_12_DIO12: any = '1'\nexport const GPIO_DIN15_12_DIO12_M: any = '1'\nexport const GPIO_DIN15_12_DIO12_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN15_12_DIO12_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN15_12_DIO12_ZERO: any = '0'\n\n\n// -------- REGISTER DIN19_16 -------- //\n\n/**\nAlias register for byte access to DIN31_0[19:16] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN19_16_RESERVED25: any = '7'\nexport const GPIO_DIN19_16_RESERVED25_M: any = '7'\nexport const GPIO_DIN19_16_RESERVED25_S: any = '7'\n/**\nData input from DIO19*/\nexport const GPIO_DIN19_16_DIO19: any = '1'\nexport const GPIO_DIN19_16_DIO19_M: any = '1'\nexport const GPIO_DIN19_16_DIO19_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN19_16_DIO19_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN19_16_DIO19_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN19_16_RESERVED17: any = '7'\nexport const GPIO_DIN19_16_RESERVED17_M: any = '7'\nexport const GPIO_DIN19_16_RESERVED17_S: any = '7'\n/**\nData input from DIO18*/\nexport const GPIO_DIN19_16_DIO18: any = '1'\nexport const GPIO_DIN19_16_DIO18_M: any = '1'\nexport const GPIO_DIN19_16_DIO18_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN19_16_DIO18_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN19_16_DIO18_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN19_16_RESERVED9: any = '7'\nexport const GPIO_DIN19_16_RESERVED9_M: any = '7'\nexport const GPIO_DIN19_16_RESERVED9_S: any = '7'\n/**\nData input from DIO17*/\nexport const GPIO_DIN19_16_DIO17: any = '1'\nexport const GPIO_DIN19_16_DIO17_M: any = '1'\nexport const GPIO_DIN19_16_DIO17_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN19_16_DIO17_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN19_16_DIO17_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN19_16_RESERVED1: any = '7'\nexport const GPIO_DIN19_16_RESERVED1_M: any = '7'\nexport const GPIO_DIN19_16_RESERVED1_S: any = '7'\n/**\nData input from DIO16*/\nexport const GPIO_DIN19_16_DIO16: any = '1'\nexport const GPIO_DIN19_16_DIO16_M: any = '1'\nexport const GPIO_DIN19_16_DIO16_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN19_16_DIO16_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN19_16_DIO16_ZERO: any = '0'\n\n\n// -------- REGISTER DIN23_20 -------- //\n\n/**\nAlias register for byte access to DIN31_0[23:20] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN23_20_RESERVED25: any = '7'\nexport const GPIO_DIN23_20_RESERVED25_M: any = '7'\nexport const GPIO_DIN23_20_RESERVED25_S: any = '7'\n/**\nData input from DIO23*/\nexport const GPIO_DIN23_20_DIO23: any = '1'\nexport const GPIO_DIN23_20_DIO23_M: any = '1'\nexport const GPIO_DIN23_20_DIO23_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN23_20_DIO23_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN23_20_DIO23_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN23_20_RESERVED17: any = '7'\nexport const GPIO_DIN23_20_RESERVED17_M: any = '7'\nexport const GPIO_DIN23_20_RESERVED17_S: any = '7'\n/**\nData input from DIO22*/\nexport const GPIO_DIN23_20_DIO22: any = '1'\nexport const GPIO_DIN23_20_DIO22_M: any = '1'\nexport const GPIO_DIN23_20_DIO22_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN23_20_DIO22_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN23_20_DIO22_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN23_20_RESERVED9: any = '7'\nexport const GPIO_DIN23_20_RESERVED9_M: any = '7'\nexport const GPIO_DIN23_20_RESERVED9_S: any = '7'\n/**\nData input from DIO21*/\nexport const GPIO_DIN23_20_DIO21: any = '1'\nexport const GPIO_DIN23_20_DIO21_M: any = '1'\nexport const GPIO_DIN23_20_DIO21_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN23_20_DIO21_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN23_20_DIO21_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN23_20_RESERVED1: any = '7'\nexport const GPIO_DIN23_20_RESERVED1_M: any = '7'\nexport const GPIO_DIN23_20_RESERVED1_S: any = '7'\n/**\nData input from DIO20*/\nexport const GPIO_DIN23_20_DIO20: any = '1'\nexport const GPIO_DIN23_20_DIO20_M: any = '1'\nexport const GPIO_DIN23_20_DIO20_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN23_20_DIO20_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN23_20_DIO20_ZERO: any = '0'\n\n\n// -------- REGISTER DIN27_24 -------- //\n\n/**\nAlias register for byte access to DIN31_0[27:24] bits.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN27_24_RESERVED9: any = '23'\nexport const GPIO_DIN27_24_RESERVED9_M: any = '23'\nexport const GPIO_DIN27_24_RESERVED9_S: any = '23'\n/**\nData input from DIO25*/\nexport const GPIO_DIN27_24_DIO25: any = '1'\nexport const GPIO_DIN27_24_DIO25_M: any = '1'\nexport const GPIO_DIN27_24_DIO25_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN27_24_DIO25_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN27_24_DIO25_ZERO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN27_24_RESERVED1: any = '7'\nexport const GPIO_DIN27_24_RESERVED1_M: any = '7'\nexport const GPIO_DIN27_24_RESERVED1_S: any = '7'\n/**\nData input from DIO24*/\nexport const GPIO_DIN27_24_DIO24: any = '1'\nexport const GPIO_DIN27_24_DIO24_M: any = '1'\nexport const GPIO_DIN27_24_DIO24_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN27_24_DIO24_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN27_24_DIO24_ZERO: any = '0'\n\n\n// -------- REGISTER DIN31_0 -------- //\n\n/**\nData input from DIO 31 to 0 pins.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_DIN31_0_RESERVED26: any = '6'\nexport const GPIO_DIN31_0_RESERVED26_M: any = '6'\nexport const GPIO_DIN31_0_RESERVED26_S: any = '6'\n/**\nData input from DIO25*/\nexport const GPIO_DIN31_0_DIO25: any = '1'\nexport const GPIO_DIN31_0_DIO25_M: any = '1'\nexport const GPIO_DIN31_0_DIO25_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO25_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO25_ZERO: any = '0'\n\n/**\nData input from DIO24*/\nexport const GPIO_DIN31_0_DIO24: any = '1'\nexport const GPIO_DIN31_0_DIO24_M: any = '1'\nexport const GPIO_DIN31_0_DIO24_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO24_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO24_ZERO: any = '0'\n\n/**\nData input from DIO23*/\nexport const GPIO_DIN31_0_DIO23: any = '1'\nexport const GPIO_DIN31_0_DIO23_M: any = '1'\nexport const GPIO_DIN31_0_DIO23_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO23_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO23_ZERO: any = '0'\n\n/**\nData input from DIO22*/\nexport const GPIO_DIN31_0_DIO22: any = '1'\nexport const GPIO_DIN31_0_DIO22_M: any = '1'\nexport const GPIO_DIN31_0_DIO22_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO22_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO22_ZERO: any = '0'\n\n/**\nData input from DIO21*/\nexport const GPIO_DIN31_0_DIO21: any = '1'\nexport const GPIO_DIN31_0_DIO21_M: any = '1'\nexport const GPIO_DIN31_0_DIO21_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO21_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO21_ZERO: any = '0'\n\n/**\nData input from DIO20*/\nexport const GPIO_DIN31_0_DIO20: any = '1'\nexport const GPIO_DIN31_0_DIO20_M: any = '1'\nexport const GPIO_DIN31_0_DIO20_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO20_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO20_ZERO: any = '0'\n\n/**\nData input from DIO19*/\nexport const GPIO_DIN31_0_DIO19: any = '1'\nexport const GPIO_DIN31_0_DIO19_M: any = '1'\nexport const GPIO_DIN31_0_DIO19_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO19_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO19_ZERO: any = '0'\n\n/**\nData input from DIO18*/\nexport const GPIO_DIN31_0_DIO18: any = '1'\nexport const GPIO_DIN31_0_DIO18_M: any = '1'\nexport const GPIO_DIN31_0_DIO18_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO18_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO18_ZERO: any = '0'\n\n/**\nData input from DIO17*/\nexport const GPIO_DIN31_0_DIO17: any = '1'\nexport const GPIO_DIN31_0_DIO17_M: any = '1'\nexport const GPIO_DIN31_0_DIO17_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO17_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO17_ZERO: any = '0'\n\n/**\nData input from DIO16*/\nexport const GPIO_DIN31_0_DIO16: any = '1'\nexport const GPIO_DIN31_0_DIO16_M: any = '1'\nexport const GPIO_DIN31_0_DIO16_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO16_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO16_ZERO: any = '0'\n\n/**\nData input from DIO15*/\nexport const GPIO_DIN31_0_DIO15: any = '1'\nexport const GPIO_DIN31_0_DIO15_M: any = '1'\nexport const GPIO_DIN31_0_DIO15_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO15_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO15_ZERO: any = '0'\n\n/**\nData input from DIO14*/\nexport const GPIO_DIN31_0_DIO14: any = '1'\nexport const GPIO_DIN31_0_DIO14_M: any = '1'\nexport const GPIO_DIN31_0_DIO14_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO14_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO14_ZERO: any = '0'\n\n/**\nData input from DIO13*/\nexport const GPIO_DIN31_0_DIO13: any = '1'\nexport const GPIO_DIN31_0_DIO13_M: any = '1'\nexport const GPIO_DIN31_0_DIO13_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO13_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO13_ZERO: any = '0'\n\n/**\nData input from DIO12*/\nexport const GPIO_DIN31_0_DIO12: any = '1'\nexport const GPIO_DIN31_0_DIO12_M: any = '1'\nexport const GPIO_DIN31_0_DIO12_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO12_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO12_ZERO: any = '0'\n\n/**\nData input from DIO11*/\nexport const GPIO_DIN31_0_DIO11: any = '1'\nexport const GPIO_DIN31_0_DIO11_M: any = '1'\nexport const GPIO_DIN31_0_DIO11_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO11_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO11_ZERO: any = '0'\n\n/**\nData input from DIO10*/\nexport const GPIO_DIN31_0_DIO10: any = '1'\nexport const GPIO_DIN31_0_DIO10_M: any = '1'\nexport const GPIO_DIN31_0_DIO10_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO10_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO10_ZERO: any = '0'\n\n/**\nData input from DIO9*/\nexport const GPIO_DIN31_0_DIO9: any = '1'\nexport const GPIO_DIN31_0_DIO9_M: any = '1'\nexport const GPIO_DIN31_0_DIO9_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO9_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO9_ZERO: any = '0'\n\n/**\nData input from DIO8*/\nexport const GPIO_DIN31_0_DIO8: any = '1'\nexport const GPIO_DIN31_0_DIO8_M: any = '1'\nexport const GPIO_DIN31_0_DIO8_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO8_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO8_ZERO: any = '0'\n\n/**\nData input from DIO7*/\nexport const GPIO_DIN31_0_DIO7: any = '1'\nexport const GPIO_DIN31_0_DIO7_M: any = '1'\nexport const GPIO_DIN31_0_DIO7_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO7_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO7_ZERO: any = '0'\n\n/**\nData input from DIO6*/\nexport const GPIO_DIN31_0_DIO6: any = '1'\nexport const GPIO_DIN31_0_DIO6_M: any = '1'\nexport const GPIO_DIN31_0_DIO6_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO6_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO6_ZERO: any = '0'\n\n/**\nData input from DIO5*/\nexport const GPIO_DIN31_0_DIO5: any = '1'\nexport const GPIO_DIN31_0_DIO5_M: any = '1'\nexport const GPIO_DIN31_0_DIO5_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO5_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO5_ZERO: any = '0'\n\n/**\nData input from DIO4*/\nexport const GPIO_DIN31_0_DIO4: any = '1'\nexport const GPIO_DIN31_0_DIO4_M: any = '1'\nexport const GPIO_DIN31_0_DIO4_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO4_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO4_ZERO: any = '0'\n\n/**\nData input from DIO3*/\nexport const GPIO_DIN31_0_DIO3: any = '1'\nexport const GPIO_DIN31_0_DIO3_M: any = '1'\nexport const GPIO_DIN31_0_DIO3_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO3_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO3_ZERO: any = '0'\n\n/**\nData input from DIO2*/\nexport const GPIO_DIN31_0_DIO2: any = '1'\nexport const GPIO_DIN31_0_DIO2_M: any = '1'\nexport const GPIO_DIN31_0_DIO2_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO2_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO2_ZERO: any = '0'\n\n/**\nData input from DIO1*/\nexport const GPIO_DIN31_0_DIO1: any = '1'\nexport const GPIO_DIN31_0_DIO1_M: any = '1'\nexport const GPIO_DIN31_0_DIO1_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO1_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO1_ZERO: any = '0'\n\n/**\nData input from DIO0*/\nexport const GPIO_DIN31_0_DIO0: any = '1'\nexport const GPIO_DIN31_0_DIO0_M: any = '1'\nexport const GPIO_DIN31_0_DIO0_S: any = '1'\n/**\nInput value is 1*/\nexport const GPIO_DIN31_0_DIO0_ONE: any = '1'\n\n/**\nInput value is 0*/\nexport const GPIO_DIN31_0_DIO0_ZERO: any = '0'\n\n\n// -------- REGISTER EVTCFG -------- //\n\n/**\nEvent configuration. This register is used to select DIO for GPIO to publish event on SVT event fabric (EVTSVT). It also contains enable bit that is used to mask the event.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_EVTCFG_RESERVED9: any = '23'\nexport const GPIO_EVTCFG_RESERVED9_M: any = '23'\nexport const GPIO_EVTCFG_RESERVED9_S: any = '23'\n/**\nEnables GPIO to publish edge qualified selected DIO event on SVT event fabric. \n\nDesign note: The edge detector flop is cleared automatically for the selected DIO once the event is published.*/\nexport const GPIO_EVTCFG_EVTEN: any = '1'\nexport const GPIO_EVTCFG_EVTEN_M: any = '1'\nexport const GPIO_EVTCFG_EVTEN_S: any = '1'\n/**\nEnable*/\nexport const GPIO_EVTCFG_EVTEN_EN: any = '1'\n\n/**\nDisable*/\nexport const GPIO_EVTCFG_EVTEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const GPIO_EVTCFG_RESERVED6: any = '2'\nexport const GPIO_EVTCFG_RESERVED6_M: any = '2'\nexport const GPIO_EVTCFG_RESERVED6_S: any = '2'\n/**\nThis is used to select DIO for event generation. For example, DIOSEL = 0x0 selects DIO0 and DIOSEL = 0x8 selects DIO8.*/\nexport const GPIO_EVTCFG_DIOSEL: any = '6'\nexport const GPIO_EVTCFG_DIOSEL_M: any = '6'\nexport const GPIO_EVTCFG_DIOSEL_S: any = '6'\n/**\nMaximum value*/\nexport const GPIO_EVTCFG_DIOSEL_MAXIMUM: any = '63'\n\n/**\nMinimum value*/\nexport const GPIO_EVTCFG_DIOSEL_MINIMUM: any = '0'\n\n\n// -------- MODULE IOC -------- //\n\nexport interface IOC_t {\n    DESC: em.$Reg\n    DESCEX: em.$Reg\n    IOC0: em.$Reg\n    IOC1: em.$Reg\n    IOC2: em.$Reg\n    IOC3: em.$Reg\n    IOC4: em.$Reg\n    IOC5: em.$Reg\n    IOC6: em.$Reg\n    IOC7: em.$Reg\n    IOC8: em.$Reg\n    IOC9: em.$Reg\n    IOC10: em.$Reg\n    IOC11: em.$Reg\n    IOC12: em.$Reg\n    IOC13: em.$Reg\n    IOC14: em.$Reg\n    IOC15: em.$Reg\n    IOC16: em.$Reg\n    IOC17: em.$Reg\n    IOC18: em.$Reg\n    IOC19: em.$Reg\n    IOC20: em.$Reg\n    IOC21: em.$Reg\n    IOC22: em.$Reg\n    IOC23: em.$Reg\n    IOC24: em.$Reg\n    IOC25: em.$Reg\n    DTBCFG: em.$Reg\n    DTBOE: em.$Reg\n    EVTCFG: em.$Reg\n    TEST: em.$Reg\n    DTBSTAT: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription Register. This register provides IP module ID, revision information, instance index and standard MMR registers offset.*/\n/**\nModule identifier used to uniquely identify this IP.*/\nexport const IOC_DESC_MODID: any = '16'\nexport const IOC_DESC_MODID_M: any = '16'\nexport const IOC_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set of from aggregated IRQ registers till DTB.\n\n\n0: Standard IP MMRs do not exist\n\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)*/\nexport const IOC_DESC_STDIPOFF: any = '4'\nexport const IOC_DESC_STDIPOFF_M: any = '4'\nexport const IOC_DESC_STDIPOFF_S: any = '4'\n/**\nIP Instance ID number. If multiple instances of IP exist in the device, this field can identify the instance number (0-15).*/\nexport const IOC_DESC_INSTIDX: any = '4'\nexport const IOC_DESC_INSTIDX_M: any = '4'\nexport const IOC_DESC_INSTIDX_S: any = '4'\n/**\nMajor revision of IP (0-15).*/\nexport const IOC_DESC_MAJREV: any = '4'\nexport const IOC_DESC_MAJREV_M: any = '4'\nexport const IOC_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP (0-15).*/\nexport const IOC_DESC_MINREV: any = '4'\nexport const IOC_DESC_MINREV_M: any = '4'\nexport const IOC_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER DESCEX -------- //\n\n/**\nExtended Description Register. This register provides configuration details of the IP to software drivers and end users.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_DESCEX_RESERVED16: any = '16'\nexport const IOC_DESCEX_RESERVED16_M: any = '16'\nexport const IOC_DESCEX_RESERVED16_S: any = '16'\n/**\nNumber of DTB IOs supported. Total DTB IOs supported is NUMDTBIO value +1.*/\nexport const IOC_DESCEX_NUMDTBIO: any = '4'\nexport const IOC_DESCEX_NUMDTBIO_M: any = '4'\nexport const IOC_DESCEX_NUMDTBIO_S: any = '4'\n/**\nHighest possible value*/\nexport const IOC_DESCEX_NUMDTBIO_MAXIMUM: any = '15'\n\n/**\nSmallest value*/\nexport const IOC_DESCEX_NUMDTBIO_MINIMUM: any = '0'\n\n/**\nNumber of high drive IOs supported. Total high drive IOs supported is NUMHDIO value +1.*/\nexport const IOC_DESCEX_NUMHDIO: any = '5'\nexport const IOC_DESCEX_NUMHDIO_M: any = '5'\nexport const IOC_DESCEX_NUMHDIO_S: any = '5'\n/**\nHighest possible value*/\nexport const IOC_DESCEX_NUMHDIO_MAXIMUM: any = '31'\n\n/**\nSmallest value*/\nexport const IOC_DESCEX_NUMHDIO_MINIMUM: any = '0'\n\n/**\nHigh drive IO supported by IOC.*/\nexport const IOC_DESCEX_HDIO: any = '1'\nexport const IOC_DESCEX_HDIO_M: any = '1'\nexport const IOC_DESCEX_HDIO_S: any = '1'\n/**\nHD IO supported by IOC*/\nexport const IOC_DESCEX_HDIO_PRESENT: any = '1'\n\n/**\nHD IO not supported by IOC*/\nexport const IOC_DESCEX_HDIO_ABSENT: any = '0'\n\n/**\nNumber of DIOs supported. Total DIOs supported is NUMDIO value +1.*/\nexport const IOC_DESCEX_NUMDIO: any = '6'\nexport const IOC_DESCEX_NUMDIO_M: any = '6'\nexport const IOC_DESCEX_NUMDIO_S: any = '6'\n/**\nHighest possible value*/\nexport const IOC_DESCEX_NUMDIO_MAXIMUM: any = '63'\n\n/**\nSmallest value*/\nexport const IOC_DESCEX_NUMDIO_MINIMUM: any = '0'\n\n\n// -------- REGISTER IOC0 -------- //\n\n/**\nConfiguration of DIO0*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC0_RESERVED31: any = '1'\nexport const IOC_IOC0_RESERVED31_M: any = '1'\nexport const IOC_IOC0_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC0_HYSTEN: any = '1'\nexport const IOC_IOC0_HYSTEN_M: any = '1'\nexport const IOC_IOC0_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC0_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC0_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC0_INPEN: any = '1'\nexport const IOC_IOC0_INPEN_M: any = '1'\nexport const IOC_IOC0_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC0_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC0_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC0_RESERVED27: any = '2'\nexport const IOC_IOC0_RESERVED27_M: any = '2'\nexport const IOC_IOC0_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC0_IOMODE: any = '3'\nexport const IOC_IOC0_IOMODE_M: any = '3'\nexport const IOC_IOC0_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC0_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC0_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC0_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC0_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC0_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC0_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC0_RESERVED22: any = '2'\nexport const IOC_IOC0_RESERVED22_M: any = '2'\nexport const IOC_IOC0_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC0_WUCFGSD: any = '2'\nexport const IOC_IOC0_WUCFGSD_M: any = '2'\nexport const IOC_IOC0_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC0_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC0_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC0_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC0_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC0_RESERVED19: any = '1'\nexport const IOC_IOC0_RESERVED19_M: any = '1'\nexport const IOC_IOC0_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC0_WUENSB: any = '1'\nexport const IOC_IOC0_WUENSB_M: any = '1'\nexport const IOC_IOC0_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC0_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC0_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC0_EDGEDET: any = '2'\nexport const IOC_IOC0_EDGEDET_M: any = '2'\nexport const IOC_IOC0_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC0_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC0_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC0_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC0_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC0_RESERVED15: any = '1'\nexport const IOC_IOC0_RESERVED15_M: any = '1'\nexport const IOC_IOC0_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC0_PULLCTL: any = '2'\nexport const IOC_IOC0_PULLCTL_M: any = '2'\nexport const IOC_IOC0_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC0_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC0_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC0_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC0_RESERVED3: any = '10'\nexport const IOC_IOC0_RESERVED3_M: any = '10'\nexport const IOC_IOC0_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO0*/\nexport const IOC_IOC0_PORTCFG: any = '3'\nexport const IOC_IOC0_PORTCFG_M: any = '3'\nexport const IOC_IOC0_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC0_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC0_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC0_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC0_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC0_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC0_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC0_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC0_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC1 -------- //\n\n/**\nConfiguration of DIO1*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC1_RESERVED31: any = '1'\nexport const IOC_IOC1_RESERVED31_M: any = '1'\nexport const IOC_IOC1_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC1_HYSTEN: any = '1'\nexport const IOC_IOC1_HYSTEN_M: any = '1'\nexport const IOC_IOC1_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC1_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC1_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC1_INPEN: any = '1'\nexport const IOC_IOC1_INPEN_M: any = '1'\nexport const IOC_IOC1_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC1_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC1_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC1_RESERVED27: any = '2'\nexport const IOC_IOC1_RESERVED27_M: any = '2'\nexport const IOC_IOC1_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC1_IOMODE: any = '3'\nexport const IOC_IOC1_IOMODE_M: any = '3'\nexport const IOC_IOC1_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC1_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC1_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC1_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC1_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC1_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC1_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC1_RESERVED22: any = '2'\nexport const IOC_IOC1_RESERVED22_M: any = '2'\nexport const IOC_IOC1_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC1_WUCFGSD: any = '2'\nexport const IOC_IOC1_WUCFGSD_M: any = '2'\nexport const IOC_IOC1_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC1_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC1_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC1_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC1_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC1_RESERVED19: any = '1'\nexport const IOC_IOC1_RESERVED19_M: any = '1'\nexport const IOC_IOC1_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC1_WUENSB: any = '1'\nexport const IOC_IOC1_WUENSB_M: any = '1'\nexport const IOC_IOC1_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC1_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC1_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC1_EDGEDET: any = '2'\nexport const IOC_IOC1_EDGEDET_M: any = '2'\nexport const IOC_IOC1_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC1_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC1_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC1_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC1_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC1_RESERVED15: any = '1'\nexport const IOC_IOC1_RESERVED15_M: any = '1'\nexport const IOC_IOC1_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC1_PULLCTL: any = '2'\nexport const IOC_IOC1_PULLCTL_M: any = '2'\nexport const IOC_IOC1_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC1_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC1_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC1_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC1_RESERVED3: any = '10'\nexport const IOC_IOC1_RESERVED3_M: any = '10'\nexport const IOC_IOC1_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO1*/\nexport const IOC_IOC1_PORTCFG: any = '3'\nexport const IOC_IOC1_PORTCFG_M: any = '3'\nexport const IOC_IOC1_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC1_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC1_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC1_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC1_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC1_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC1_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC1_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC1_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC2 -------- //\n\n/**\nSelects usage of DIO2*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC2_RESERVED31: any = '1'\nexport const IOC_IOC2_RESERVED31_M: any = '1'\nexport const IOC_IOC2_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC2_HYSTEN: any = '1'\nexport const IOC_IOC2_HYSTEN_M: any = '1'\nexport const IOC_IOC2_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC2_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC2_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC2_INPEN: any = '1'\nexport const IOC_IOC2_INPEN_M: any = '1'\nexport const IOC_IOC2_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC2_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC2_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC2_RESERVED27: any = '2'\nexport const IOC_IOC2_RESERVED27_M: any = '2'\nexport const IOC_IOC2_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC2_IOMODE: any = '3'\nexport const IOC_IOC2_IOMODE_M: any = '3'\nexport const IOC_IOC2_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC2_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC2_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC2_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC2_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC2_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC2_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC2_RESERVED22: any = '2'\nexport const IOC_IOC2_RESERVED22_M: any = '2'\nexport const IOC_IOC2_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC2_WUCFGSD: any = '2'\nexport const IOC_IOC2_WUCFGSD_M: any = '2'\nexport const IOC_IOC2_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC2_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC2_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC2_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC2_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC2_RESERVED19: any = '1'\nexport const IOC_IOC2_RESERVED19_M: any = '1'\nexport const IOC_IOC2_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC2_WUENSB: any = '1'\nexport const IOC_IOC2_WUENSB_M: any = '1'\nexport const IOC_IOC2_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC2_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC2_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC2_EDGEDET: any = '2'\nexport const IOC_IOC2_EDGEDET_M: any = '2'\nexport const IOC_IOC2_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC2_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC2_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC2_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC2_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC2_RESERVED15: any = '1'\nexport const IOC_IOC2_RESERVED15_M: any = '1'\nexport const IOC_IOC2_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC2_PULLCTL: any = '2'\nexport const IOC_IOC2_PULLCTL_M: any = '2'\nexport const IOC_IOC2_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC2_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC2_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC2_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC2_RESERVED3: any = '10'\nexport const IOC_IOC2_RESERVED3_M: any = '10'\nexport const IOC_IOC2_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO2*/\nexport const IOC_IOC2_PORTCFG: any = '3'\nexport const IOC_IOC2_PORTCFG_M: any = '3'\nexport const IOC_IOC2_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC2_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC2_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC2_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC2_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC2_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC2_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC2_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC2_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC3 -------- //\n\n/**\nConfiguration of DIO3*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC3_RESERVED31: any = '1'\nexport const IOC_IOC3_RESERVED31_M: any = '1'\nexport const IOC_IOC3_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC3_HYSTEN: any = '1'\nexport const IOC_IOC3_HYSTEN_M: any = '1'\nexport const IOC_IOC3_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC3_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC3_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC3_INPEN: any = '1'\nexport const IOC_IOC3_INPEN_M: any = '1'\nexport const IOC_IOC3_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC3_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC3_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC3_RESERVED27: any = '2'\nexport const IOC_IOC3_RESERVED27_M: any = '2'\nexport const IOC_IOC3_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC3_IOMODE: any = '3'\nexport const IOC_IOC3_IOMODE_M: any = '3'\nexport const IOC_IOC3_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC3_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC3_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC3_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC3_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC3_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC3_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC3_RESERVED22: any = '2'\nexport const IOC_IOC3_RESERVED22_M: any = '2'\nexport const IOC_IOC3_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC3_WUCFGSD: any = '2'\nexport const IOC_IOC3_WUCFGSD_M: any = '2'\nexport const IOC_IOC3_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC3_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC3_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC3_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC3_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC3_RESERVED19: any = '1'\nexport const IOC_IOC3_RESERVED19_M: any = '1'\nexport const IOC_IOC3_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC3_WUENSB: any = '1'\nexport const IOC_IOC3_WUENSB_M: any = '1'\nexport const IOC_IOC3_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC3_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC3_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC3_EDGEDET: any = '2'\nexport const IOC_IOC3_EDGEDET_M: any = '2'\nexport const IOC_IOC3_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC3_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC3_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC3_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC3_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC3_RESERVED15: any = '1'\nexport const IOC_IOC3_RESERVED15_M: any = '1'\nexport const IOC_IOC3_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC3_PULLCTL: any = '2'\nexport const IOC_IOC3_PULLCTL_M: any = '2'\nexport const IOC_IOC3_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC3_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC3_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC3_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC3_RESERVED3: any = '10'\nexport const IOC_IOC3_RESERVED3_M: any = '10'\nexport const IOC_IOC3_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO3*/\nexport const IOC_IOC3_PORTCFG: any = '3'\nexport const IOC_IOC3_PORTCFG_M: any = '3'\nexport const IOC_IOC3_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC3_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC3_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC3_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC3_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC3_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC3_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC3_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC3_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC4 -------- //\n\n/**\nConfiguration of DIO4*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC4_RESERVED31: any = '1'\nexport const IOC_IOC4_RESERVED31_M: any = '1'\nexport const IOC_IOC4_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC4_HYSTEN: any = '1'\nexport const IOC_IOC4_HYSTEN_M: any = '1'\nexport const IOC_IOC4_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC4_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC4_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC4_INPEN: any = '1'\nexport const IOC_IOC4_INPEN_M: any = '1'\nexport const IOC_IOC4_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC4_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC4_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC4_RESERVED27: any = '2'\nexport const IOC_IOC4_RESERVED27_M: any = '2'\nexport const IOC_IOC4_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC4_IOMODE: any = '3'\nexport const IOC_IOC4_IOMODE_M: any = '3'\nexport const IOC_IOC4_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC4_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC4_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC4_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC4_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC4_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC4_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC4_RESERVED22: any = '2'\nexport const IOC_IOC4_RESERVED22_M: any = '2'\nexport const IOC_IOC4_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC4_WUCFGSD: any = '2'\nexport const IOC_IOC4_WUCFGSD_M: any = '2'\nexport const IOC_IOC4_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC4_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC4_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC4_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC4_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC4_RESERVED19: any = '1'\nexport const IOC_IOC4_RESERVED19_M: any = '1'\nexport const IOC_IOC4_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC4_WUENSB: any = '1'\nexport const IOC_IOC4_WUENSB_M: any = '1'\nexport const IOC_IOC4_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC4_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC4_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC4_EDGEDET: any = '2'\nexport const IOC_IOC4_EDGEDET_M: any = '2'\nexport const IOC_IOC4_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC4_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC4_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC4_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC4_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC4_RESERVED15: any = '1'\nexport const IOC_IOC4_RESERVED15_M: any = '1'\nexport const IOC_IOC4_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC4_PULLCTL: any = '2'\nexport const IOC_IOC4_PULLCTL_M: any = '2'\nexport const IOC_IOC4_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC4_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC4_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC4_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC4_RESERVED3: any = '10'\nexport const IOC_IOC4_RESERVED3_M: any = '10'\nexport const IOC_IOC4_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO4*/\nexport const IOC_IOC4_PORTCFG: any = '3'\nexport const IOC_IOC4_PORTCFG_M: any = '3'\nexport const IOC_IOC4_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC4_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC4_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC4_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC4_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC4_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC4_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC4_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC4_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC5 -------- //\n\n/**\nConfiguration of DIO5*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC5_RESERVED31: any = '1'\nexport const IOC_IOC5_RESERVED31_M: any = '1'\nexport const IOC_IOC5_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC5_HYSTEN: any = '1'\nexport const IOC_IOC5_HYSTEN_M: any = '1'\nexport const IOC_IOC5_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC5_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC5_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC5_INPEN: any = '1'\nexport const IOC_IOC5_INPEN_M: any = '1'\nexport const IOC_IOC5_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC5_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC5_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC5_RESERVED27: any = '2'\nexport const IOC_IOC5_RESERVED27_M: any = '2'\nexport const IOC_IOC5_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC5_IOMODE: any = '3'\nexport const IOC_IOC5_IOMODE_M: any = '3'\nexport const IOC_IOC5_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC5_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC5_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC5_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC5_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC5_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC5_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC5_RESERVED22: any = '2'\nexport const IOC_IOC5_RESERVED22_M: any = '2'\nexport const IOC_IOC5_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC5_WUCFGSD: any = '2'\nexport const IOC_IOC5_WUCFGSD_M: any = '2'\nexport const IOC_IOC5_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC5_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC5_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC5_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC5_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC5_RESERVED19: any = '1'\nexport const IOC_IOC5_RESERVED19_M: any = '1'\nexport const IOC_IOC5_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC5_WUENSB: any = '1'\nexport const IOC_IOC5_WUENSB_M: any = '1'\nexport const IOC_IOC5_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC5_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC5_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC5_EDGEDET: any = '2'\nexport const IOC_IOC5_EDGEDET_M: any = '2'\nexport const IOC_IOC5_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC5_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC5_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC5_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC5_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC5_RESERVED15: any = '1'\nexport const IOC_IOC5_RESERVED15_M: any = '1'\nexport const IOC_IOC5_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC5_PULLCTL: any = '2'\nexport const IOC_IOC5_PULLCTL_M: any = '2'\nexport const IOC_IOC5_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC5_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC5_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC5_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC5_RESERVED3: any = '10'\nexport const IOC_IOC5_RESERVED3_M: any = '10'\nexport const IOC_IOC5_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO5*/\nexport const IOC_IOC5_PORTCFG: any = '3'\nexport const IOC_IOC5_PORTCFG_M: any = '3'\nexport const IOC_IOC5_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC5_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC5_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC5_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC5_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC5_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC5_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC5_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC5_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC6 -------- //\n\n/**\nConfiguration of DIO6*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC6_RESERVED31: any = '1'\nexport const IOC_IOC6_RESERVED31_M: any = '1'\nexport const IOC_IOC6_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC6_HYSTEN: any = '1'\nexport const IOC_IOC6_HYSTEN_M: any = '1'\nexport const IOC_IOC6_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC6_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC6_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC6_INPEN: any = '1'\nexport const IOC_IOC6_INPEN_M: any = '1'\nexport const IOC_IOC6_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC6_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC6_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC6_RESERVED27: any = '2'\nexport const IOC_IOC6_RESERVED27_M: any = '2'\nexport const IOC_IOC6_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC6_IOMODE: any = '3'\nexport const IOC_IOC6_IOMODE_M: any = '3'\nexport const IOC_IOC6_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC6_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC6_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC6_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC6_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC6_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC6_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC6_RESERVED22: any = '2'\nexport const IOC_IOC6_RESERVED22_M: any = '2'\nexport const IOC_IOC6_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC6_WUCFGSD: any = '2'\nexport const IOC_IOC6_WUCFGSD_M: any = '2'\nexport const IOC_IOC6_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC6_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC6_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC6_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC6_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC6_RESERVED19: any = '1'\nexport const IOC_IOC6_RESERVED19_M: any = '1'\nexport const IOC_IOC6_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC6_WUENSB: any = '1'\nexport const IOC_IOC6_WUENSB_M: any = '1'\nexport const IOC_IOC6_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC6_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC6_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC6_EDGEDET: any = '2'\nexport const IOC_IOC6_EDGEDET_M: any = '2'\nexport const IOC_IOC6_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC6_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC6_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC6_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC6_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC6_RESERVED15: any = '1'\nexport const IOC_IOC6_RESERVED15_M: any = '1'\nexport const IOC_IOC6_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC6_PULLCTL: any = '2'\nexport const IOC_IOC6_PULLCTL_M: any = '2'\nexport const IOC_IOC6_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC6_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC6_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC6_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC6_RESERVED3: any = '10'\nexport const IOC_IOC6_RESERVED3_M: any = '10'\nexport const IOC_IOC6_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO6*/\nexport const IOC_IOC6_PORTCFG: any = '3'\nexport const IOC_IOC6_PORTCFG_M: any = '3'\nexport const IOC_IOC6_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC6_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC6_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC6_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC6_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC6_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC6_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC6_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC6_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC7 -------- //\n\n/**\nConfiguration of DIO7*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC7_RESERVED31: any = '1'\nexport const IOC_IOC7_RESERVED31_M: any = '1'\nexport const IOC_IOC7_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC7_HYSTEN: any = '1'\nexport const IOC_IOC7_HYSTEN_M: any = '1'\nexport const IOC_IOC7_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC7_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC7_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC7_INPEN: any = '1'\nexport const IOC_IOC7_INPEN_M: any = '1'\nexport const IOC_IOC7_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC7_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC7_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC7_RESERVED27: any = '2'\nexport const IOC_IOC7_RESERVED27_M: any = '2'\nexport const IOC_IOC7_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC7_IOMODE: any = '3'\nexport const IOC_IOC7_IOMODE_M: any = '3'\nexport const IOC_IOC7_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC7_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC7_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC7_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC7_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC7_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC7_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC7_RESERVED22: any = '2'\nexport const IOC_IOC7_RESERVED22_M: any = '2'\nexport const IOC_IOC7_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC7_WUCFGSD: any = '2'\nexport const IOC_IOC7_WUCFGSD_M: any = '2'\nexport const IOC_IOC7_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC7_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC7_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC7_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC7_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC7_RESERVED19: any = '1'\nexport const IOC_IOC7_RESERVED19_M: any = '1'\nexport const IOC_IOC7_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC7_WUENSB: any = '1'\nexport const IOC_IOC7_WUENSB_M: any = '1'\nexport const IOC_IOC7_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC7_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC7_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC7_EDGEDET: any = '2'\nexport const IOC_IOC7_EDGEDET_M: any = '2'\nexport const IOC_IOC7_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC7_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC7_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC7_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC7_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC7_RESERVED15: any = '1'\nexport const IOC_IOC7_RESERVED15_M: any = '1'\nexport const IOC_IOC7_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC7_PULLCTL: any = '2'\nexport const IOC_IOC7_PULLCTL_M: any = '2'\nexport const IOC_IOC7_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC7_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC7_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC7_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC7_RESERVED3: any = '10'\nexport const IOC_IOC7_RESERVED3_M: any = '10'\nexport const IOC_IOC7_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO7*/\nexport const IOC_IOC7_PORTCFG: any = '3'\nexport const IOC_IOC7_PORTCFG_M: any = '3'\nexport const IOC_IOC7_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC7_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC7_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC7_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC7_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC7_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC7_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC7_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC7_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC8 -------- //\n\n/**\nConfiguration of DIO8*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC8_RESERVED31: any = '1'\nexport const IOC_IOC8_RESERVED31_M: any = '1'\nexport const IOC_IOC8_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC8_HYSTEN: any = '1'\nexport const IOC_IOC8_HYSTEN_M: any = '1'\nexport const IOC_IOC8_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC8_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC8_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC8_INPEN: any = '1'\nexport const IOC_IOC8_INPEN_M: any = '1'\nexport const IOC_IOC8_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC8_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC8_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC8_RESERVED27: any = '2'\nexport const IOC_IOC8_RESERVED27_M: any = '2'\nexport const IOC_IOC8_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC8_IOMODE: any = '3'\nexport const IOC_IOC8_IOMODE_M: any = '3'\nexport const IOC_IOC8_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC8_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC8_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC8_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC8_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC8_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC8_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC8_RESERVED22: any = '2'\nexport const IOC_IOC8_RESERVED22_M: any = '2'\nexport const IOC_IOC8_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC8_WUCFGSD: any = '2'\nexport const IOC_IOC8_WUCFGSD_M: any = '2'\nexport const IOC_IOC8_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC8_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC8_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC8_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC8_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC8_RESERVED19: any = '1'\nexport const IOC_IOC8_RESERVED19_M: any = '1'\nexport const IOC_IOC8_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC8_WUENSB: any = '1'\nexport const IOC_IOC8_WUENSB_M: any = '1'\nexport const IOC_IOC8_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC8_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC8_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC8_EDGEDET: any = '2'\nexport const IOC_IOC8_EDGEDET_M: any = '2'\nexport const IOC_IOC8_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC8_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC8_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC8_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC8_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC8_RESERVED15: any = '1'\nexport const IOC_IOC8_RESERVED15_M: any = '1'\nexport const IOC_IOC8_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC8_PULLCTL: any = '2'\nexport const IOC_IOC8_PULLCTL_M: any = '2'\nexport const IOC_IOC8_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC8_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC8_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC8_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC8_RESERVED3: any = '10'\nexport const IOC_IOC8_RESERVED3_M: any = '10'\nexport const IOC_IOC8_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO8*/\nexport const IOC_IOC8_PORTCFG: any = '3'\nexport const IOC_IOC8_PORTCFG_M: any = '3'\nexport const IOC_IOC8_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC8_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC8_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC8_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC8_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC8_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC8_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC8_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC8_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC9 -------- //\n\n/**\nConfiguration of DIO9*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC9_RESERVED31: any = '1'\nexport const IOC_IOC9_RESERVED31_M: any = '1'\nexport const IOC_IOC9_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC9_HYSTEN: any = '1'\nexport const IOC_IOC9_HYSTEN_M: any = '1'\nexport const IOC_IOC9_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC9_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC9_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC9_INPEN: any = '1'\nexport const IOC_IOC9_INPEN_M: any = '1'\nexport const IOC_IOC9_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC9_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC9_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC9_RESERVED27: any = '2'\nexport const IOC_IOC9_RESERVED27_M: any = '2'\nexport const IOC_IOC9_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC9_IOMODE: any = '3'\nexport const IOC_IOC9_IOMODE_M: any = '3'\nexport const IOC_IOC9_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC9_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC9_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC9_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC9_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC9_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC9_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC9_RESERVED22: any = '2'\nexport const IOC_IOC9_RESERVED22_M: any = '2'\nexport const IOC_IOC9_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC9_WUCFGSD: any = '2'\nexport const IOC_IOC9_WUCFGSD_M: any = '2'\nexport const IOC_IOC9_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC9_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC9_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC9_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC9_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC9_RESERVED19: any = '1'\nexport const IOC_IOC9_RESERVED19_M: any = '1'\nexport const IOC_IOC9_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC9_WUENSB: any = '1'\nexport const IOC_IOC9_WUENSB_M: any = '1'\nexport const IOC_IOC9_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC9_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC9_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC9_EDGEDET: any = '2'\nexport const IOC_IOC9_EDGEDET_M: any = '2'\nexport const IOC_IOC9_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC9_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC9_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC9_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC9_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC9_RESERVED15: any = '1'\nexport const IOC_IOC9_RESERVED15_M: any = '1'\nexport const IOC_IOC9_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC9_PULLCTL: any = '2'\nexport const IOC_IOC9_PULLCTL_M: any = '2'\nexport const IOC_IOC9_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC9_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC9_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC9_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC9_RESERVED3: any = '10'\nexport const IOC_IOC9_RESERVED3_M: any = '10'\nexport const IOC_IOC9_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO9*/\nexport const IOC_IOC9_PORTCFG: any = '3'\nexport const IOC_IOC9_PORTCFG_M: any = '3'\nexport const IOC_IOC9_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC9_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC9_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC9_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC9_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC9_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC9_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC9_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC9_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC10 -------- //\n\n/**\nConfiguration of DIO10*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC10_RESERVED31: any = '1'\nexport const IOC_IOC10_RESERVED31_M: any = '1'\nexport const IOC_IOC10_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC10_HYSTEN: any = '1'\nexport const IOC_IOC10_HYSTEN_M: any = '1'\nexport const IOC_IOC10_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC10_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC10_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC10_INPEN: any = '1'\nexport const IOC_IOC10_INPEN_M: any = '1'\nexport const IOC_IOC10_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC10_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC10_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC10_RESERVED27: any = '2'\nexport const IOC_IOC10_RESERVED27_M: any = '2'\nexport const IOC_IOC10_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC10_IOMODE: any = '3'\nexport const IOC_IOC10_IOMODE_M: any = '3'\nexport const IOC_IOC10_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC10_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC10_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC10_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC10_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC10_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC10_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC10_RESERVED22: any = '2'\nexport const IOC_IOC10_RESERVED22_M: any = '2'\nexport const IOC_IOC10_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC10_WUCFGSD: any = '2'\nexport const IOC_IOC10_WUCFGSD_M: any = '2'\nexport const IOC_IOC10_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC10_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC10_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC10_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC10_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC10_RESERVED19: any = '1'\nexport const IOC_IOC10_RESERVED19_M: any = '1'\nexport const IOC_IOC10_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC10_WUENSB: any = '1'\nexport const IOC_IOC10_WUENSB_M: any = '1'\nexport const IOC_IOC10_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC10_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC10_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC10_EDGEDET: any = '2'\nexport const IOC_IOC10_EDGEDET_M: any = '2'\nexport const IOC_IOC10_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC10_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC10_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC10_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC10_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC10_RESERVED15: any = '1'\nexport const IOC_IOC10_RESERVED15_M: any = '1'\nexport const IOC_IOC10_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC10_PULLCTL: any = '2'\nexport const IOC_IOC10_PULLCTL_M: any = '2'\nexport const IOC_IOC10_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC10_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC10_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC10_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC10_RESERVED3: any = '10'\nexport const IOC_IOC10_RESERVED3_M: any = '10'\nexport const IOC_IOC10_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO10*/\nexport const IOC_IOC10_PORTCFG: any = '3'\nexport const IOC_IOC10_PORTCFG_M: any = '3'\nexport const IOC_IOC10_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC10_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC10_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC10_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC10_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC10_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC10_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC10_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC10_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC11 -------- //\n\n/**\nConfiguration of DIO11*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC11_RESERVED31: any = '1'\nexport const IOC_IOC11_RESERVED31_M: any = '1'\nexport const IOC_IOC11_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC11_HYSTEN: any = '1'\nexport const IOC_IOC11_HYSTEN_M: any = '1'\nexport const IOC_IOC11_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC11_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC11_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC11_INPEN: any = '1'\nexport const IOC_IOC11_INPEN_M: any = '1'\nexport const IOC_IOC11_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC11_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC11_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC11_RESERVED27: any = '2'\nexport const IOC_IOC11_RESERVED27_M: any = '2'\nexport const IOC_IOC11_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC11_IOMODE: any = '3'\nexport const IOC_IOC11_IOMODE_M: any = '3'\nexport const IOC_IOC11_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC11_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC11_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC11_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC11_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC11_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC11_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC11_RESERVED22: any = '2'\nexport const IOC_IOC11_RESERVED22_M: any = '2'\nexport const IOC_IOC11_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC11_WUCFGSD: any = '2'\nexport const IOC_IOC11_WUCFGSD_M: any = '2'\nexport const IOC_IOC11_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC11_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC11_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC11_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC11_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC11_RESERVED19: any = '1'\nexport const IOC_IOC11_RESERVED19_M: any = '1'\nexport const IOC_IOC11_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC11_WUENSB: any = '1'\nexport const IOC_IOC11_WUENSB_M: any = '1'\nexport const IOC_IOC11_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC11_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC11_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC11_EDGEDET: any = '2'\nexport const IOC_IOC11_EDGEDET_M: any = '2'\nexport const IOC_IOC11_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC11_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC11_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC11_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC11_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC11_RESERVED15: any = '1'\nexport const IOC_IOC11_RESERVED15_M: any = '1'\nexport const IOC_IOC11_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC11_PULLCTL: any = '2'\nexport const IOC_IOC11_PULLCTL_M: any = '2'\nexport const IOC_IOC11_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC11_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC11_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC11_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC11_RESERVED3: any = '10'\nexport const IOC_IOC11_RESERVED3_M: any = '10'\nexport const IOC_IOC11_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO11*/\nexport const IOC_IOC11_PORTCFG: any = '3'\nexport const IOC_IOC11_PORTCFG_M: any = '3'\nexport const IOC_IOC11_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC11_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC11_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC11_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC11_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC11_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC11_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC11_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC11_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC12 -------- //\n\n/**\nConfiguration of DIO12*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC12_RESERVED31: any = '1'\nexport const IOC_IOC12_RESERVED31_M: any = '1'\nexport const IOC_IOC12_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC12_HYSTEN: any = '1'\nexport const IOC_IOC12_HYSTEN_M: any = '1'\nexport const IOC_IOC12_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC12_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC12_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC12_INPEN: any = '1'\nexport const IOC_IOC12_INPEN_M: any = '1'\nexport const IOC_IOC12_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC12_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC12_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC12_RESERVED27: any = '2'\nexport const IOC_IOC12_RESERVED27_M: any = '2'\nexport const IOC_IOC12_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC12_IOMODE: any = '3'\nexport const IOC_IOC12_IOMODE_M: any = '3'\nexport const IOC_IOC12_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC12_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC12_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC12_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC12_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC12_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC12_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC12_RESERVED22: any = '2'\nexport const IOC_IOC12_RESERVED22_M: any = '2'\nexport const IOC_IOC12_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC12_WUCFGSD: any = '2'\nexport const IOC_IOC12_WUCFGSD_M: any = '2'\nexport const IOC_IOC12_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC12_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC12_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC12_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC12_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC12_RESERVED19: any = '1'\nexport const IOC_IOC12_RESERVED19_M: any = '1'\nexport const IOC_IOC12_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC12_WUENSB: any = '1'\nexport const IOC_IOC12_WUENSB_M: any = '1'\nexport const IOC_IOC12_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC12_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC12_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC12_EDGEDET: any = '2'\nexport const IOC_IOC12_EDGEDET_M: any = '2'\nexport const IOC_IOC12_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC12_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC12_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC12_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC12_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC12_RESERVED15: any = '1'\nexport const IOC_IOC12_RESERVED15_M: any = '1'\nexport const IOC_IOC12_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC12_PULLCTL: any = '2'\nexport const IOC_IOC12_PULLCTL_M: any = '2'\nexport const IOC_IOC12_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC12_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC12_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC12_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSlew rate configuration*/\nexport const IOC_IOC12_SLEWRED: any = '1'\nexport const IOC_IOC12_SLEWRED_M: any = '1'\nexport const IOC_IOC12_SLEWRED_S: any = '1'\n/**\nReduced slew rate*/\nexport const IOC_IOC12_SLEWRED_REDUCED: any = '1'\n\n/**\nNormal slew rate*/\nexport const IOC_IOC12_SLEWRED_NORMAL: any = '0'\n\n/**\nOutput current configuration. Writing value 0x3 defaults to 2mA current setting.*/\nexport const IOC_IOC12_IOCURR: any = '2'\nexport const IOC_IOC12_IOCURR_M: any = '2'\nexport const IOC_IOC12_IOCURR_S: any = '2'\n/**\n8mA*/\nexport const IOC_IOC12_IOCURR_CUR_8MA: any = '2'\n\n/**\n4mA*/\nexport const IOC_IOC12_IOCURR_CUR_4MA: any = '1'\n\n/**\n2mA*/\nexport const IOC_IOC12_IOCURR_CUR_2MA: any = '0'\n\n/**\nDrive strength configuration*/\nexport const IOC_IOC12_IOSTR: any = '2'\nexport const IOC_IOC12_IOSTR_M: any = '2'\nexport const IOC_IOC12_IOSTR_S: any = '2'\n/**\nMaximum drive strength*/\nexport const IOC_IOC12_IOSTR_MAX: any = '3'\n\n/**\nMedium drive strength*/\nexport const IOC_IOC12_IOSTR_MEDIUM: any = '2'\n\n/**\nMinimum drive stregnth*/\nexport const IOC_IOC12_IOSTR_MIN: any = '1'\n\n/**\nAutomatic drive strength adjustment*/\nexport const IOC_IOC12_IOSTR_AUTO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC12_RESERVED3: any = '5'\nexport const IOC_IOC12_RESERVED3_M: any = '5'\nexport const IOC_IOC12_RESERVED3_S: any = '5'\n/**\nSelects usage of DIO12*/\nexport const IOC_IOC12_PORTCFG: any = '3'\nexport const IOC_IOC12_PORTCFG_M: any = '3'\nexport const IOC_IOC12_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC12_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC12_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC12_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC12_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC12_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC12_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC12_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC12_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC13 -------- //\n\n/**\nConfiguration of DIO13*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC13_RESERVED31: any = '1'\nexport const IOC_IOC13_RESERVED31_M: any = '1'\nexport const IOC_IOC13_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC13_HYSTEN: any = '1'\nexport const IOC_IOC13_HYSTEN_M: any = '1'\nexport const IOC_IOC13_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC13_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC13_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC13_INPEN: any = '1'\nexport const IOC_IOC13_INPEN_M: any = '1'\nexport const IOC_IOC13_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC13_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC13_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC13_RESERVED27: any = '2'\nexport const IOC_IOC13_RESERVED27_M: any = '2'\nexport const IOC_IOC13_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC13_IOMODE: any = '3'\nexport const IOC_IOC13_IOMODE_M: any = '3'\nexport const IOC_IOC13_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC13_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC13_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC13_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC13_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC13_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC13_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC13_RESERVED22: any = '2'\nexport const IOC_IOC13_RESERVED22_M: any = '2'\nexport const IOC_IOC13_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC13_WUCFGSD: any = '2'\nexport const IOC_IOC13_WUCFGSD_M: any = '2'\nexport const IOC_IOC13_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC13_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC13_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC13_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC13_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC13_RESERVED19: any = '1'\nexport const IOC_IOC13_RESERVED19_M: any = '1'\nexport const IOC_IOC13_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC13_WUENSB: any = '1'\nexport const IOC_IOC13_WUENSB_M: any = '1'\nexport const IOC_IOC13_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC13_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC13_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC13_EDGEDET: any = '2'\nexport const IOC_IOC13_EDGEDET_M: any = '2'\nexport const IOC_IOC13_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC13_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC13_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC13_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC13_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC13_RESERVED15: any = '1'\nexport const IOC_IOC13_RESERVED15_M: any = '1'\nexport const IOC_IOC13_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC13_PULLCTL: any = '2'\nexport const IOC_IOC13_PULLCTL_M: any = '2'\nexport const IOC_IOC13_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC13_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC13_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC13_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC13_RESERVED3: any = '10'\nexport const IOC_IOC13_RESERVED3_M: any = '10'\nexport const IOC_IOC13_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO13*/\nexport const IOC_IOC13_PORTCFG: any = '3'\nexport const IOC_IOC13_PORTCFG_M: any = '3'\nexport const IOC_IOC13_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC13_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC13_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC13_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC13_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC13_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC13_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC13_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC13_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC14 -------- //\n\n/**\nConfiguration of DIO14*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC14_RESERVED31: any = '1'\nexport const IOC_IOC14_RESERVED31_M: any = '1'\nexport const IOC_IOC14_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC14_HYSTEN: any = '1'\nexport const IOC_IOC14_HYSTEN_M: any = '1'\nexport const IOC_IOC14_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC14_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC14_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC14_INPEN: any = '1'\nexport const IOC_IOC14_INPEN_M: any = '1'\nexport const IOC_IOC14_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC14_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC14_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC14_RESERVED27: any = '2'\nexport const IOC_IOC14_RESERVED27_M: any = '2'\nexport const IOC_IOC14_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC14_IOMODE: any = '3'\nexport const IOC_IOC14_IOMODE_M: any = '3'\nexport const IOC_IOC14_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC14_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC14_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC14_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC14_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC14_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC14_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC14_RESERVED22: any = '2'\nexport const IOC_IOC14_RESERVED22_M: any = '2'\nexport const IOC_IOC14_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC14_WUCFGSD: any = '2'\nexport const IOC_IOC14_WUCFGSD_M: any = '2'\nexport const IOC_IOC14_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC14_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC14_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC14_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC14_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC14_RESERVED19: any = '1'\nexport const IOC_IOC14_RESERVED19_M: any = '1'\nexport const IOC_IOC14_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC14_WUENSB: any = '1'\nexport const IOC_IOC14_WUENSB_M: any = '1'\nexport const IOC_IOC14_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC14_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC14_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC14_EDGEDET: any = '2'\nexport const IOC_IOC14_EDGEDET_M: any = '2'\nexport const IOC_IOC14_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC14_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC14_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC14_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC14_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC14_RESERVED15: any = '1'\nexport const IOC_IOC14_RESERVED15_M: any = '1'\nexport const IOC_IOC14_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC14_PULLCTL: any = '2'\nexport const IOC_IOC14_PULLCTL_M: any = '2'\nexport const IOC_IOC14_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC14_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC14_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC14_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC14_RESERVED3: any = '10'\nexport const IOC_IOC14_RESERVED3_M: any = '10'\nexport const IOC_IOC14_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO14*/\nexport const IOC_IOC14_PORTCFG: any = '3'\nexport const IOC_IOC14_PORTCFG_M: any = '3'\nexport const IOC_IOC14_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC14_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC14_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC14_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC14_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC14_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC14_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC14_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC14_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC15 -------- //\n\n/**\nConfiguration of DIO15*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC15_RESERVED31: any = '1'\nexport const IOC_IOC15_RESERVED31_M: any = '1'\nexport const IOC_IOC15_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC15_HYSTEN: any = '1'\nexport const IOC_IOC15_HYSTEN_M: any = '1'\nexport const IOC_IOC15_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC15_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC15_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC15_INPEN: any = '1'\nexport const IOC_IOC15_INPEN_M: any = '1'\nexport const IOC_IOC15_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC15_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC15_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC15_RESERVED27: any = '2'\nexport const IOC_IOC15_RESERVED27_M: any = '2'\nexport const IOC_IOC15_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC15_IOMODE: any = '3'\nexport const IOC_IOC15_IOMODE_M: any = '3'\nexport const IOC_IOC15_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC15_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC15_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC15_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC15_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC15_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC15_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC15_RESERVED22: any = '2'\nexport const IOC_IOC15_RESERVED22_M: any = '2'\nexport const IOC_IOC15_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC15_WUCFGSD: any = '2'\nexport const IOC_IOC15_WUCFGSD_M: any = '2'\nexport const IOC_IOC15_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC15_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC15_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC15_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC15_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC15_RESERVED19: any = '1'\nexport const IOC_IOC15_RESERVED19_M: any = '1'\nexport const IOC_IOC15_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC15_WUENSB: any = '1'\nexport const IOC_IOC15_WUENSB_M: any = '1'\nexport const IOC_IOC15_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC15_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC15_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC15_EDGEDET: any = '2'\nexport const IOC_IOC15_EDGEDET_M: any = '2'\nexport const IOC_IOC15_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC15_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC15_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC15_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC15_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC15_RESERVED15: any = '1'\nexport const IOC_IOC15_RESERVED15_M: any = '1'\nexport const IOC_IOC15_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC15_PULLCTL: any = '2'\nexport const IOC_IOC15_PULLCTL_M: any = '2'\nexport const IOC_IOC15_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC15_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC15_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC15_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC15_RESERVED3: any = '10'\nexport const IOC_IOC15_RESERVED3_M: any = '10'\nexport const IOC_IOC15_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO15*/\nexport const IOC_IOC15_PORTCFG: any = '3'\nexport const IOC_IOC15_PORTCFG_M: any = '3'\nexport const IOC_IOC15_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC15_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC15_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC15_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC15_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC15_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC15_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC15_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC15_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC16 -------- //\n\n/**\nConfiguration of DIO16*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC16_RESERVED31: any = '1'\nexport const IOC_IOC16_RESERVED31_M: any = '1'\nexport const IOC_IOC16_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC16_HYSTEN: any = '1'\nexport const IOC_IOC16_HYSTEN_M: any = '1'\nexport const IOC_IOC16_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC16_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC16_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC16_INPEN: any = '1'\nexport const IOC_IOC16_INPEN_M: any = '1'\nexport const IOC_IOC16_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC16_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC16_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC16_RESERVED27: any = '2'\nexport const IOC_IOC16_RESERVED27_M: any = '2'\nexport const IOC_IOC16_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC16_IOMODE: any = '3'\nexport const IOC_IOC16_IOMODE_M: any = '3'\nexport const IOC_IOC16_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC16_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC16_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC16_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC16_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC16_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC16_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC16_RESERVED22: any = '2'\nexport const IOC_IOC16_RESERVED22_M: any = '2'\nexport const IOC_IOC16_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC16_WUCFGSD: any = '2'\nexport const IOC_IOC16_WUCFGSD_M: any = '2'\nexport const IOC_IOC16_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC16_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC16_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC16_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC16_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC16_RESERVED19: any = '1'\nexport const IOC_IOC16_RESERVED19_M: any = '1'\nexport const IOC_IOC16_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC16_WUENSB: any = '1'\nexport const IOC_IOC16_WUENSB_M: any = '1'\nexport const IOC_IOC16_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC16_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC16_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC16_EDGEDET: any = '2'\nexport const IOC_IOC16_EDGEDET_M: any = '2'\nexport const IOC_IOC16_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC16_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC16_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC16_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC16_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC16_RESERVED15: any = '1'\nexport const IOC_IOC16_RESERVED15_M: any = '1'\nexport const IOC_IOC16_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC16_PULLCTL: any = '2'\nexport const IOC_IOC16_PULLCTL_M: any = '2'\nexport const IOC_IOC16_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC16_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC16_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC16_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSlew rate configuration*/\nexport const IOC_IOC16_SLEWRED: any = '1'\nexport const IOC_IOC16_SLEWRED_M: any = '1'\nexport const IOC_IOC16_SLEWRED_S: any = '1'\n/**\nReduced slew rate*/\nexport const IOC_IOC16_SLEWRED_REDUCED: any = '1'\n\n/**\nNormal slew rate*/\nexport const IOC_IOC16_SLEWRED_NORMAL: any = '0'\n\n/**\nOutput current configuration. Writing value 0x3 defaults to 2mA current setting.*/\nexport const IOC_IOC16_IOCURR: any = '2'\nexport const IOC_IOC16_IOCURR_M: any = '2'\nexport const IOC_IOC16_IOCURR_S: any = '2'\n/**\n8mA*/\nexport const IOC_IOC16_IOCURR_CUR_8MA: any = '2'\n\n/**\n4mA*/\nexport const IOC_IOC16_IOCURR_CUR_4MA: any = '1'\n\n/**\n2mA*/\nexport const IOC_IOC16_IOCURR_CUR_2MA: any = '0'\n\n/**\nDrive strength configuration*/\nexport const IOC_IOC16_IOSTR: any = '2'\nexport const IOC_IOC16_IOSTR_M: any = '2'\nexport const IOC_IOC16_IOSTR_S: any = '2'\n/**\nMaximum drive strength*/\nexport const IOC_IOC16_IOSTR_MAX: any = '3'\n\n/**\nMedium drive strength*/\nexport const IOC_IOC16_IOSTR_MEDIUM: any = '2'\n\n/**\nMinimum drive stregnth*/\nexport const IOC_IOC16_IOSTR_MIN: any = '1'\n\n/**\nAutomatic drive strength adjustment*/\nexport const IOC_IOC16_IOSTR_AUTO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC16_RESERVED3: any = '5'\nexport const IOC_IOC16_RESERVED3_M: any = '5'\nexport const IOC_IOC16_RESERVED3_S: any = '5'\n/**\nSelects usage of DIO16*/\nexport const IOC_IOC16_PORTCFG: any = '3'\nexport const IOC_IOC16_PORTCFG_M: any = '3'\nexport const IOC_IOC16_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC16_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC16_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC16_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC16_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC16_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC16_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC16_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC16_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC17 -------- //\n\n/**\nConfiguration of DIO17*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC17_RESERVED31: any = '1'\nexport const IOC_IOC17_RESERVED31_M: any = '1'\nexport const IOC_IOC17_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC17_HYSTEN: any = '1'\nexport const IOC_IOC17_HYSTEN_M: any = '1'\nexport const IOC_IOC17_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC17_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC17_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC17_INPEN: any = '1'\nexport const IOC_IOC17_INPEN_M: any = '1'\nexport const IOC_IOC17_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC17_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC17_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC17_RESERVED27: any = '2'\nexport const IOC_IOC17_RESERVED27_M: any = '2'\nexport const IOC_IOC17_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC17_IOMODE: any = '3'\nexport const IOC_IOC17_IOMODE_M: any = '3'\nexport const IOC_IOC17_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC17_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC17_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC17_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC17_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC17_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC17_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC17_RESERVED22: any = '2'\nexport const IOC_IOC17_RESERVED22_M: any = '2'\nexport const IOC_IOC17_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC17_WUCFGSD: any = '2'\nexport const IOC_IOC17_WUCFGSD_M: any = '2'\nexport const IOC_IOC17_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC17_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC17_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC17_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC17_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC17_RESERVED19: any = '1'\nexport const IOC_IOC17_RESERVED19_M: any = '1'\nexport const IOC_IOC17_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC17_WUENSB: any = '1'\nexport const IOC_IOC17_WUENSB_M: any = '1'\nexport const IOC_IOC17_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC17_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC17_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC17_EDGEDET: any = '2'\nexport const IOC_IOC17_EDGEDET_M: any = '2'\nexport const IOC_IOC17_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC17_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC17_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC17_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC17_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC17_RESERVED15: any = '1'\nexport const IOC_IOC17_RESERVED15_M: any = '1'\nexport const IOC_IOC17_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC17_PULLCTL: any = '2'\nexport const IOC_IOC17_PULLCTL_M: any = '2'\nexport const IOC_IOC17_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC17_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC17_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC17_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSlew rate configuration*/\nexport const IOC_IOC17_SLEWRED: any = '1'\nexport const IOC_IOC17_SLEWRED_M: any = '1'\nexport const IOC_IOC17_SLEWRED_S: any = '1'\n/**\nReduced slew rate*/\nexport const IOC_IOC17_SLEWRED_REDUCED: any = '1'\n\n/**\nNormal slew rate*/\nexport const IOC_IOC17_SLEWRED_NORMAL: any = '0'\n\n/**\nOutput current configuration. Writing value 0x3 defaults to 2mA current setting.*/\nexport const IOC_IOC17_IOCURR: any = '2'\nexport const IOC_IOC17_IOCURR_M: any = '2'\nexport const IOC_IOC17_IOCURR_S: any = '2'\n/**\n8mA*/\nexport const IOC_IOC17_IOCURR_CUR_8MA: any = '2'\n\n/**\n4mA*/\nexport const IOC_IOC17_IOCURR_CUR_4MA: any = '1'\n\n/**\n2mA*/\nexport const IOC_IOC17_IOCURR_CUR_2MA: any = '0'\n\n/**\nDrive strength configuration*/\nexport const IOC_IOC17_IOSTR: any = '2'\nexport const IOC_IOC17_IOSTR_M: any = '2'\nexport const IOC_IOC17_IOSTR_S: any = '2'\n/**\nMaximum drive strength*/\nexport const IOC_IOC17_IOSTR_MAX: any = '3'\n\n/**\nMedium drive strength*/\nexport const IOC_IOC17_IOSTR_MEDIUM: any = '2'\n\n/**\nMinimum drive stregnth*/\nexport const IOC_IOC17_IOSTR_MIN: any = '1'\n\n/**\nAutomatic drive strength adjustment*/\nexport const IOC_IOC17_IOSTR_AUTO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC17_RESERVED3: any = '5'\nexport const IOC_IOC17_RESERVED3_M: any = '5'\nexport const IOC_IOC17_RESERVED3_S: any = '5'\n/**\nSelects usage of DIO17*/\nexport const IOC_IOC17_PORTCFG: any = '3'\nexport const IOC_IOC17_PORTCFG_M: any = '3'\nexport const IOC_IOC17_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC17_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC17_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC17_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC17_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC17_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC17_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC17_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC17_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC18 -------- //\n\n/**\nConfiguration of DIO18*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC18_RESERVED31: any = '1'\nexport const IOC_IOC18_RESERVED31_M: any = '1'\nexport const IOC_IOC18_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC18_HYSTEN: any = '1'\nexport const IOC_IOC18_HYSTEN_M: any = '1'\nexport const IOC_IOC18_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC18_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC18_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC18_INPEN: any = '1'\nexport const IOC_IOC18_INPEN_M: any = '1'\nexport const IOC_IOC18_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC18_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC18_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC18_RESERVED27: any = '2'\nexport const IOC_IOC18_RESERVED27_M: any = '2'\nexport const IOC_IOC18_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC18_IOMODE: any = '3'\nexport const IOC_IOC18_IOMODE_M: any = '3'\nexport const IOC_IOC18_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC18_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC18_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC18_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC18_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC18_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC18_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC18_RESERVED22: any = '2'\nexport const IOC_IOC18_RESERVED22_M: any = '2'\nexport const IOC_IOC18_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC18_WUCFGSD: any = '2'\nexport const IOC_IOC18_WUCFGSD_M: any = '2'\nexport const IOC_IOC18_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC18_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC18_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC18_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC18_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC18_RESERVED19: any = '1'\nexport const IOC_IOC18_RESERVED19_M: any = '1'\nexport const IOC_IOC18_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC18_WUENSB: any = '1'\nexport const IOC_IOC18_WUENSB_M: any = '1'\nexport const IOC_IOC18_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC18_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC18_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC18_EDGEDET: any = '2'\nexport const IOC_IOC18_EDGEDET_M: any = '2'\nexport const IOC_IOC18_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC18_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC18_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC18_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC18_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC18_RESERVED15: any = '1'\nexport const IOC_IOC18_RESERVED15_M: any = '1'\nexport const IOC_IOC18_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC18_PULLCTL: any = '2'\nexport const IOC_IOC18_PULLCTL_M: any = '2'\nexport const IOC_IOC18_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC18_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC18_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC18_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSlew rate configuration*/\nexport const IOC_IOC18_SLEWRED: any = '1'\nexport const IOC_IOC18_SLEWRED_M: any = '1'\nexport const IOC_IOC18_SLEWRED_S: any = '1'\n/**\nReduced slew rate*/\nexport const IOC_IOC18_SLEWRED_REDUCED: any = '1'\n\n/**\nNormal slew rate*/\nexport const IOC_IOC18_SLEWRED_NORMAL: any = '0'\n\n/**\nOutput current configuration. Writing value 0x3 defaults to 2mA current setting.*/\nexport const IOC_IOC18_IOCURR: any = '2'\nexport const IOC_IOC18_IOCURR_M: any = '2'\nexport const IOC_IOC18_IOCURR_S: any = '2'\n/**\n8mA*/\nexport const IOC_IOC18_IOCURR_CUR_8MA: any = '2'\n\n/**\n4mA*/\nexport const IOC_IOC18_IOCURR_CUR_4MA: any = '1'\n\n/**\n2mA*/\nexport const IOC_IOC18_IOCURR_CUR_2MA: any = '0'\n\n/**\nDrive strength configuration*/\nexport const IOC_IOC18_IOSTR: any = '2'\nexport const IOC_IOC18_IOSTR_M: any = '2'\nexport const IOC_IOC18_IOSTR_S: any = '2'\n/**\nMaximum drive strength*/\nexport const IOC_IOC18_IOSTR_MAX: any = '3'\n\n/**\nMedium drive strength*/\nexport const IOC_IOC18_IOSTR_MEDIUM: any = '2'\n\n/**\nMinimum drive stregnth*/\nexport const IOC_IOC18_IOSTR_MIN: any = '1'\n\n/**\nAutomatic drive strength adjustment*/\nexport const IOC_IOC18_IOSTR_AUTO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC18_RESERVED3: any = '5'\nexport const IOC_IOC18_RESERVED3_M: any = '5'\nexport const IOC_IOC18_RESERVED3_S: any = '5'\n/**\nSelects usage of DIO18*/\nexport const IOC_IOC18_PORTCFG: any = '3'\nexport const IOC_IOC18_PORTCFG_M: any = '3'\nexport const IOC_IOC18_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC18_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC18_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC18_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC18_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC18_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC18_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC18_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC18_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC19 -------- //\n\n/**\nConfiguration of DIO19*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC19_RESERVED31: any = '1'\nexport const IOC_IOC19_RESERVED31_M: any = '1'\nexport const IOC_IOC19_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC19_HYSTEN: any = '1'\nexport const IOC_IOC19_HYSTEN_M: any = '1'\nexport const IOC_IOC19_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC19_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC19_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC19_INPEN: any = '1'\nexport const IOC_IOC19_INPEN_M: any = '1'\nexport const IOC_IOC19_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC19_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC19_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC19_RESERVED27: any = '2'\nexport const IOC_IOC19_RESERVED27_M: any = '2'\nexport const IOC_IOC19_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC19_IOMODE: any = '3'\nexport const IOC_IOC19_IOMODE_M: any = '3'\nexport const IOC_IOC19_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC19_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC19_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC19_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC19_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC19_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC19_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC19_RESERVED22: any = '2'\nexport const IOC_IOC19_RESERVED22_M: any = '2'\nexport const IOC_IOC19_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC19_WUCFGSD: any = '2'\nexport const IOC_IOC19_WUCFGSD_M: any = '2'\nexport const IOC_IOC19_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC19_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC19_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC19_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC19_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC19_RESERVED19: any = '1'\nexport const IOC_IOC19_RESERVED19_M: any = '1'\nexport const IOC_IOC19_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC19_WUENSB: any = '1'\nexport const IOC_IOC19_WUENSB_M: any = '1'\nexport const IOC_IOC19_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC19_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC19_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC19_EDGEDET: any = '2'\nexport const IOC_IOC19_EDGEDET_M: any = '2'\nexport const IOC_IOC19_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC19_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC19_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC19_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC19_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC19_RESERVED15: any = '1'\nexport const IOC_IOC19_RESERVED15_M: any = '1'\nexport const IOC_IOC19_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC19_PULLCTL: any = '2'\nexport const IOC_IOC19_PULLCTL_M: any = '2'\nexport const IOC_IOC19_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC19_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC19_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC19_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSlew rate configuration*/\nexport const IOC_IOC19_SLEWRED: any = '1'\nexport const IOC_IOC19_SLEWRED_M: any = '1'\nexport const IOC_IOC19_SLEWRED_S: any = '1'\n/**\nReduced slew rate*/\nexport const IOC_IOC19_SLEWRED_REDUCED: any = '1'\n\n/**\nNormal slew rate*/\nexport const IOC_IOC19_SLEWRED_NORMAL: any = '0'\n\n/**\nOutput current configuration. Writing value 0x3 defaults to 2mA current setting.*/\nexport const IOC_IOC19_IOCURR: any = '2'\nexport const IOC_IOC19_IOCURR_M: any = '2'\nexport const IOC_IOC19_IOCURR_S: any = '2'\n/**\n8mA*/\nexport const IOC_IOC19_IOCURR_CUR_8MA: any = '2'\n\n/**\n4mA*/\nexport const IOC_IOC19_IOCURR_CUR_4MA: any = '1'\n\n/**\n2mA*/\nexport const IOC_IOC19_IOCURR_CUR_2MA: any = '0'\n\n/**\nDrive strength configuration*/\nexport const IOC_IOC19_IOSTR: any = '2'\nexport const IOC_IOC19_IOSTR_M: any = '2'\nexport const IOC_IOC19_IOSTR_S: any = '2'\n/**\nMaximum drive strength*/\nexport const IOC_IOC19_IOSTR_MAX: any = '3'\n\n/**\nMedium drive strength*/\nexport const IOC_IOC19_IOSTR_MEDIUM: any = '2'\n\n/**\nMinimum drive stregnth*/\nexport const IOC_IOC19_IOSTR_MIN: any = '1'\n\n/**\nAutomatic drive strength adjustment*/\nexport const IOC_IOC19_IOSTR_AUTO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC19_RESERVED3: any = '5'\nexport const IOC_IOC19_RESERVED3_M: any = '5'\nexport const IOC_IOC19_RESERVED3_S: any = '5'\n/**\nSelects usage of DIO19*/\nexport const IOC_IOC19_PORTCFG: any = '3'\nexport const IOC_IOC19_PORTCFG_M: any = '3'\nexport const IOC_IOC19_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC19_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC19_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC19_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC19_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC19_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC19_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC19_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC19_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC20 -------- //\n\n/**\nConfiguration of DIO20*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC20_RESERVED31: any = '1'\nexport const IOC_IOC20_RESERVED31_M: any = '1'\nexport const IOC_IOC20_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC20_HYSTEN: any = '1'\nexport const IOC_IOC20_HYSTEN_M: any = '1'\nexport const IOC_IOC20_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC20_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC20_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC20_INPEN: any = '1'\nexport const IOC_IOC20_INPEN_M: any = '1'\nexport const IOC_IOC20_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC20_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC20_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC20_RESERVED27: any = '2'\nexport const IOC_IOC20_RESERVED27_M: any = '2'\nexport const IOC_IOC20_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC20_IOMODE: any = '3'\nexport const IOC_IOC20_IOMODE_M: any = '3'\nexport const IOC_IOC20_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC20_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC20_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC20_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC20_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC20_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC20_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC20_RESERVED22: any = '2'\nexport const IOC_IOC20_RESERVED22_M: any = '2'\nexport const IOC_IOC20_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC20_WUCFGSD: any = '2'\nexport const IOC_IOC20_WUCFGSD_M: any = '2'\nexport const IOC_IOC20_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC20_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC20_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC20_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC20_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC20_RESERVED19: any = '1'\nexport const IOC_IOC20_RESERVED19_M: any = '1'\nexport const IOC_IOC20_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC20_WUENSB: any = '1'\nexport const IOC_IOC20_WUENSB_M: any = '1'\nexport const IOC_IOC20_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC20_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC20_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC20_EDGEDET: any = '2'\nexport const IOC_IOC20_EDGEDET_M: any = '2'\nexport const IOC_IOC20_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC20_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC20_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC20_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC20_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC20_RESERVED15: any = '1'\nexport const IOC_IOC20_RESERVED15_M: any = '1'\nexport const IOC_IOC20_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC20_PULLCTL: any = '2'\nexport const IOC_IOC20_PULLCTL_M: any = '2'\nexport const IOC_IOC20_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC20_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC20_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC20_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC20_RESERVED3: any = '10'\nexport const IOC_IOC20_RESERVED3_M: any = '10'\nexport const IOC_IOC20_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO20*/\nexport const IOC_IOC20_PORTCFG: any = '3'\nexport const IOC_IOC20_PORTCFG_M: any = '3'\nexport const IOC_IOC20_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC20_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC20_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC20_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC20_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC20_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC20_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC20_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC20_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC21 -------- //\n\n/**\nConfiguration of DIO21*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC21_RESERVED31: any = '1'\nexport const IOC_IOC21_RESERVED31_M: any = '1'\nexport const IOC_IOC21_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC21_HYSTEN: any = '1'\nexport const IOC_IOC21_HYSTEN_M: any = '1'\nexport const IOC_IOC21_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC21_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC21_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC21_INPEN: any = '1'\nexport const IOC_IOC21_INPEN_M: any = '1'\nexport const IOC_IOC21_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC21_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC21_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC21_RESERVED27: any = '2'\nexport const IOC_IOC21_RESERVED27_M: any = '2'\nexport const IOC_IOC21_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC21_IOMODE: any = '3'\nexport const IOC_IOC21_IOMODE_M: any = '3'\nexport const IOC_IOC21_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC21_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC21_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC21_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC21_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC21_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC21_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC21_RESERVED22: any = '2'\nexport const IOC_IOC21_RESERVED22_M: any = '2'\nexport const IOC_IOC21_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC21_WUCFGSD: any = '2'\nexport const IOC_IOC21_WUCFGSD_M: any = '2'\nexport const IOC_IOC21_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC21_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC21_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC21_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC21_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC21_RESERVED19: any = '1'\nexport const IOC_IOC21_RESERVED19_M: any = '1'\nexport const IOC_IOC21_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC21_WUENSB: any = '1'\nexport const IOC_IOC21_WUENSB_M: any = '1'\nexport const IOC_IOC21_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC21_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC21_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC21_EDGEDET: any = '2'\nexport const IOC_IOC21_EDGEDET_M: any = '2'\nexport const IOC_IOC21_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC21_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC21_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC21_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC21_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC21_RESERVED15: any = '1'\nexport const IOC_IOC21_RESERVED15_M: any = '1'\nexport const IOC_IOC21_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC21_PULLCTL: any = '2'\nexport const IOC_IOC21_PULLCTL_M: any = '2'\nexport const IOC_IOC21_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC21_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC21_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC21_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC21_RESERVED3: any = '10'\nexport const IOC_IOC21_RESERVED3_M: any = '10'\nexport const IOC_IOC21_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO21*/\nexport const IOC_IOC21_PORTCFG: any = '3'\nexport const IOC_IOC21_PORTCFG_M: any = '3'\nexport const IOC_IOC21_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC21_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC21_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC21_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC21_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC21_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC21_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC21_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC21_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC22 -------- //\n\n/**\nConfiguration of DIO22*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC22_RESERVED31: any = '1'\nexport const IOC_IOC22_RESERVED31_M: any = '1'\nexport const IOC_IOC22_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC22_HYSTEN: any = '1'\nexport const IOC_IOC22_HYSTEN_M: any = '1'\nexport const IOC_IOC22_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC22_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC22_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC22_INPEN: any = '1'\nexport const IOC_IOC22_INPEN_M: any = '1'\nexport const IOC_IOC22_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC22_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC22_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC22_RESERVED27: any = '2'\nexport const IOC_IOC22_RESERVED27_M: any = '2'\nexport const IOC_IOC22_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC22_IOMODE: any = '3'\nexport const IOC_IOC22_IOMODE_M: any = '3'\nexport const IOC_IOC22_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC22_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC22_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC22_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC22_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC22_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC22_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC22_RESERVED22: any = '2'\nexport const IOC_IOC22_RESERVED22_M: any = '2'\nexport const IOC_IOC22_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC22_WUCFGSD: any = '2'\nexport const IOC_IOC22_WUCFGSD_M: any = '2'\nexport const IOC_IOC22_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC22_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC22_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC22_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC22_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC22_RESERVED19: any = '1'\nexport const IOC_IOC22_RESERVED19_M: any = '1'\nexport const IOC_IOC22_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC22_WUENSB: any = '1'\nexport const IOC_IOC22_WUENSB_M: any = '1'\nexport const IOC_IOC22_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC22_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC22_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC22_EDGEDET: any = '2'\nexport const IOC_IOC22_EDGEDET_M: any = '2'\nexport const IOC_IOC22_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC22_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC22_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC22_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC22_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC22_RESERVED15: any = '1'\nexport const IOC_IOC22_RESERVED15_M: any = '1'\nexport const IOC_IOC22_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC22_PULLCTL: any = '2'\nexport const IOC_IOC22_PULLCTL_M: any = '2'\nexport const IOC_IOC22_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC22_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC22_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC22_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC22_RESERVED3: any = '10'\nexport const IOC_IOC22_RESERVED3_M: any = '10'\nexport const IOC_IOC22_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO22*/\nexport const IOC_IOC22_PORTCFG: any = '3'\nexport const IOC_IOC22_PORTCFG_M: any = '3'\nexport const IOC_IOC22_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC22_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC22_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC22_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC22_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC22_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC22_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC22_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC22_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC23 -------- //\n\n/**\nConfiguration of DIO23*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC23_RESERVED31: any = '1'\nexport const IOC_IOC23_RESERVED31_M: any = '1'\nexport const IOC_IOC23_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC23_HYSTEN: any = '1'\nexport const IOC_IOC23_HYSTEN_M: any = '1'\nexport const IOC_IOC23_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC23_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC23_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC23_INPEN: any = '1'\nexport const IOC_IOC23_INPEN_M: any = '1'\nexport const IOC_IOC23_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC23_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC23_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC23_RESERVED27: any = '2'\nexport const IOC_IOC23_RESERVED27_M: any = '2'\nexport const IOC_IOC23_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC23_IOMODE: any = '3'\nexport const IOC_IOC23_IOMODE_M: any = '3'\nexport const IOC_IOC23_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC23_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC23_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC23_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC23_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC23_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC23_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC23_RESERVED22: any = '2'\nexport const IOC_IOC23_RESERVED22_M: any = '2'\nexport const IOC_IOC23_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC23_WUCFGSD: any = '2'\nexport const IOC_IOC23_WUCFGSD_M: any = '2'\nexport const IOC_IOC23_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC23_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC23_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC23_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC23_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC23_RESERVED19: any = '1'\nexport const IOC_IOC23_RESERVED19_M: any = '1'\nexport const IOC_IOC23_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC23_WUENSB: any = '1'\nexport const IOC_IOC23_WUENSB_M: any = '1'\nexport const IOC_IOC23_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC23_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC23_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC23_EDGEDET: any = '2'\nexport const IOC_IOC23_EDGEDET_M: any = '2'\nexport const IOC_IOC23_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC23_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC23_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC23_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC23_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC23_RESERVED15: any = '1'\nexport const IOC_IOC23_RESERVED15_M: any = '1'\nexport const IOC_IOC23_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC23_PULLCTL: any = '2'\nexport const IOC_IOC23_PULLCTL_M: any = '2'\nexport const IOC_IOC23_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC23_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC23_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC23_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC23_RESERVED3: any = '10'\nexport const IOC_IOC23_RESERVED3_M: any = '10'\nexport const IOC_IOC23_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO23*/\nexport const IOC_IOC23_PORTCFG: any = '3'\nexport const IOC_IOC23_PORTCFG_M: any = '3'\nexport const IOC_IOC23_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC23_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC23_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC23_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC23_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC23_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC23_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC23_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC23_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC24 -------- //\n\n/**\nConfiguration of DIO24*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC24_RESERVED31: any = '1'\nexport const IOC_IOC24_RESERVED31_M: any = '1'\nexport const IOC_IOC24_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC24_HYSTEN: any = '1'\nexport const IOC_IOC24_HYSTEN_M: any = '1'\nexport const IOC_IOC24_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC24_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC24_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC24_INPEN: any = '1'\nexport const IOC_IOC24_INPEN_M: any = '1'\nexport const IOC_IOC24_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC24_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC24_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC24_RESERVED27: any = '2'\nexport const IOC_IOC24_RESERVED27_M: any = '2'\nexport const IOC_IOC24_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC24_IOMODE: any = '3'\nexport const IOC_IOC24_IOMODE_M: any = '3'\nexport const IOC_IOC24_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC24_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC24_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC24_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC24_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC24_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC24_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC24_RESERVED22: any = '2'\nexport const IOC_IOC24_RESERVED22_M: any = '2'\nexport const IOC_IOC24_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC24_WUCFGSD: any = '2'\nexport const IOC_IOC24_WUCFGSD_M: any = '2'\nexport const IOC_IOC24_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC24_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC24_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC24_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC24_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC24_RESERVED19: any = '1'\nexport const IOC_IOC24_RESERVED19_M: any = '1'\nexport const IOC_IOC24_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC24_WUENSB: any = '1'\nexport const IOC_IOC24_WUENSB_M: any = '1'\nexport const IOC_IOC24_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC24_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC24_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC24_EDGEDET: any = '2'\nexport const IOC_IOC24_EDGEDET_M: any = '2'\nexport const IOC_IOC24_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC24_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC24_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC24_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC24_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC24_RESERVED15: any = '1'\nexport const IOC_IOC24_RESERVED15_M: any = '1'\nexport const IOC_IOC24_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC24_PULLCTL: any = '2'\nexport const IOC_IOC24_PULLCTL_M: any = '2'\nexport const IOC_IOC24_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC24_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC24_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC24_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSlew rate configuration*/\nexport const IOC_IOC24_SLEWRED: any = '1'\nexport const IOC_IOC24_SLEWRED_M: any = '1'\nexport const IOC_IOC24_SLEWRED_S: any = '1'\n/**\nReduced slew rate*/\nexport const IOC_IOC24_SLEWRED_REDUCED: any = '1'\n\n/**\nNormal slew rate*/\nexport const IOC_IOC24_SLEWRED_NORMAL: any = '0'\n\n/**\nOutput current configuration. Writing value 0x3 defaults to 2mA current setting.*/\nexport const IOC_IOC24_IOCURR: any = '2'\nexport const IOC_IOC24_IOCURR_M: any = '2'\nexport const IOC_IOC24_IOCURR_S: any = '2'\n/**\n8mA*/\nexport const IOC_IOC24_IOCURR_CUR_8MA: any = '2'\n\n/**\n4mA*/\nexport const IOC_IOC24_IOCURR_CUR_4MA: any = '1'\n\n/**\n2mA*/\nexport const IOC_IOC24_IOCURR_CUR_2MA: any = '0'\n\n/**\nDrive strength configuration*/\nexport const IOC_IOC24_IOSTR: any = '2'\nexport const IOC_IOC24_IOSTR_M: any = '2'\nexport const IOC_IOC24_IOSTR_S: any = '2'\n/**\nMaximum drive strength*/\nexport const IOC_IOC24_IOSTR_MAX: any = '3'\n\n/**\nMedium drive strength*/\nexport const IOC_IOC24_IOSTR_MEDIUM: any = '2'\n\n/**\nMinimum drive stregnth*/\nexport const IOC_IOC24_IOSTR_MIN: any = '1'\n\n/**\nAutomatic drive strength adjustment*/\nexport const IOC_IOC24_IOSTR_AUTO: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC24_RESERVED3: any = '5'\nexport const IOC_IOC24_RESERVED3_M: any = '5'\nexport const IOC_IOC24_RESERVED3_S: any = '5'\n/**\nSelects usage of DIO24*/\nexport const IOC_IOC24_PORTCFG: any = '3'\nexport const IOC_IOC24_PORTCFG_M: any = '3'\nexport const IOC_IOC24_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC24_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC24_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC24_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC24_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC24_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC24_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC24_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC24_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER IOC25 -------- //\n\n/**\nSelects usage of DIO25*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC25_RESERVED31: any = '1'\nexport const IOC_IOC25_RESERVED31_M: any = '1'\nexport const IOC_IOC25_RESERVED31_S: any = '1'\n/**\nThis field controls input hysteresis*/\nexport const IOC_IOC25_HYSTEN: any = '1'\nexport const IOC_IOC25_HYSTEN_M: any = '1'\nexport const IOC_IOC25_HYSTEN_S: any = '1'\n/**\nInput hysteresis enabled*/\nexport const IOC_IOC25_HYSTEN_EN: any = '1'\n\n/**\nInput hysteresis disabled*/\nexport const IOC_IOC25_HYSTEN_DIS: any = '0'\n\n/**\nThis field controls the input capability of DIO*/\nexport const IOC_IOC25_INPEN: any = '1'\nexport const IOC_IOC25_INPEN_M: any = '1'\nexport const IOC_IOC25_INPEN_S: any = '1'\n/**\nInput enabled*/\nexport const IOC_IOC25_INPEN_EN: any = '1'\n\n/**\nInput disabled*/\nexport const IOC_IOC25_INPEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC25_RESERVED27: any = '2'\nexport const IOC_IOC25_RESERVED27_M: any = '2'\nexport const IOC_IOC25_RESERVED27_S: any = '2'\n/**\nIO Mode. Setting this to value 0x6 or 0x7 will default to normal IO behavior.*/\nexport const IOC_IOC25_IOMODE: any = '3'\nexport const IOC_IOC25_IOMODE_M: any = '3'\nexport const IOC_IOC25_IOMODE_S: any = '3'\n/**\nOpen Source, inverted IO*/\nexport const IOC_IOC25_IOMODE_OPENS_INV: any = '5'\n\n/**\nOpen Source, normal IO*/\nexport const IOC_IOC25_IOMODE_OPENS: any = '4'\n\n/**\nOpen Drain, inverted IO*/\nexport const IOC_IOC25_IOMODE_OPEND_INV: any = '3'\n\n/**\nOpen Drain, normal IO*/\nexport const IOC_IOC25_IOMODE_OPEND: any = '2'\n\n/**\nInverted IO*/\nexport const IOC_IOC25_IOMODE_INVERTED: any = '1'\n\n/**\nNormal IO*/\nexport const IOC_IOC25_IOMODE_NORMAL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC25_RESERVED22: any = '2'\nexport const IOC_IOC25_RESERVED22_M: any = '2'\nexport const IOC_IOC25_RESERVED22_S: any = '2'\n/**\nWakeup configuration from shutdown*/\nexport const IOC_IOC25_WUCFGSD: any = '2'\nexport const IOC_IOC25_WUCFGSD_M: any = '2'\nexport const IOC_IOC25_WUCFGSD_S: any = '2'\n/**\nWakeup triggered when pad level is high*/\nexport const IOC_IOC25_WUCFGSD_WAKE_HIGH: any = '3'\n\n/**\nWakeup triggered when pad level is low*/\nexport const IOC_IOC25_WUCFGSD_WAKE_LOW: any = '2'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC25_WUCFGSD_DIS_1: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC25_WUCFGSD_DIS_0: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC25_RESERVED19: any = '1'\nexport const IOC_IOC25_RESERVED19_M: any = '1'\nexport const IOC_IOC25_RESERVED19_S: any = '1'\n/**\nWakeup enable from standby*/\nexport const IOC_IOC25_WUENSB: any = '1'\nexport const IOC_IOC25_WUENSB_M: any = '1'\nexport const IOC_IOC25_WUENSB_S: any = '1'\n/**\nWakeup enabled (effective only if EDGEDET is enabled)*/\nexport const IOC_IOC25_WUENSB_EN: any = '1'\n\n/**\nWakeup disabled*/\nexport const IOC_IOC25_WUENSB_DIS: any = '0'\n\n/**\nEdge detect configuration*/\nexport const IOC_IOC25_EDGEDET: any = '2'\nexport const IOC_IOC25_EDGEDET_M: any = '2'\nexport const IOC_IOC25_EDGEDET_S: any = '2'\n/**\nPositive and negative edge detection*/\nexport const IOC_IOC25_EDGEDET_EDGE_BOTH: any = '3'\n\n/**\nPositive edge detection*/\nexport const IOC_IOC25_EDGEDET_EDGE_POS: any = '2'\n\n/**\nNegative edge detection*/\nexport const IOC_IOC25_EDGEDET_EDGE_NEG: any = '1'\n\n/**\nNo edge detection*/\nexport const IOC_IOC25_EDGEDET_EDGE_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC25_RESERVED15: any = '1'\nexport const IOC_IOC25_RESERVED15_M: any = '1'\nexport const IOC_IOC25_RESERVED15_S: any = '1'\n/**\nPull control. Setting this to value 0x3 disables pull.*/\nexport const IOC_IOC25_PULLCTL: any = '2'\nexport const IOC_IOC25_PULLCTL_M: any = '2'\nexport const IOC_IOC25_PULLCTL_S: any = '2'\n/**\nPull up enabled*/\nexport const IOC_IOC25_PULLCTL_PULL_UP: any = '2'\n\n/**\nPull down enabled*/\nexport const IOC_IOC25_PULLCTL_PULL_DOWN: any = '1'\n\n/**\nNo pull*/\nexport const IOC_IOC25_PULLCTL_PULL_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_IOC25_RESERVED3: any = '10'\nexport const IOC_IOC25_RESERVED3_M: any = '10'\nexport const IOC_IOC25_RESERVED3_S: any = '10'\n/**\nSelects usage of DIO25*/\nexport const IOC_IOC25_PORTCFG: any = '3'\nexport const IOC_IOC25_PORTCFG_M: any = '3'\nexport const IOC_IOC25_PORTCFG_S: any = '3'\n/**\nDigital Test Bus function*/\nexport const IOC_IOC25_PORTCFG_DTB: any = '7'\n\n/**\nAnalog function*/\nexport const IOC_IOC25_PORTCFG_ANA: any = '6'\n\n/**\nDigital peripheral function-5*/\nexport const IOC_IOC25_PORTCFG_PFUNC5: any = '5'\n\n/**\nDigital peripheral function-4*/\nexport const IOC_IOC25_PORTCFG_PFUNC4: any = '4'\n\n/**\nDigital peripheral function-3*/\nexport const IOC_IOC25_PORTCFG_PFUNC3: any = '3'\n\n/**\nDigital peripheral function-2*/\nexport const IOC_IOC25_PORTCFG_PFUNC2: any = '2'\n\n/**\nDigital peripheral function-1 */\nexport const IOC_IOC25_PORTCFG_PFUNC1: any = '1'\n\n/**\nBase function*/\nexport const IOC_IOC25_PORTCFG_BASE: any = '0'\n\n\n// -------- REGISTER DTBCFG -------- //\n\n/**\nDTB configuration*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_DTBCFG_RESERVED24: any = '8'\nexport const IOC_DTBCFG_RESERVED24_M: any = '8'\nexport const IOC_DTBCFG_RESERVED24_S: any = '8'\n/**\nThis bit is used to divide DTB[0] output by 8.*/\nexport const IOC_DTBCFG_DTB0DIV: any = '1'\nexport const IOC_DTBCFG_DTB0DIV_M: any = '1'\nexport const IOC_DTBCFG_DTB0DIV_S: any = '1'\n/**\nDivide DTB[0] output by 8*/\nexport const IOC_DTBCFG_DTB0DIV_EN: any = '1'\n\n/**\nNo divide*/\nexport const IOC_DTBCFG_DTB0DIV_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_DTBCFG_RESERVED19: any = '4'\nexport const IOC_DTBCFG_RESERVED19_M: any = '4'\nexport const IOC_DTBCFG_RESERVED19_S: any = '4'\n/**\nSelects which 3 DTB lines out of total 16 are routed to DTB pins 15 to 13.*/\nexport const IOC_DTBCFG_PADSEL: any = '3'\nexport const IOC_DTBCFG_PADSEL_M: any = '3'\nexport const IOC_DTBCFG_PADSEL_S: any = '3'\n/**\nDTB[2:0] selected*/\nexport const IOC_DTBCFG_PADSEL_DTB2TO0: any = '5'\n\n/**\nDTB[5:3] selected*/\nexport const IOC_DTBCFG_PADSEL_DTB5TO3: any = '4'\n\n/**\nDTB[8:6] selected*/\nexport const IOC_DTBCFG_PADSEL_DTB8TO6: any = '3'\n\n/**\nDTB[11:9] selected*/\nexport const IOC_DTBCFG_PADSEL_DTB11TO9: any = '2'\n\n/**\nDTB[14:12] selected*/\nexport const IOC_DTBCFG_PADSEL_DTB14TO12: any = '1'\n\n/**\nDTB[15:13] selected*/\nexport const IOC_DTBCFG_PADSEL_DTB15TO13: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_DTBCFG_RESERVED13: any = '3'\nexport const IOC_DTBCFG_RESERVED13_M: any = '3'\nexport const IOC_DTBCFG_RESERVED13_S: any = '3'\n/**\nULL DTB Mux selection*/\nexport const IOC_DTBCFG_ULLSEL: any = '5'\nexport const IOC_DTBCFG_ULLSEL_M: any = '5'\nexport const IOC_DTBCFG_ULLSEL_S: any = '5'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_DTBCFG_RESERVED5: any = '3'\nexport const IOC_DTBCFG_RESERVED5_M: any = '3'\nexport const IOC_DTBCFG_RESERVED5_S: any = '3'\n/**\nSVT DTB Mux selection*/\nexport const IOC_DTBCFG_SVTSEL: any = '5'\nexport const IOC_DTBCFG_SVTSEL_M: any = '5'\nexport const IOC_DTBCFG_SVTSEL_S: any = '5'\n\n// -------- REGISTER DTBOE -------- //\n\n/**\nDTB output enable*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_DTBOE_RESERVED16: any = '16'\nexport const IOC_DTBOE_RESERVED16_M: any = '16'\nexport const IOC_DTBOE_RESERVED16_S: any = '16'\n/**\nEnables DTB output 15*/\nexport const IOC_DTBOE_EN15: any = '1'\nexport const IOC_DTBOE_EN15_M: any = '1'\nexport const IOC_DTBOE_EN15_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN15_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN15_DIS: any = '0'\n\n/**\nEnables DTB output 14*/\nexport const IOC_DTBOE_EN14: any = '1'\nexport const IOC_DTBOE_EN14_M: any = '1'\nexport const IOC_DTBOE_EN14_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN14_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN14_DIS: any = '0'\n\n/**\nEnables DTB output 13*/\nexport const IOC_DTBOE_EN13: any = '1'\nexport const IOC_DTBOE_EN13_M: any = '1'\nexport const IOC_DTBOE_EN13_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN13_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN13_DIS: any = '0'\n\n/**\nEnables DTB output 12*/\nexport const IOC_DTBOE_EN12: any = '1'\nexport const IOC_DTBOE_EN12_M: any = '1'\nexport const IOC_DTBOE_EN12_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN12_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN12_DIS: any = '0'\n\n/**\nEnables DTB output 11*/\nexport const IOC_DTBOE_EN11: any = '1'\nexport const IOC_DTBOE_EN11_M: any = '1'\nexport const IOC_DTBOE_EN11_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN11_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN11_DIS: any = '0'\n\n/**\nEnables DTB output 10*/\nexport const IOC_DTBOE_EN10: any = '1'\nexport const IOC_DTBOE_EN10_M: any = '1'\nexport const IOC_DTBOE_EN10_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN10_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN10_DIS: any = '0'\n\n/**\nEnables DTB output 9*/\nexport const IOC_DTBOE_EN9: any = '1'\nexport const IOC_DTBOE_EN9_M: any = '1'\nexport const IOC_DTBOE_EN9_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN9_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN9_DIS: any = '0'\n\n/**\nEnables DTB output 8*/\nexport const IOC_DTBOE_EN8: any = '1'\nexport const IOC_DTBOE_EN8_M: any = '1'\nexport const IOC_DTBOE_EN8_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN8_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN8_DIS: any = '0'\n\n/**\nEnables DTB output 7*/\nexport const IOC_DTBOE_EN7: any = '1'\nexport const IOC_DTBOE_EN7_M: any = '1'\nexport const IOC_DTBOE_EN7_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN7_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN7_DIS: any = '0'\n\n/**\nEnables DTB output 6*/\nexport const IOC_DTBOE_EN6: any = '1'\nexport const IOC_DTBOE_EN6_M: any = '1'\nexport const IOC_DTBOE_EN6_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN6_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN6_DIS: any = '0'\n\n/**\nEnables DTB output 5*/\nexport const IOC_DTBOE_EN5: any = '1'\nexport const IOC_DTBOE_EN5_M: any = '1'\nexport const IOC_DTBOE_EN5_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN5_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN5_DIS: any = '0'\n\n/**\nEnables DTB output 4*/\nexport const IOC_DTBOE_EN4: any = '1'\nexport const IOC_DTBOE_EN4_M: any = '1'\nexport const IOC_DTBOE_EN4_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN4_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN4_DIS: any = '0'\n\n/**\nEnables DTB output 3*/\nexport const IOC_DTBOE_EN3: any = '1'\nexport const IOC_DTBOE_EN3_M: any = '1'\nexport const IOC_DTBOE_EN3_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN3_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN3_DIS: any = '0'\n\n/**\nEnables DTB output 2*/\nexport const IOC_DTBOE_EN2: any = '1'\nexport const IOC_DTBOE_EN2_M: any = '1'\nexport const IOC_DTBOE_EN2_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN2_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN2_DIS: any = '0'\n\n/**\nEnables DTB output 1*/\nexport const IOC_DTBOE_EN1: any = '1'\nexport const IOC_DTBOE_EN1_M: any = '1'\nexport const IOC_DTBOE_EN1_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN1_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN1_DIS: any = '0'\n\n/**\nEnables DTB output 0*/\nexport const IOC_DTBOE_EN0: any = '1'\nexport const IOC_DTBOE_EN0_M: any = '1'\nexport const IOC_DTBOE_EN0_S: any = '1'\n/**\nDTB output enabled*/\nexport const IOC_DTBOE_EN0_EN: any = '1'\n\n/**\nDTB output disabled*/\nexport const IOC_DTBOE_EN0_DIS: any = '0'\n\n\n// -------- REGISTER EVTCFG -------- //\n\n/**\nEvent configuration. This register is used to select DIO for IOC to publish event on ULL event fabric. It also contains enable bit that is used to mask the event and event flag bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_EVTCFG_RESERVED9: any = '23'\nexport const IOC_EVTCFG_RESERVED9_M: any = '23'\nexport const IOC_EVTCFG_RESERVED9_S: any = '23'\n/**\nEvent flag. It is set when edge is detected on selected DIO.\n\nNote: The edge detector flop is cleared for the selected DIO when EVTIFG is cleared by software.*/\nexport const IOC_EVTCFG_EVTIFG: any = '1'\nexport const IOC_EVTCFG_EVTIFG_M: any = '1'\nexport const IOC_EVTCFG_EVTIFG_S: any = '1'\n/**\nSet ULL event*/\nexport const IOC_EVTCFG_EVTIFG_SET: any = '1'\n\n/**\nClear ULL event*/\nexport const IOC_EVTCFG_EVTIFG_CLR: any = '0'\n\n/**\nEnables IOC to publish event on AON event fabric when EVTIFG is set. */\nexport const IOC_EVTCFG_EVTEN: any = '1'\nexport const IOC_EVTCFG_EVTEN_M: any = '1'\nexport const IOC_EVTCFG_EVTEN_S: any = '1'\n/**\nEnable*/\nexport const IOC_EVTCFG_EVTEN_EN: any = '1'\n\n/**\nDisable*/\nexport const IOC_EVTCFG_EVTEN_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_EVTCFG_RESERVED6: any = '1'\nexport const IOC_EVTCFG_RESERVED6_M: any = '1'\nexport const IOC_EVTCFG_RESERVED6_S: any = '1'\n/**\nThis is used to select DIO for event generation. For example, DIOSEL = 0x0 selects DIO0 and DIOSEL = 0x8 selects DIO8.*/\nexport const IOC_EVTCFG_DIOSEL: any = '6'\nexport const IOC_EVTCFG_DIOSEL_M: any = '6'\nexport const IOC_EVTCFG_DIOSEL_S: any = '6'\n\n// -------- REGISTER TEST -------- //\n\n/**\nTest register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_TEST_RESERVED1: any = '31'\nexport const IOC_TEST_RESERVED1_M: any = '31'\nexport const IOC_TEST_RESERVED1_S: any = '31'\n/**\nThis is used to drive SWDIO (Serial Wire DIO) output data and output enable from debug sub-system onto DIO12 (Test Data Output) pad.*/\nexport const IOC_TEST_SEL: any = '1'\nexport const IOC_TEST_SEL_M: any = '1'\nexport const IOC_TEST_SEL_S: any = '1'\n/**\nOutput data and output enable driven based on debug sub-system inputs*/\nexport const IOC_TEST_SEL_HI: any = '1'\n\n/**\nOutput data and output enable managed by IOC*/\nexport const IOC_TEST_SEL_LO: any = '0'\n\n\n// -------- REGISTER DTBSTAT -------- //\n\n/**\nDTB status register.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const IOC_DTBSTAT_RESERVED16: any = '16'\nexport const IOC_DTBSTAT_RESERVED16_M: any = '16'\nexport const IOC_DTBSTAT_RESERVED16_S: any = '16'\n/**\nThis bit field captures the final 16-bit value of DTB signals provided from IOC to device pins.*/\nexport const IOC_DTBSTAT_VAL: any = '16'\nexport const IOC_DTBSTAT_VAL_M: any = '16'\nexport const IOC_DTBSTAT_VAL_S: any = '16'\n\n// -------- MODULE LGPT -------- //\n\nexport interface LGPT_t {\n    DESC: em.$Reg\n    DESCEX: em.$Reg\n    STARTCFG: em.$Reg\n    CTL: em.$Reg\n    OUTCTL: em.$Reg\n    CNTR: em.$Reg\n    PRECFG: em.$Reg\n    PREEVENT: em.$Reg\n    CHFILT: em.$Reg\n    QDECSTAT: em.$Reg\n    IRGEN: em.$Reg\n    DMA: em.$Reg\n    DMARW: em.$Reg\n    ADCTRG: em.$Reg\n    IOCTL: em.$Reg\n    IMASK: em.$Reg\n    RIS: em.$Reg\n    MIS: em.$Reg\n    ISET: em.$Reg\n    ICLR: em.$Reg\n    IMSET: em.$Reg\n    IMCLR: em.$Reg\n    EMU: em.$Reg\n    C0CFG: em.$Reg\n    C1CFG: em.$Reg\n    C2CFG: em.$Reg\n    PTGT: em.$Reg\n    PC0CC: em.$Reg\n    PC1CC: em.$Reg\n    PC2CC: em.$Reg\n    TGT: em.$Reg\n    C0CC: em.$Reg\n    C1CC: em.$Reg\n    C2CC: em.$Reg\n    PTGTNC: em.$Reg\n    PC0CCNC: em.$Reg\n    PC1CCNC: em.$Reg\n    PC2CCNC: em.$Reg\n    TGTNC: em.$Reg\n    C0CCNC: em.$Reg\n    C1CCNC: em.$Reg\n    C2CCNC: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription Register.\n\n\nThis register provides IP module ID, revision information, instance index and standard MMR registers offset.*/\n/**\nModule identifier used to uniquely identify this IP.\n\n*/\nexport const LGPT_DESC_MODID: any = '16'\nexport const LGPT_DESC_MODID_M: any = '16'\nexport const LGPT_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set of from aggregated IRQ registers till DTB.\n\n\n0: Standard IP MMRs do not exist\n\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)*/\nexport const LGPT_DESC_STDIPOFF: any = '4'\nexport const LGPT_DESC_STDIPOFF_M: any = '4'\nexport const LGPT_DESC_STDIPOFF_S: any = '4'\n/**\nIP Instance ID number. If multiple instances of IP exist in the device, this field can identify the instance number.*/\nexport const LGPT_DESC_INSTIDX: any = '4'\nexport const LGPT_DESC_INSTIDX_M: any = '4'\nexport const LGPT_DESC_INSTIDX_S: any = '4'\n/**\nMajor revision of IP.*/\nexport const LGPT_DESC_MAJREV: any = '4'\nexport const LGPT_DESC_MAJREV_M: any = '4'\nexport const LGPT_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP.*/\nexport const LGPT_DESC_MINREV: any = '4'\nexport const LGPT_DESC_MINREV_M: any = '4'\nexport const LGPT_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER DESCEX -------- //\n\n/**\nDescription Extended\n\n\nThis register describes the parameters of the LGPT.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_DESCEX_RESERVED20: any = '12'\nexport const LGPT_DESCEX_RESERVED20_M: any = '12'\nexport const LGPT_DESCEX_RESERVED20_S: any = '12'\n/**\nHas IR logic.*/\nexport const LGPT_DESCEX_HIR: any = '1'\nexport const LGPT_DESCEX_HIR_M: any = '1'\nexport const LGPT_DESCEX_HIR_S: any = '1'\n/**\nHas Dead-Band, Fault, and Park logic.*/\nexport const LGPT_DESCEX_HDBF: any = '1'\nexport const LGPT_DESCEX_HDBF_M: any = '1'\nexport const LGPT_DESCEX_HDBF_S: any = '1'\n/**\nPrescale width. The prescaler can maximum be configured to 2^PREW-1.*/\nexport const LGPT_DESCEX_PREW: any = '4'\nexport const LGPT_DESCEX_PREW_M: any = '4'\nexport const LGPT_DESCEX_PREW_S: any = '4'\n/**\nHas Quadrature Decoder.*/\nexport const LGPT_DESCEX_HQDEC: any = '1'\nexport const LGPT_DESCEX_HQDEC_M: any = '1'\nexport const LGPT_DESCEX_HQDEC_S: any = '1'\n/**\nHas channel input filter.*/\nexport const LGPT_DESCEX_HCIF: any = '1'\nexport const LGPT_DESCEX_HCIF_M: any = '1'\nexport const LGPT_DESCEX_HCIF_S: any = '1'\n/**\nChannel input filter size. The prevailing state filter can maximum be configured to 2^CIFS-1.*/\nexport const LGPT_DESCEX_CIFS: any = '4'\nexport const LGPT_DESCEX_CIFS_M: any = '4'\nexport const LGPT_DESCEX_CIFS_S: any = '4'\n/**\nHas uDMA output and logic.*/\nexport const LGPT_DESCEX_HDMA: any = '1'\nexport const LGPT_DESCEX_HDMA_M: any = '1'\nexport const LGPT_DESCEX_HDMA_S: any = '1'\n/**\nHas interrupt output and logic.*/\nexport const LGPT_DESCEX_HINT: any = '1'\nexport const LGPT_DESCEX_HINT_M: any = '1'\nexport const LGPT_DESCEX_HINT_S: any = '1'\n/**\nCounter bit-width.\n\nThe maximum counter value is equal to 2^CNTRW-1.\n*/\nexport const LGPT_DESCEX_CNTRW: any = '2'\nexport const LGPT_DESCEX_CNTRW_M: any = '2'\nexport const LGPT_DESCEX_CNTRW_S: any = '2'\n/**\nRESERVED*/\nexport const LGPT_DESCEX_CNTRW_RESERVED: any = '3'\n\n/**\n32-bit counter.*/\nexport const LGPT_DESCEX_CNTRW_CNTR32: any = '2'\n\n/**\n24-bit counter.*/\nexport const LGPT_DESCEX_CNTRW_CNTR24: any = '1'\n\n/**\n16-bit counter.*/\nexport const LGPT_DESCEX_CNTRW_CNTR16: any = '0'\n\n/**\nNumber of channels.*/\nexport const LGPT_DESCEX_NCH: any = '4'\nexport const LGPT_DESCEX_NCH_M: any = '4'\nexport const LGPT_DESCEX_NCH_S: any = '4'\n\n// -------- REGISTER STARTCFG -------- //\n\n/**\nStart Configuration\n\n\nThis register is only for when CTL.MODE is configured to one of the SYNC modes.\nThis register defines when this LGPT starts.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_STARTCFG_RESERVED2: any = '30'\nexport const LGPT_STARTCFG_RESERVED2_M: any = '30'\nexport const LGPT_STARTCFG_RESERVED2_S: any = '30'\n/**\nLGPT start\n\n*/\nexport const LGPT_STARTCFG_LGPT0: any = '2'\nexport const LGPT_STARTCFG_LGPT0_M: any = '2'\nexport const LGPT_STARTCFG_LGPT0_S: any = '2'\n/**\nLGPT starts when synchronized event input is high. Configured here EVTSVT.LGPTSYNCSEL.*/\nexport const LGPT_STARTCFG_LGPT0_EV_SYNC: any = '0'\n\n\n// -------- REGISTER CTL -------- //\n\n/**\nTimer Control*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_CTL_RESERVED11: any = '21'\nexport const LGPT_CTL_RESERVED11_M: any = '21'\nexport const LGPT_CTL_RESERVED11_S: any = '21'\n/**\nChannel 2 reset.*/\nexport const LGPT_CTL_C2RST: any = '1'\nexport const LGPT_CTL_C2RST_M: any = '1'\nexport const LGPT_CTL_C2RST_S: any = '1'\n/**\nReset C2CC, PC2CC, and C2CFG.*/\nexport const LGPT_CTL_C2RST_RST: any = '1'\n\n/**\nNo effect.*/\nexport const LGPT_CTL_C2RST_NOEFF: any = '0'\n\n/**\nChannel 1 reset.*/\nexport const LGPT_CTL_C1RST: any = '1'\nexport const LGPT_CTL_C1RST_M: any = '1'\nexport const LGPT_CTL_C1RST_S: any = '1'\n/**\nReset C1CC, PC1CC, and C1CFG.*/\nexport const LGPT_CTL_C1RST_RST: any = '1'\n\n/**\nNo effect.*/\nexport const LGPT_CTL_C1RST_NOEFF: any = '0'\n\n/**\nChannel 0 reset.*/\nexport const LGPT_CTL_C0RST: any = '1'\nexport const LGPT_CTL_C0RST_M: any = '1'\nexport const LGPT_CTL_C0RST_S: any = '1'\n/**\nReset C0CC, PC0CC, and C0CFG.*/\nexport const LGPT_CTL_C0RST_RST: any = '1'\n\n/**\nNo effect.*/\nexport const LGPT_CTL_C0RST_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_CTL_RESERVED6: any = '2'\nexport const LGPT_CTL_RESERVED6_M: any = '2'\nexport const LGPT_CTL_RESERVED6_S: any = '2'\n/**\nInterrupt Phase.\n\nThis bit field controls when the RIS.TGT and RIS.ZERO interrupts are set.*/\nexport const LGPT_CTL_INTP: any = '1'\nexport const LGPT_CTL_INTP_M: any = '1'\nexport const LGPT_CTL_INTP_S: any = '1'\n/**\nRIS.TGT and RIS.ZERO are set one timer clock cycle after CNTR = TARGET/ZERO.*/\nexport const LGPT_CTL_INTP_LATE: any = '1'\n\n/**\nRIS.TGT and RIS.ZERO are set one system clock cycle after CNTR = TARGET/ZERO.*/\nexport const LGPT_CTL_INTP_EARLY: any = '0'\n\n/**\nCompare direction.\n\n\nThis bit field controls the direction the counter must have in order to set the [RIS.CnCC] channel interrupts. This bitfield is only relevant if [CnCFG.CCACT] is configured to a compare action. */\nexport const LGPT_CTL_CMPDIR: any = '2'\nexport const LGPT_CTL_CMPDIR_M: any = '2'\nexport const LGPT_CTL_CMPDIR_S: any = '2'\n/**\nRESERVED*/\nexport const LGPT_CTL_CMPDIR_RESERVED: any = '3'\n\n/**\nCompare RIS fields are only set on down count.*/\nexport const LGPT_CTL_CMPDIR_DOWN: any = '2'\n\n/**\nCompare RIS fields are only set on up count.*/\nexport const LGPT_CTL_CMPDIR_UP: any = '1'\n\n/**\nCompare RIS fields are set on up count and down count.*/\nexport const LGPT_CTL_CMPDIR_BOTH: any = '0'\n\n/**\nTimer mode control\n\n\nThe CNTR restarts from 0 when MODE is written to UP_ONCE, UP_PER, UPDWN_PER, QDEC, SYNC_UP_ONCE, SYNC_UP_PER or SYNC_UPDWN_PER.\n\nWhen writing MODE all internally queued updates to the channels and TGT is cleared.\n\nWhen configuring the timer, MODE should be the last thing to configure. If changing timer configuration after MODE has been set is necessary, instructions, if any, given in the configuration registers should be followed. See for example C0CFG.\n*/\nexport const LGPT_CTL_MODE: any = '3'\nexport const LGPT_CTL_MODE_M: any = '3'\nexport const LGPT_CTL_MODE_S: any = '3'\n/**\nStart counting up and down periodically synchronous to another LGPT,  selected within STARTCFG. The timer is started by setting CTL.MODE = UPDWN_PER automatically. \n\nIt then operates as a normal timer in CTL.MODE = UPDWN_PER, counting from 0 to target value and back to 0, repeatedly.\n\nPeriod =  (target value * 2) * timer clock period*/\nexport const LGPT_CTL_MODE_SYNC_UPDWN_PER: any = '7'\n\n/**\nStart counting up periodically synchronous to another LGPT,  selected within STARTCFG. The timer is started by setting CTL.MODE = UP_PER automatically. \n\nIt then operates as a normal timer in CTL.MODE = UP_PER, incrementing from 0 to target value, repeatedly.\n\nPeriod =  (target value * 2) * timer clock period\n*/\nexport const LGPT_CTL_MODE_SYNC_UP_PER: any = '6'\n\n/**\nStart counting up once synchronous to another LGPT, selected within STARTCFG. The timer is started by setting CTL.MODE = UP_ONCE automatically. \n\nIt then functions as a normal timer in CTL.MODE = UP_ONCE, incrementing from 0 to target value,  then stops and sets MODE to DIS.\n*/\nexport const LGPT_CTL_MODE_SYNC_UP_ONCE: any = '5'\n\n/**\nThe timer functions as a quadrature decoder. IOC input 0, IOC input 1 and IOC input 2 are used respectivly as PHA, PHB and IDX inputs. IDX can be turned off by setting C2CFG.EDGE = NONE.\n\nThe timer clock frequency sets the sample rate of the QDEC logic. This frequency can be configured in PRECFG.*/\nexport const LGPT_CTL_MODE_QDEC: any = '4'\n\n/**\nCount up and down periodically. The timer counts from 0 to target value and back to 0, repeatedly.\n\n\nPeriod =  (target value * 2) * timer clock period*/\nexport const LGPT_CTL_MODE_UPDWN_PER: any = '3'\n\n/**\nCount up periodically. The timer increments from 0 to target value, repeatedly.\n\n\nPeriod = (target value + 1) * timer clock period*/\nexport const LGPT_CTL_MODE_UP_PER: any = '2'\n\n/**\nCount up once. The timer increments from 0 to target value,  then stops and sets MODE to DIS.*/\nexport const LGPT_CTL_MODE_UP_ONCE: any = '1'\n\n/**\nDisable timer. Updates to counter, channels, and events stop.*/\nexport const LGPT_CTL_MODE_DIS: any = '0'\n\n\n// -------- REGISTER OUTCTL -------- //\n\n/**\nOutput Control\n\n\nSet and clear individual outputs manually. Manual update of an output takes priority over automatic channel updates to the same output. It is not possible to set and clear an output at the same time, such requests will be neglected.\n\nAn output can be automatically cleared, set, toggled, or pulsed by each channel, listed in decreasing order of priority. The action with highest priority happens when multiple channels want to update an output at the same time.\n\nAll outputs are connected to the event fabric and the IO controller. The outputs going to the IO controller have an aditional complementary output, this output is the inverted IO output. Both the IO and the IO complementary outputs are passed through an IO Controller, see IOCTL.\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_OUTCTL_RESERVED6: any = '26'\nexport const LGPT_OUTCTL_RESERVED6_M: any = '26'\nexport const LGPT_OUTCTL_RESERVED6_S: any = '26'\n/**\nSet output 2.\n\n\nWrite 1 to set output 2.*/\nexport const LGPT_OUTCTL_SETOUT2: any = '1'\nexport const LGPT_OUTCTL_SETOUT2_M: any = '1'\nexport const LGPT_OUTCTL_SETOUT2_S: any = '1'\n/**\nClear output 2.\n\n\nWrite 1 to clear output 2.*/\nexport const LGPT_OUTCTL_CLROUT2: any = '1'\nexport const LGPT_OUTCTL_CLROUT2_M: any = '1'\nexport const LGPT_OUTCTL_CLROUT2_S: any = '1'\n/**\nSet output 1.\n\n\nWrite 1 to set output 1.*/\nexport const LGPT_OUTCTL_SETOUT1: any = '1'\nexport const LGPT_OUTCTL_SETOUT1_M: any = '1'\nexport const LGPT_OUTCTL_SETOUT1_S: any = '1'\n/**\nClear output 1.\n\n\nWrite 1 to clear output 1.*/\nexport const LGPT_OUTCTL_CLROUT1: any = '1'\nexport const LGPT_OUTCTL_CLROUT1_M: any = '1'\nexport const LGPT_OUTCTL_CLROUT1_S: any = '1'\n/**\nSet output 0.\n\n\nWrite 1 to set output 0.*/\nexport const LGPT_OUTCTL_SETOUT0: any = '1'\nexport const LGPT_OUTCTL_SETOUT0_M: any = '1'\nexport const LGPT_OUTCTL_SETOUT0_S: any = '1'\n/**\nClear output 0.\n\n\nWrite 1 to clear output 0.*/\nexport const LGPT_OUTCTL_CLROUT0: any = '1'\nexport const LGPT_OUTCTL_CLROUT0_M: any = '1'\nexport const LGPT_OUTCTL_CLROUT0_S: any = '1'\n\n// -------- REGISTER CNTR -------- //\n\n/**\nCounter\n\nThe counter of this timer. After CTL.MODE is set the counter updates at the rate specified in PRECFG.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_CNTR_RESERVED16: any = '16'\nexport const LGPT_CNTR_RESERVED16_M: any = '16'\nexport const LGPT_CNTR_RESERVED16_S: any = '16'\n/**\nCurrent counter value.\n\nIf CTL.MODE = QDEC this can be used to set the initial counter value during QDEC.  Writing to CNTR in other modes than QDEC is possible, but may result in unpredictable behavior.*/\nexport const LGPT_CNTR_VAL: any = '16'\nexport const LGPT_CNTR_VAL_M: any = '16'\nexport const LGPT_CNTR_VAL_S: any = '16'\n\n// -------- REGISTER PRECFG -------- //\n\n/**\nClock Prescaler Configuration\n\n\nThis register is used to set the timer clock period. The prescaler is a counter which counts down from the value TICKDIV. When the prescaler counter reaches zero, CNTR is updated. The field TICKDIV effectively divides the prescaler tick source. The timer clock frequency can be calculated as TICKSRC/(TICKDIV+1).*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PRECFG_RESERVED16: any = '16'\nexport const LGPT_PRECFG_RESERVED16_M: any = '16'\nexport const LGPT_PRECFG_RESERVED16_S: any = '16'\n/**\nTick division.\n\n\nTICKDIV determines the timer clock frequency for the counter, and timer output updates. The timer clock frequency is the clock selected by TICKSRC divided by (TICKDIV + 1). This inverse is the timer clock period.\n\n0x00: Divide by 1.\n0x01: Divide by 2.\n... \n0xFF: Divide by 256.*/\nexport const LGPT_PRECFG_TICKDIV: any = '8'\nexport const LGPT_PRECFG_TICKDIV_M: any = '8'\nexport const LGPT_PRECFG_TICKDIV_S: any = '8'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PRECFG_RESERVED2: any = '6'\nexport const LGPT_PRECFG_RESERVED2_M: any = '6'\nexport const LGPT_PRECFG_RESERVED2_S: any = '6'\n/**\nPrescaler tick source.\n\n\nTICKSRC determines the source which decrements the prescaler.*/\nexport const LGPT_PRECFG_TICKSRC: any = '2'\nexport const LGPT_PRECFG_TICKSRC_M: any = '2'\nexport const LGPT_PRECFG_TICKSRC_S: any = '2'\n/**\nPrescaler is updated at both edges of TICKEN.*/\nexport const LGPT_PRECFG_TICKSRC_BOTH_TICK: any = '3'\n\n/**\nPrescaler is updated at the falling edge of TICKEN.*/\nexport const LGPT_PRECFG_TICKSRC_FALL_TICK: any = '2'\n\n/**\nPrescaler is updated at the rising edge of TICKEN.*/\nexport const LGPT_PRECFG_TICKSRC_RISE_TICK: any = '1'\n\n/**\nPrescaler is updated at the system clock.*/\nexport const LGPT_PRECFG_TICKSRC_CLK: any = '0'\n\n\n// -------- REGISTER PREEVENT -------- //\n\n/**\nPrescaler Event\n\n\nThis register is used to output a logic high signal before the zero crossing of the prescaler counter. The output is routed to the IOC.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PREEVENT_RESERVED8: any = '24'\nexport const LGPT_PREEVENT_RESERVED8_M: any = '24'\nexport const LGPT_PREEVENT_RESERVED8_S: any = '24'\n/**\nSets the HIGH time of the prescaler event output. \n\n\nEvent goes high when the prescaler counter equals VAL. Event goes low when prescaler counter is 0.\n\nNote:\n- Can be used to precharge or turn an external component on for a short time before sampling, like in QDEC.\n- If there is a requirement to create such events that have very short periods compared to timer clock period, use two timers. One timer acts as prescaler and event generator for another timer.*/\nexport const LGPT_PREEVENT_VAL: any = '8'\nexport const LGPT_PREEVENT_VAL_M: any = '8'\nexport const LGPT_PREEVENT_VAL_S: any = '8'\n\n// -------- REGISTER CHFILT -------- //\n\n/**\nChannel Input Filter\n\n\nThis register is used to configure the filter on the channel inputs. The configuration is for all inputs.\nThe filter is enabled when a channel is in capture mode.\n\nThe input to the filter is passed to the edge detection logic if LOAD + 1 consecutive input samples are equal. The filter functions as a down counter, counting down every input sample.\nIf two consecutive samples are unequal, the filter counter restarts from LOAD.\nIf the filter counter reaches zero, the input signal is valid and passed to the edge detection logic.\n\nThe channel filter should only be configured while the CTL.MODE = DIS. Configuring the filter while the timer is running can result in unexpected behavior.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_CHFILT_RESERVED16: any = '16'\nexport const LGPT_CHFILT_RESERVED16_M: any = '16'\nexport const LGPT_CHFILT_RESERVED16_S: any = '16'\n/**\nThe input of the channel filter is passed to the edge detection logic after LOAD + 1 consecutive equal samples.*/\nexport const LGPT_CHFILT_LOAD: any = '8'\nexport const LGPT_CHFILT_LOAD_M: any = '8'\nexport const LGPT_CHFILT_LOAD_S: any = '8'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_CHFILT_RESERVED2: any = '6'\nexport const LGPT_CHFILT_RESERVED2_M: any = '6'\nexport const LGPT_CHFILT_RESERVED2_S: any = '6'\n/**\nChannel filter mode*/\nexport const LGPT_CHFILT_MODE: any = '2'\nexport const LGPT_CHFILT_MODE_M: any = '2'\nexport const LGPT_CHFILT_MODE_S: any = '2'\n/**\nFilter is clocked by timer clock.*/\nexport const LGPT_CHFILT_MODE_TIMERCLK: any = '3'\n\n/**\nFilter is clocked by PRECFG.TICKSRC.*/\nexport const LGPT_CHFILT_MODE_TICKSRC: any = '2'\n\n/**\nFilter is clocked by system clock.*/\nexport const LGPT_CHFILT_MODE_CLK: any = '1'\n\n/**\nFilter is bypassed. No Filter is used.*/\nexport const LGPT_CHFILT_MODE_BYPASS: any = '0'\n\n\n// -------- REGISTER QDECSTAT -------- //\n\n/**\nQuadrature Decoder Status\n\n\nThis register can be used during QDEC mode to check the status of the quadrature decoder.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_QDECSTAT_RESERVED2: any = '30'\nexport const LGPT_QDECSTAT_RESERVED2_M: any = '30'\nexport const LGPT_QDECSTAT_RESERVED2_S: any = '30'\n/**\nDouble transition*/\nexport const LGPT_QDECSTAT_DBLTRANS: any = '1'\nexport const LGPT_QDECSTAT_DBLTRANS_M: any = '1'\nexport const LGPT_QDECSTAT_DBLTRANS_S: any = '1'\n/**\nDouble transition on phase inputs.*/\nexport const LGPT_QDECSTAT_DBLTRANS_DBL: any = '1'\n\n/**\nSingle or no transition on phase inputs.*/\nexport const LGPT_QDECSTAT_DBLTRANS_NONE: any = '0'\n\n/**\nDirection of count during QDEC mode.*/\nexport const LGPT_QDECSTAT_QDIR: any = '1'\nexport const LGPT_QDECSTAT_QDIR_M: any = '1'\nexport const LGPT_QDECSTAT_QDIR_S: any = '1'\n/**\nDown (PHB leads PHA)*/\nexport const LGPT_QDECSTAT_QDIR_DOWN: any = '1'\n\n/**\nUp (PHA leads PHB)*/\nexport const LGPT_QDECSTAT_QDIR_UP: any = '0'\n\n\n// -------- REGISTER IRGEN -------- //\n\n/**\nIR Generation\n\n\nUse this register to generate IR codes. When CTL = 1, an AND gate is enabled between IO output 0 in LGPT0 and IC output 0 in LGPT1. The output of the gate overrides IO output 0 in LGPT0. See OUTCTL for explanation of outputs. \n\nTo generate IR codes let LGPT0 generate the carrier wave on output 0. Set this output as tick input of LGPT1, with PRECFG.TICKSRC = FALL_TICK. \nGenerate wanted IR codes by adjusting LGPT1 PTGT and PC0CC. */\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_IRGEN_RESERVED1: any = '31'\nexport const LGPT_IRGEN_RESERVED1_M: any = '31'\nexport const LGPT_IRGEN_RESERVED1_S: any = '31'\n/**\nControl\n\n*/\nexport const LGPT_IRGEN_CTL: any = '1'\nexport const LGPT_IRGEN_CTL_M: any = '1'\nexport const LGPT_IRGEN_CTL_S: any = '1'\n/**\nEnable.*/\nexport const LGPT_IRGEN_CTL_EN: any = '1'\n\n/**\nDisable.*/\nexport const LGPT_IRGEN_CTL_DIS: any = '0'\n\n\n// -------- REGISTER DMA -------- //\n\n/**\nDirect Memory Accsess\n\n\nThis register is used to enable DMA requests from the timer and set the register addresses which the DMA will access (read/write).\nChoose DMA request source by setting the REQ field. The setting of the corresponding interrupt in the RIS registers also sets the DMA request. \nUpon a DMA request defined by REQ an internal address pointer is set to RWADDR*4. Every access to DMARW will increment the internal pointer by 4 such that the next DMA access will be to the next register.\nThe internal pointer will stop after RWCNTR increments. Further access will be ignored.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_DMA_RESERVED20: any = '12'\nexport const LGPT_DMA_RESERVED20_M: any = '12'\nexport const LGPT_DMA_RESERVED20_S: any = '12'\n/**\nThe read/write counter. RWCNTR+1 is the number of times the DMA can access (read/write) the DMARW register. For each DMA access to DMARW an internal counter is incremented, writing to the next address field. RWADDR + 4*RWCNTR is the final register address which can be accessed by the DMA.*/\nexport const LGPT_DMA_RWCNTR: any = '4'\nexport const LGPT_DMA_RWCNTR_M: any = '4'\nexport const LGPT_DMA_RWCNTR_S: any = '4'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_DMA_RESERVED15: any = '1'\nexport const LGPT_DMA_RESERVED15_M: any = '1'\nexport const LGPT_DMA_RESERVED15_S: any = '1'\n/**\nThe base address which the DMA access when reading/writing DMARW.  The base address is set by taking the 9 LSB of the physical address and divide by 4.\n\nFor example, if you wanted the RWADDR to point to the PTGT register you should set RWADDR = 0x0FC/4.*/\nexport const LGPT_DMA_RWADDR: any = '7'\nexport const LGPT_DMA_RWADDR_M: any = '7'\nexport const LGPT_DMA_RWADDR_S: any = '7'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_DMA_RESERVED4: any = '4'\nexport const LGPT_DMA_RESERVED4_M: any = '4'\nexport const LGPT_DMA_RESERVED4_S: any = '4'\n/**\n*/\nexport const LGPT_DMA_REQ: any = '4'\nexport const LGPT_DMA_REQ_M: any = '4'\nexport const LGPT_DMA_REQ_S: any = '4'\n/**\nSetting of RIS.C11CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C11CC: any = '15'\n\n/**\nSetting of RIS.C10CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C10CC: any = '14'\n\n/**\nSetting of RIS.C9CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C9CC: any = '13'\n\n/**\nSetting of RIS.C8CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C8CC: any = '12'\n\n/**\nSetting of RIS.C7CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C7CC: any = '11'\n\n/**\nSetting of RIS.C6CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C6CC: any = '10'\n\n/**\nSetting of RIS.C5CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C5CC: any = '9'\n\n/**\nSetting of RIS.C4CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C4CC: any = '8'\n\n/**\nSetting of RIS.C3CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C3CC: any = '7'\n\n/**\nSetting of RIS.C2CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C2CC: any = '6'\n\n/**\nSetting of RIS.C1CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C1CC: any = '5'\n\n/**\nSetting of RIS.C0CC generates a DMA request.*/\nexport const LGPT_DMA_REQ_C0CC: any = '4'\n\n/**\nSetting of RIS.FAULT generates a DMA request.*/\nexport const LGPT_DMA_REQ_FAULT: any = '3'\n\n/**\nSetting of RIS.ZERO generates a DMA request.*/\nexport const LGPT_DMA_REQ_ZERO: any = '2'\n\n/**\nSetting of RIS.TGT generates a DMA request.\n\n*/\nexport const LGPT_DMA_REQ_TGT: any = '1'\n\n/**\nDisabled*/\nexport const LGPT_DMA_REQ_DIS: any = '0'\n\n\n// -------- REGISTER DMARW -------- //\n\n/**\nDirect Memory Access\n\n\nThis register is used by the DMA to access (read/write) register inside this LGPT module.\nEach access to this register will increment the internal DMA address counter. See DMA for description.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_DMARW_RESERVED16: any = '16'\nexport const LGPT_DMARW_RESERVED16_M: any = '16'\nexport const LGPT_DMARW_RESERVED16_S: any = '16'\n/**\nDMA read write value.\n\n\nThe value that is read/written from/to the registers.*/\nexport const LGPT_DMARW_VAL: any = '16'\nexport const LGPT_DMARW_VAL_M: any = '16'\nexport const LGPT_DMARW_VAL_S: any = '16'\n\n// -------- REGISTER ADCTRG -------- //\n\n/**\nADC Trigger\n\n\nThis register is used to enable ADC trigger from the timer. \nChoose ADC trigger source by setting the SRC field. The setting of the corresponding interrupt in the RIS registers also sets the ADC trigger. */\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_ADCTRG_RESERVED4: any = '28'\nexport const LGPT_ADCTRG_RESERVED4_M: any = '28'\nexport const LGPT_ADCTRG_RESERVED4_S: any = '28'\n/**\n*/\nexport const LGPT_ADCTRG_SRC: any = '4'\nexport const LGPT_ADCTRG_SRC_M: any = '4'\nexport const LGPT_ADCTRG_SRC_S: any = '4'\n/**\nSetting of RIS.C11CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C11CC: any = '15'\n\n/**\nSetting of RIS.C10CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C10CC: any = '14'\n\n/**\nSetting of RIS.C9CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C9CC: any = '13'\n\n/**\nSetting of RIS.C8CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C8CC: any = '12'\n\n/**\nSetting of RIS.C7CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C7CC: any = '11'\n\n/**\nSetting of RIS.C6CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C6CC: any = '10'\n\n/**\nSetting of RIS.C5CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C5CC: any = '9'\n\n/**\nSetting of RIS.C4CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C4CC: any = '8'\n\n/**\nSetting of RIS.C3CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C3CC: any = '7'\n\n/**\nSetting of RIS.C2CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C2CC: any = '6'\n\n/**\nSetting of RIS.C1CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C1CC: any = '5'\n\n/**\nSetting of RIS.C0CC generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_C0CC: any = '4'\n\n/**\nSetting of RIS.FAULT generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_FAULT: any = '3'\n\n/**\nSetting of RIS.ZERO generates an ADC trigger.*/\nexport const LGPT_ADCTRG_SRC_ZERO: any = '2'\n\n/**\nSetting of RIS.TGT generates an ADC trigger.\n\n*/\nexport const LGPT_ADCTRG_SRC_TGT: any = '1'\n\n/**\nDisabled*/\nexport const LGPT_ADCTRG_SRC_DIS: any = '0'\n\n\n// -------- REGISTER IOCTL -------- //\n\n/**\nIO Controller\n\n\nThis register overrides the IO outputs.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_IOCTL_RESERVED12: any = '20'\nexport const LGPT_IOCTL_RESERVED12_M: any = '20'\nexport const LGPT_IOCTL_RESERVED12_S: any = '20'\n/**\nIO complementary output 2 control\n\n\nThis bit field controls IO complementary output 2. */\nexport const LGPT_IOCTL_COUT2: any = '2'\nexport const LGPT_IOCTL_COUT2_M: any = '2'\nexport const LGPT_IOCTL_COUT2_S: any = '2'\n/**\nInverted value. The IO complementary output is inverted.*/\nexport const LGPT_IOCTL_COUT2_INV: any = '3'\n\n/**\nDriven high. The IO complementary output is driven high.*/\nexport const LGPT_IOCTL_COUT2_HIGH: any = '2'\n\n/**\nDriven low. The IO complementary output is driven low.*/\nexport const LGPT_IOCTL_COUT2_LOW: any = '1'\n\n/**\nNormal output. The IO complementary output is not changed.*/\nexport const LGPT_IOCTL_COUT2_NRM: any = '0'\n\n/**\nIO output 2 control\n\n\nThis bit field controls IO output 2. */\nexport const LGPT_IOCTL_OUT2: any = '2'\nexport const LGPT_IOCTL_OUT2_M: any = '2'\nexport const LGPT_IOCTL_OUT2_S: any = '2'\n/**\nInverted value. The IO output is inverted.*/\nexport const LGPT_IOCTL_OUT2_INV: any = '3'\n\n/**\nDriven high. The IO output is driven high.*/\nexport const LGPT_IOCTL_OUT2_HIGH: any = '2'\n\n/**\nDriven low. The IO output is driven low.*/\nexport const LGPT_IOCTL_OUT2_LOW: any = '1'\n\n/**\nNormal output. The IO output is not changed.*/\nexport const LGPT_IOCTL_OUT2_NRM: any = '0'\n\n/**\nIO complementary output 1 control\n\n\nThis bit field controls IO complementary output 1. */\nexport const LGPT_IOCTL_COUT1: any = '2'\nexport const LGPT_IOCTL_COUT1_M: any = '2'\nexport const LGPT_IOCTL_COUT1_S: any = '2'\n/**\nInverted value. The IO complementary output is inverted.*/\nexport const LGPT_IOCTL_COUT1_INV: any = '3'\n\n/**\nDriven high. The IO complementary output is driven high.*/\nexport const LGPT_IOCTL_COUT1_HIGH: any = '2'\n\n/**\nDriven low. The IO complementary output is driven low.*/\nexport const LGPT_IOCTL_COUT1_LOW: any = '1'\n\n/**\nNormal output. The IO complementary output is not changed.*/\nexport const LGPT_IOCTL_COUT1_NRM: any = '0'\n\n/**\nIO output 1 control\n\n\nThis bit field controls IO output 1. */\nexport const LGPT_IOCTL_OUT1: any = '2'\nexport const LGPT_IOCTL_OUT1_M: any = '2'\nexport const LGPT_IOCTL_OUT1_S: any = '2'\n/**\nInverted value. The IO output is inverted.*/\nexport const LGPT_IOCTL_OUT1_INV: any = '3'\n\n/**\nDriven high. The IO output is driven high.*/\nexport const LGPT_IOCTL_OUT1_HIGH: any = '2'\n\n/**\nDriven low. The IO output is driven low.*/\nexport const LGPT_IOCTL_OUT1_LOW: any = '1'\n\n/**\nNormal output. The IO output is not changed.*/\nexport const LGPT_IOCTL_OUT1_NRM: any = '0'\n\n/**\nIO complementary output 0 control\n\n\nThis bit field controls IO complementary output 0. */\nexport const LGPT_IOCTL_COUT0: any = '2'\nexport const LGPT_IOCTL_COUT0_M: any = '2'\nexport const LGPT_IOCTL_COUT0_S: any = '2'\n/**\nInverted value. The IO complementary output is inverted.*/\nexport const LGPT_IOCTL_COUT0_INV: any = '3'\n\n/**\nDriven high. The IO complementary output is driven high.*/\nexport const LGPT_IOCTL_COUT0_HIGH: any = '2'\n\n/**\nDriven low. The IO complementary output is driven low.*/\nexport const LGPT_IOCTL_COUT0_LOW: any = '1'\n\n/**\nNormal output. The IO complementary output is not changed.*/\nexport const LGPT_IOCTL_COUT0_NRM: any = '0'\n\n/**\nIO output 0 control\n\n\nThis bit field controls IO output 0. */\nexport const LGPT_IOCTL_OUT0: any = '2'\nexport const LGPT_IOCTL_OUT0_M: any = '2'\nexport const LGPT_IOCTL_OUT0_S: any = '2'\n/**\nInverted value. The IO output is inverted.*/\nexport const LGPT_IOCTL_OUT0_INV: any = '3'\n\n/**\nDriven high. The IO output is driven high.*/\nexport const LGPT_IOCTL_OUT0_HIGH: any = '2'\n\n/**\nDriven low. The IO output is driven low.*/\nexport const LGPT_IOCTL_OUT0_LOW: any = '1'\n\n/**\nNormal output. The IO output is not changed.*/\nexport const LGPT_IOCTL_OUT0_NRM: any = '0'\n\n\n// -------- REGISTER IMASK -------- //\n\n/**\nInterrupt mask. \n\n\nThis register selects interrupt sources which are allowed to pass from RIS to MIS when the corresponding bit-fields are set to 1.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_IMASK_RESERVED11: any = '21'\nexport const LGPT_IMASK_RESERVED11_M: any = '21'\nexport const LGPT_IMASK_RESERVED11_S: any = '21'\n/**\nEnable RIS.C2CC interrupt.*/\nexport const LGPT_IMASK_C2CC: any = '1'\nexport const LGPT_IMASK_C2CC_M: any = '1'\nexport const LGPT_IMASK_C2CC_S: any = '1'\n/**\nEnable*/\nexport const LGPT_IMASK_C2CC_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT_IMASK_C2CC_DIS: any = '0'\n\n/**\nEnable RIS.C1CC interrupt.*/\nexport const LGPT_IMASK_C1CC: any = '1'\nexport const LGPT_IMASK_C1CC_M: any = '1'\nexport const LGPT_IMASK_C1CC_S: any = '1'\n/**\nEnable*/\nexport const LGPT_IMASK_C1CC_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT_IMASK_C1CC_DIS: any = '0'\n\n/**\nEnable RIS.C0CC interrupt.*/\nexport const LGPT_IMASK_C0CC: any = '1'\nexport const LGPT_IMASK_C0CC_M: any = '1'\nexport const LGPT_IMASK_C0CC_S: any = '1'\n/**\nEnable*/\nexport const LGPT_IMASK_C0CC_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT_IMASK_C0CC_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_IMASK_RESERVED7: any = '1'\nexport const LGPT_IMASK_RESERVED7_M: any = '1'\nexport const LGPT_IMASK_RESERVED7_S: any = '1'\n/**\nEnable RIS.FAULT interrupt.*/\nexport const LGPT_IMASK_FAULT: any = '1'\nexport const LGPT_IMASK_FAULT_M: any = '1'\nexport const LGPT_IMASK_FAULT_S: any = '1'\n/**\nEnable*/\nexport const LGPT_IMASK_FAULT_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT_IMASK_FAULT_DIS: any = '0'\n\n/**\nEnable RIS.IDX interrupt.*/\nexport const LGPT_IMASK_IDX: any = '1'\nexport const LGPT_IMASK_IDX_M: any = '1'\nexport const LGPT_IMASK_IDX_S: any = '1'\n/**\nEnable*/\nexport const LGPT_IMASK_IDX_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT_IMASK_IDX_DIS: any = '0'\n\n/**\nEnable RIS.DIRCHNG interrupt.*/\nexport const LGPT_IMASK_DIRCHNG: any = '1'\nexport const LGPT_IMASK_DIRCHNG_M: any = '1'\nexport const LGPT_IMASK_DIRCHNG_S: any = '1'\n/**\nEnable*/\nexport const LGPT_IMASK_DIRCHNG_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT_IMASK_DIRCHNG_DIS: any = '0'\n\n/**\nEnable RIS.CNTRCHNG interrupt.*/\nexport const LGPT_IMASK_CNTRCHNG: any = '1'\nexport const LGPT_IMASK_CNTRCHNG_M: any = '1'\nexport const LGPT_IMASK_CNTRCHNG_S: any = '1'\n/**\nEnable*/\nexport const LGPT_IMASK_CNTRCHNG_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT_IMASK_CNTRCHNG_DIS: any = '0'\n\n/**\nEnable RIS.DBLTRANS interrupt.*/\nexport const LGPT_IMASK_DBLTRANS: any = '1'\nexport const LGPT_IMASK_DBLTRANS_M: any = '1'\nexport const LGPT_IMASK_DBLTRANS_S: any = '1'\n/**\nEnable*/\nexport const LGPT_IMASK_DBLTRANS_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT_IMASK_DBLTRANS_DIS: any = '0'\n\n/**\nEnable RIS.ZERO interrupt.*/\nexport const LGPT_IMASK_ZERO: any = '1'\nexport const LGPT_IMASK_ZERO_M: any = '1'\nexport const LGPT_IMASK_ZERO_S: any = '1'\n/**\nEnable*/\nexport const LGPT_IMASK_ZERO_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT_IMASK_ZERO_DIS: any = '0'\n\n/**\nEnable RIS.TGT interrupt.*/\nexport const LGPT_IMASK_TGT: any = '1'\nexport const LGPT_IMASK_TGT_M: any = '1'\nexport const LGPT_IMASK_TGT_S: any = '1'\n/**\nEnable*/\nexport const LGPT_IMASK_TGT_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT_IMASK_TGT_DIS: any = '0'\n\n\n// -------- REGISTER RIS -------- //\n\n/**\nRaw interrupt status. \n\n\nThis register reflects the state of all pending interrupts, regardless of masking. This register allows the user to implement a poll scheme. A flag set in this register can be cleared by writing 1 to the corresponding ICLR register bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_RIS_RESERVED11: any = '21'\nexport const LGPT_RIS_RESERVED11_M: any = '21'\nexport const LGPT_RIS_RESERVED11_S: any = '21'\n/**\nStatus of the C2CC interrupt. The interrupt is set when C2CC has capture or compare event. */\nexport const LGPT_RIS_C2CC: any = '1'\nexport const LGPT_RIS_C2CC_M: any = '1'\nexport const LGPT_RIS_C2CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_RIS_C2CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_RIS_C2CC_CLR: any = '0'\n\n/**\nStatus of the C1CC interrupt. The interrupt is set when C1CC has capture or compare event. */\nexport const LGPT_RIS_C1CC: any = '1'\nexport const LGPT_RIS_C1CC_M: any = '1'\nexport const LGPT_RIS_C1CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_RIS_C1CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_RIS_C1CC_CLR: any = '0'\n\n/**\nStatus of the C0CC interrupt. The interrupt is set when C0CC has capture or compare event. */\nexport const LGPT_RIS_C0CC: any = '1'\nexport const LGPT_RIS_C0CC_M: any = '1'\nexport const LGPT_RIS_C0CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_RIS_C0CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_RIS_C0CC_CLR: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_RIS_RESERVED7: any = '1'\nexport const LGPT_RIS_RESERVED7_M: any = '1'\nexport const LGPT_RIS_RESERVED7_S: any = '1'\n/**\nStatus of the FAULT interrupt. The interrupt is set immediately on active fault input.*/\nexport const LGPT_RIS_FAULT: any = '1'\nexport const LGPT_RIS_FAULT_M: any = '1'\nexport const LGPT_RIS_FAULT_S: any = '1'\n/**\nSet*/\nexport const LGPT_RIS_FAULT_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_RIS_FAULT_CLR: any = '0'\n\n/**\nStatus of the IDX interrupt. The interrupt is set when IDX is active. */\nexport const LGPT_RIS_IDX: any = '1'\nexport const LGPT_RIS_IDX_M: any = '1'\nexport const LGPT_RIS_IDX_S: any = '1'\n/**\nSet*/\nexport const LGPT_RIS_IDX_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_RIS_IDX_CLR: any = '0'\n\n/**\nStatus of the DIRCHNG interrupt. The interrupt is set when the direction of the counter changes. */\nexport const LGPT_RIS_DIRCHNG: any = '1'\nexport const LGPT_RIS_DIRCHNG_M: any = '1'\nexport const LGPT_RIS_DIRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT_RIS_DIRCHNG_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_RIS_DIRCHNG_CLR: any = '0'\n\n/**\nStatus of the CNTRCHNG interrupt. The interrupt is set when the counter increments or decrements.*/\nexport const LGPT_RIS_CNTRCHNG: any = '1'\nexport const LGPT_RIS_CNTRCHNG_M: any = '1'\nexport const LGPT_RIS_CNTRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT_RIS_CNTRCHNG_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_RIS_CNTRCHNG_CLR: any = '0'\n\n/**\nStatus of the DBLTRANS interrupt. The interrupt is set when a double transition has happened during QDEC mode.*/\nexport const LGPT_RIS_DBLTRANS: any = '1'\nexport const LGPT_RIS_DBLTRANS_M: any = '1'\nexport const LGPT_RIS_DBLTRANS_S: any = '1'\n/**\nSet*/\nexport const LGPT_RIS_DBLTRANS_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_RIS_DBLTRANS_CLR: any = '0'\n\n/**\nStatus of the ZERO interrupt. The interrupt is set when CNTR = 0. */\nexport const LGPT_RIS_ZERO: any = '1'\nexport const LGPT_RIS_ZERO_M: any = '1'\nexport const LGPT_RIS_ZERO_S: any = '1'\n/**\nSet*/\nexport const LGPT_RIS_ZERO_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_RIS_ZERO_CLR: any = '0'\n\n/**\nStatus of the TGT interrupt. The interrupt is set when CNTR = TGT. */\nexport const LGPT_RIS_TGT: any = '1'\nexport const LGPT_RIS_TGT_M: any = '1'\nexport const LGPT_RIS_TGT_S: any = '1'\n/**\nSet*/\nexport const LGPT_RIS_TGT_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_RIS_TGT_CLR: any = '0'\n\n\n// -------- REGISTER MIS -------- //\n\n/**\nMasked interrupt status. \n\n\nThis register is simply a bitwise AND of the contents of IMASK and RIS.*] registers. A flag set in this register can be cleared by writing 1 to the corresponding ICLR register bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_MIS_RESERVED11: any = '21'\nexport const LGPT_MIS_RESERVED11_M: any = '21'\nexport const LGPT_MIS_RESERVED11_S: any = '21'\n/**\nMasked status of the RIS.C2CC interrupt. */\nexport const LGPT_MIS_C2CC: any = '1'\nexport const LGPT_MIS_C2CC_M: any = '1'\nexport const LGPT_MIS_C2CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_MIS_C2CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_MIS_C2CC_CLR: any = '0'\n\n/**\nMasked status of the RIS.C1CC interrupt.*/\nexport const LGPT_MIS_C1CC: any = '1'\nexport const LGPT_MIS_C1CC_M: any = '1'\nexport const LGPT_MIS_C1CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_MIS_C1CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_MIS_C1CC_CLR: any = '0'\n\n/**\nMasked status of the RIS.C0CC interrupt.*/\nexport const LGPT_MIS_C0CC: any = '1'\nexport const LGPT_MIS_C0CC_M: any = '1'\nexport const LGPT_MIS_C0CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_MIS_C0CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_MIS_C0CC_CLR: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_MIS_RESERVED7: any = '1'\nexport const LGPT_MIS_RESERVED7_M: any = '1'\nexport const LGPT_MIS_RESERVED7_S: any = '1'\n/**\nMasked status of the RIS.FAULT interrupt.*/\nexport const LGPT_MIS_FAULT: any = '1'\nexport const LGPT_MIS_FAULT_M: any = '1'\nexport const LGPT_MIS_FAULT_S: any = '1'\n/**\nSet*/\nexport const LGPT_MIS_FAULT_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_MIS_FAULT_CLR: any = '0'\n\n/**\nMasked status of the RIS.IDX interrupt.*/\nexport const LGPT_MIS_IDX: any = '1'\nexport const LGPT_MIS_IDX_M: any = '1'\nexport const LGPT_MIS_IDX_S: any = '1'\n/**\nSet*/\nexport const LGPT_MIS_IDX_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_MIS_IDX_CLR: any = '0'\n\n/**\nMasked status of the RIS.DIRCHNG interrupt.*/\nexport const LGPT_MIS_DIRCHNG: any = '1'\nexport const LGPT_MIS_DIRCHNG_M: any = '1'\nexport const LGPT_MIS_DIRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT_MIS_DIRCHNG_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_MIS_DIRCHNG_CLR: any = '0'\n\n/**\nMasked status of the RIS.CNTRCHNG interrupt.*/\nexport const LGPT_MIS_CNTRCHNG: any = '1'\nexport const LGPT_MIS_CNTRCHNG_M: any = '1'\nexport const LGPT_MIS_CNTRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT_MIS_CNTRCHNG_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_MIS_CNTRCHNG_CLR: any = '0'\n\n/**\nMasked status of the RIS.DBLTRANS interrupt.*/\nexport const LGPT_MIS_DBLTRANS: any = '1'\nexport const LGPT_MIS_DBLTRANS_M: any = '1'\nexport const LGPT_MIS_DBLTRANS_S: any = '1'\n/**\nSet*/\nexport const LGPT_MIS_DBLTRANS_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_MIS_DBLTRANS_CLR: any = '0'\n\n/**\nMasked status of the RIS.ZERO interrupt.*/\nexport const LGPT_MIS_ZERO: any = '1'\nexport const LGPT_MIS_ZERO_M: any = '1'\nexport const LGPT_MIS_ZERO_S: any = '1'\n/**\nSet*/\nexport const LGPT_MIS_ZERO_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_MIS_ZERO_CLR: any = '0'\n\n/**\nMasked status of the RIS.TGT interrupt.*/\nexport const LGPT_MIS_TGT: any = '1'\nexport const LGPT_MIS_TGT_M: any = '1'\nexport const LGPT_MIS_TGT_S: any = '1'\n/**\nSet*/\nexport const LGPT_MIS_TGT_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT_MIS_TGT_CLR: any = '0'\n\n\n// -------- REGISTER ISET -------- //\n\n/**\nInterrupt set register. \n\n\nThis register can used by software for diagnostics and safety checking purposes. Writing a 1 to a bit in this register will set the event and the corresponding RIS bit also gets set. If the corresponding IMASK bit is set, then the corresponding MIS register bit also gets set.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_ISET_RESERVED11: any = '21'\nexport const LGPT_ISET_RESERVED11_M: any = '21'\nexport const LGPT_ISET_RESERVED11_S: any = '21'\n/**\nSet the RIS.C2CC interrupt. */\nexport const LGPT_ISET_C2CC: any = '1'\nexport const LGPT_ISET_C2CC_M: any = '1'\nexport const LGPT_ISET_C2CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_ISET_C2CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ISET_C2CC_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.C1CC interrupt.*/\nexport const LGPT_ISET_C1CC: any = '1'\nexport const LGPT_ISET_C1CC_M: any = '1'\nexport const LGPT_ISET_C1CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_ISET_C1CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ISET_C1CC_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.C0CC interrupt.*/\nexport const LGPT_ISET_C0CC: any = '1'\nexport const LGPT_ISET_C0CC_M: any = '1'\nexport const LGPT_ISET_C0CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_ISET_C0CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ISET_C0CC_NO_EFFECT: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_ISET_RESERVED7: any = '1'\nexport const LGPT_ISET_RESERVED7_M: any = '1'\nexport const LGPT_ISET_RESERVED7_S: any = '1'\n/**\nSet the RIS.FAULT interrupt.*/\nexport const LGPT_ISET_FAULT: any = '1'\nexport const LGPT_ISET_FAULT_M: any = '1'\nexport const LGPT_ISET_FAULT_S: any = '1'\n/**\nSet*/\nexport const LGPT_ISET_FAULT_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ISET_FAULT_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.IDX interrupt.*/\nexport const LGPT_ISET_IDX: any = '1'\nexport const LGPT_ISET_IDX_M: any = '1'\nexport const LGPT_ISET_IDX_S: any = '1'\n/**\nSet*/\nexport const LGPT_ISET_IDX_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ISET_IDX_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.DIRCHNG interrupt.*/\nexport const LGPT_ISET_DIRCHNG: any = '1'\nexport const LGPT_ISET_DIRCHNG_M: any = '1'\nexport const LGPT_ISET_DIRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT_ISET_DIRCHNG_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ISET_DIRCHNG_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.CNTRCHNG interrupt.*/\nexport const LGPT_ISET_CNTRCHNG: any = '1'\nexport const LGPT_ISET_CNTRCHNG_M: any = '1'\nexport const LGPT_ISET_CNTRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT_ISET_CNTRCHNG_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ISET_CNTRCHNG_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.DBLTRANS interrupt.*/\nexport const LGPT_ISET_DBLTRANS: any = '1'\nexport const LGPT_ISET_DBLTRANS_M: any = '1'\nexport const LGPT_ISET_DBLTRANS_S: any = '1'\n/**\nSet*/\nexport const LGPT_ISET_DBLTRANS_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ISET_DBLTRANS_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.ZERO interrupt.*/\nexport const LGPT_ISET_ZERO: any = '1'\nexport const LGPT_ISET_ZERO_M: any = '1'\nexport const LGPT_ISET_ZERO_S: any = '1'\n/**\nSet*/\nexport const LGPT_ISET_ZERO_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ISET_ZERO_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.TGT interrupt.*/\nexport const LGPT_ISET_TGT: any = '1'\nexport const LGPT_ISET_TGT_M: any = '1'\nexport const LGPT_ISET_TGT_S: any = '1'\n/**\nSet*/\nexport const LGPT_ISET_TGT_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ISET_TGT_NO_EFFECT: any = '0'\n\n\n// -------- REGISTER ICLR -------- //\n\n/**\nInterrupt clear register. \n\n\nThis register allows software to clear interrupts. Writing a 1 to a bit in this register will clear the event and the corresponding RIS bit also gets cleared. If the corresponding IMASK bit is set, then the corresponding MIS register bit also gets cleared.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_ICLR_RESERVED11: any = '21'\nexport const LGPT_ICLR_RESERVED11_M: any = '21'\nexport const LGPT_ICLR_RESERVED11_S: any = '21'\n/**\nClear the RIS.C2CC interrupt. */\nexport const LGPT_ICLR_C2CC: any = '1'\nexport const LGPT_ICLR_C2CC_M: any = '1'\nexport const LGPT_ICLR_C2CC_S: any = '1'\n/**\nClear*/\nexport const LGPT_ICLR_C2CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ICLR_C2CC_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.C1CC interrupt.*/\nexport const LGPT_ICLR_C1CC: any = '1'\nexport const LGPT_ICLR_C1CC_M: any = '1'\nexport const LGPT_ICLR_C1CC_S: any = '1'\n/**\nClear*/\nexport const LGPT_ICLR_C1CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ICLR_C1CC_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.C0CC interrupt.*/\nexport const LGPT_ICLR_C0CC: any = '1'\nexport const LGPT_ICLR_C0CC_M: any = '1'\nexport const LGPT_ICLR_C0CC_S: any = '1'\n/**\nClear*/\nexport const LGPT_ICLR_C0CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ICLR_C0CC_NO_EFFECT: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_ICLR_RESERVED7: any = '1'\nexport const LGPT_ICLR_RESERVED7_M: any = '1'\nexport const LGPT_ICLR_RESERVED7_S: any = '1'\n/**\nClear the RIS.FAULT interrupt.*/\nexport const LGPT_ICLR_FAULT: any = '1'\nexport const LGPT_ICLR_FAULT_M: any = '1'\nexport const LGPT_ICLR_FAULT_S: any = '1'\n/**\nClear*/\nexport const LGPT_ICLR_FAULT_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ICLR_FAULT_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.IDX interrupt.*/\nexport const LGPT_ICLR_IDX: any = '1'\nexport const LGPT_ICLR_IDX_M: any = '1'\nexport const LGPT_ICLR_IDX_S: any = '1'\n/**\nClear*/\nexport const LGPT_ICLR_IDX_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ICLR_IDX_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.DIRCHNG interrupt.*/\nexport const LGPT_ICLR_DIRCHNG: any = '1'\nexport const LGPT_ICLR_DIRCHNG_M: any = '1'\nexport const LGPT_ICLR_DIRCHNG_S: any = '1'\n/**\nClear*/\nexport const LGPT_ICLR_DIRCHNG_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ICLR_DIRCHNG_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.CNTRCHNG interrupt.*/\nexport const LGPT_ICLR_CNTRCHNG: any = '1'\nexport const LGPT_ICLR_CNTRCHNG_M: any = '1'\nexport const LGPT_ICLR_CNTRCHNG_S: any = '1'\n/**\nClear*/\nexport const LGPT_ICLR_CNTRCHNG_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ICLR_CNTRCHNG_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.DBLTRANS interrupt.*/\nexport const LGPT_ICLR_DBLTRANS: any = '1'\nexport const LGPT_ICLR_DBLTRANS_M: any = '1'\nexport const LGPT_ICLR_DBLTRANS_S: any = '1'\n/**\nClear*/\nexport const LGPT_ICLR_DBLTRANS_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ICLR_DBLTRANS_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.ZERO interrupt.*/\nexport const LGPT_ICLR_ZERO: any = '1'\nexport const LGPT_ICLR_ZERO_M: any = '1'\nexport const LGPT_ICLR_ZERO_S: any = '1'\n/**\nClear*/\nexport const LGPT_ICLR_ZERO_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ICLR_ZERO_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.TGT interrupt.*/\nexport const LGPT_ICLR_TGT: any = '1'\nexport const LGPT_ICLR_TGT_M: any = '1'\nexport const LGPT_ICLR_TGT_S: any = '1'\n/**\nClear*/\nexport const LGPT_ICLR_TGT_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_ICLR_TGT_NO_EFFECT: any = '0'\n\n\n// -------- REGISTER IMSET -------- //\n\n/**\nInterrupt mask set register. \n\n\nWriting a 1 to a bit in this register will set the corresponding IMASK bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_IMSET_RESERVED11: any = '21'\nexport const LGPT_IMSET_RESERVED11_M: any = '21'\nexport const LGPT_IMSET_RESERVED11_S: any = '21'\n/**\nSet the MIS.C2CC mask. */\nexport const LGPT_IMSET_C2CC: any = '1'\nexport const LGPT_IMSET_C2CC_M: any = '1'\nexport const LGPT_IMSET_C2CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_IMSET_C2CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMSET_C2CC_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.C1CC mask.*/\nexport const LGPT_IMSET_C1CC: any = '1'\nexport const LGPT_IMSET_C1CC_M: any = '1'\nexport const LGPT_IMSET_C1CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_IMSET_C1CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMSET_C1CC_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.C0CC mask.*/\nexport const LGPT_IMSET_C0CC: any = '1'\nexport const LGPT_IMSET_C0CC_M: any = '1'\nexport const LGPT_IMSET_C0CC_S: any = '1'\n/**\nSet*/\nexport const LGPT_IMSET_C0CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMSET_C0CC_NO_EFFECT: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_IMSET_RESERVED7: any = '1'\nexport const LGPT_IMSET_RESERVED7_M: any = '1'\nexport const LGPT_IMSET_RESERVED7_S: any = '1'\n/**\nSet the MIS.FAULT mask.*/\nexport const LGPT_IMSET_FAULT: any = '1'\nexport const LGPT_IMSET_FAULT_M: any = '1'\nexport const LGPT_IMSET_FAULT_S: any = '1'\n/**\nSet*/\nexport const LGPT_IMSET_FAULT_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMSET_FAULT_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.IDX mask.*/\nexport const LGPT_IMSET_IDX: any = '1'\nexport const LGPT_IMSET_IDX_M: any = '1'\nexport const LGPT_IMSET_IDX_S: any = '1'\n/**\nSet*/\nexport const LGPT_IMSET_IDX_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMSET_IDX_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.DIRCHNG mask.*/\nexport const LGPT_IMSET_DIRCHNG: any = '1'\nexport const LGPT_IMSET_DIRCHNG_M: any = '1'\nexport const LGPT_IMSET_DIRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT_IMSET_DIRCHNG_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMSET_DIRCHNG_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.CNTRCHNG mask.*/\nexport const LGPT_IMSET_CNTRCHNG: any = '1'\nexport const LGPT_IMSET_CNTRCHNG_M: any = '1'\nexport const LGPT_IMSET_CNTRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT_IMSET_CNTRCHNG_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMSET_CNTRCHNG_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.DBLTRANS mask.*/\nexport const LGPT_IMSET_DBLTRANS: any = '1'\nexport const LGPT_IMSET_DBLTRANS_M: any = '1'\nexport const LGPT_IMSET_DBLTRANS_S: any = '1'\n/**\nSet*/\nexport const LGPT_IMSET_DBLTRANS_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMSET_DBLTRANS_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.ZERO mask.*/\nexport const LGPT_IMSET_ZERO: any = '1'\nexport const LGPT_IMSET_ZERO_M: any = '1'\nexport const LGPT_IMSET_ZERO_S: any = '1'\n/**\nSet*/\nexport const LGPT_IMSET_ZERO_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMSET_ZERO_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.TGT mask.*/\nexport const LGPT_IMSET_TGT: any = '1'\nexport const LGPT_IMSET_TGT_M: any = '1'\nexport const LGPT_IMSET_TGT_S: any = '1'\n/**\nSet*/\nexport const LGPT_IMSET_TGT_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMSET_TGT_NO_EFFECT: any = '0'\n\n\n// -------- REGISTER IMCLR -------- //\n\n/**\nInterrupt mask clear register. \n\n\nWriting a 1 to a bit in this register will clear the corresponding IMASK bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_IMCLR_RESERVED11: any = '21'\nexport const LGPT_IMCLR_RESERVED11_M: any = '21'\nexport const LGPT_IMCLR_RESERVED11_S: any = '21'\n/**\nClear the MIS.C2CC mask. */\nexport const LGPT_IMCLR_C2CC: any = '1'\nexport const LGPT_IMCLR_C2CC_M: any = '1'\nexport const LGPT_IMCLR_C2CC_S: any = '1'\n/**\nClear*/\nexport const LGPT_IMCLR_C2CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMCLR_C2CC_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.C1CC mask.*/\nexport const LGPT_IMCLR_C1CC: any = '1'\nexport const LGPT_IMCLR_C1CC_M: any = '1'\nexport const LGPT_IMCLR_C1CC_S: any = '1'\n/**\nClear*/\nexport const LGPT_IMCLR_C1CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMCLR_C1CC_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.C0CC mask.*/\nexport const LGPT_IMCLR_C0CC: any = '1'\nexport const LGPT_IMCLR_C0CC_M: any = '1'\nexport const LGPT_IMCLR_C0CC_S: any = '1'\n/**\nClear*/\nexport const LGPT_IMCLR_C0CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMCLR_C0CC_NO_EFFECT: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_IMCLR_RESERVED7: any = '1'\nexport const LGPT_IMCLR_RESERVED7_M: any = '1'\nexport const LGPT_IMCLR_RESERVED7_S: any = '1'\n/**\nClear the MIS.FAULT mask.*/\nexport const LGPT_IMCLR_FAULT: any = '1'\nexport const LGPT_IMCLR_FAULT_M: any = '1'\nexport const LGPT_IMCLR_FAULT_S: any = '1'\n/**\nClear*/\nexport const LGPT_IMCLR_FAULT_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMCLR_FAULT_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.IDX mask.*/\nexport const LGPT_IMCLR_IDX: any = '1'\nexport const LGPT_IMCLR_IDX_M: any = '1'\nexport const LGPT_IMCLR_IDX_S: any = '1'\n/**\nClear*/\nexport const LGPT_IMCLR_IDX_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMCLR_IDX_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.DIRCHNG mask.*/\nexport const LGPT_IMCLR_DIRCHNG: any = '1'\nexport const LGPT_IMCLR_DIRCHNG_M: any = '1'\nexport const LGPT_IMCLR_DIRCHNG_S: any = '1'\n/**\nClear*/\nexport const LGPT_IMCLR_DIRCHNG_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMCLR_DIRCHNG_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.CNTRCHNG mask.*/\nexport const LGPT_IMCLR_CNTRCHNG: any = '1'\nexport const LGPT_IMCLR_CNTRCHNG_M: any = '1'\nexport const LGPT_IMCLR_CNTRCHNG_S: any = '1'\n/**\nClear*/\nexport const LGPT_IMCLR_CNTRCHNG_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMCLR_CNTRCHNG_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.DBLTRANS mask.*/\nexport const LGPT_IMCLR_DBLTRANS: any = '1'\nexport const LGPT_IMCLR_DBLTRANS_M: any = '1'\nexport const LGPT_IMCLR_DBLTRANS_S: any = '1'\n/**\nClear*/\nexport const LGPT_IMCLR_DBLTRANS_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMCLR_DBLTRANS_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.ZERO mask.*/\nexport const LGPT_IMCLR_ZERO: any = '1'\nexport const LGPT_IMCLR_ZERO_M: any = '1'\nexport const LGPT_IMCLR_ZERO_S: any = '1'\n/**\nClear*/\nexport const LGPT_IMCLR_ZERO_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMCLR_ZERO_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.TGT mask.*/\nexport const LGPT_IMCLR_TGT: any = '1'\nexport const LGPT_IMCLR_TGT_M: any = '1'\nexport const LGPT_IMCLR_TGT_S: any = '1'\n/**\nClear*/\nexport const LGPT_IMCLR_TGT_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT_IMCLR_TGT_NO_EFFECT: any = '0'\n\n\n// -------- REGISTER EMU -------- //\n\n/**\nDebug control\n\n\nThis register can be used to freeze the timer when CPU halts when HALT is set to 1. When HALT is set to 0, or when the CPU releases debug halt, the filters and edge detection logic is flushed and the timer starts. For setting a predefined output value during a CPU debug halt, PARK, if the timer has this register, should be configured additionally. If this timer does not have the PARK register a predefined output value during CPU halt is not possible.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_EMU_RESERVED2: any = '30'\nexport const LGPT_EMU_RESERVED2_M: any = '30'\nexport const LGPT_EMU_RESERVED2_S: any = '30'\n/**\nHalt control.\n\n\nConfigure when the counter shall stop upon CPU halt. This bitfield only applies if HALT = 1.*/\nexport const LGPT_EMU_CTL: any = '1'\nexport const LGPT_EMU_CTL_M: any = '1'\nexport const LGPT_EMU_CTL_S: any = '1'\n/**\nZero condition. The counter stops when CNTR = 0.*/\nexport const LGPT_EMU_CTL_ZERCOND: any = '1'\n\n/**\nImmediate reaction. The counter stops immediately on debug halt.*/\nexport const LGPT_EMU_CTL_IMMEDIATE: any = '0'\n\n/**\nHalt LGPT when CPU is halted in debug.*/\nexport const LGPT_EMU_HALT: any = '1'\nexport const LGPT_EMU_HALT_M: any = '1'\nexport const LGPT_EMU_HALT_S: any = '1'\n/**\nEnable.*/\nexport const LGPT_EMU_HALT_EN: any = '1'\n\n/**\nDisable.*/\nexport const LGPT_EMU_HALT_DIS: any = '0'\n\n\n// -------- REGISTER C0CFG -------- //\n\n/**\nChannel 0 Configuration\n\n\nThis register configures channel function and enables outputs.\n\nEach channel has an edge-detection circuit. The the edge-detection circuit is: \n - enabled while CCACT selects a capture function and CTL.MODE is different from DIS.\n - flushed while CCACT selects a capture function and CTL.MODE is changed from DIS to another mode.\n\nThe flush action uses two system clock periods. It prevents capture events caused by expired signal values stored in the edge-detection circuit.\n\nThe channel input signal enters the edge-detection circuit. False capture events can occur when:\n- the edge-detection circuit contains expired signal samples and the circuit is enabled without flush as described above.\n- the CCACT field is reconfigured while CTL.MODE is different from DIS.\n\nPrimary use scenario is to select CCACT before starting the timer. Follow these steps to configure CCACT to a capture action while CTL.MODE is different from DIS:\n- Set EDGE to NONE.\n- Configure CCACT.\n- Wait for three system clock periods before setting EDGE different from NONE.\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C0CFG_RESERVED11: any = '21'\nexport const LGPT_C0CFG_RESERVED11_M: any = '21'\nexport const LGPT_C0CFG_RESERVED11_S: any = '21'\n/**\nOutput 2 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT2 becomes zero after a capture or compare event.*/\nexport const LGPT_C0CFG_OUT2: any = '1'\nexport const LGPT_C0CFG_OUT2_M: any = '1'\nexport const LGPT_C0CFG_OUT2_S: any = '1'\n/**\nChannel 0 controls output 2.*/\nexport const LGPT_C0CFG_OUT2_EN: any = '1'\n\n/**\nChannel 0 does not control output 2.*/\nexport const LGPT_C0CFG_OUT2_DIS: any = '0'\n\n/**\nOutput 1 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT1 becomes zero after a capture or compare event.*/\nexport const LGPT_C0CFG_OUT1: any = '1'\nexport const LGPT_C0CFG_OUT1_M: any = '1'\nexport const LGPT_C0CFG_OUT1_S: any = '1'\n/**\nChannel 0 controls output 1.*/\nexport const LGPT_C0CFG_OUT1_EN: any = '1'\n\n/**\nChannel 0 does not control output 1.*/\nexport const LGPT_C0CFG_OUT1_DIS: any = '0'\n\n/**\nOutput 0 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT0 becomes zero after a capture or compare event.*/\nexport const LGPT_C0CFG_OUT0: any = '1'\nexport const LGPT_C0CFG_OUT0_M: any = '1'\nexport const LGPT_C0CFG_OUT0_S: any = '1'\n/**\nChannel 0 controls output 0.*/\nexport const LGPT_C0CFG_OUT0_EN: any = '1'\n\n/**\nChannel 0 does not control output 0.*/\nexport const LGPT_C0CFG_OUT0_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C0CFG_RESERVED7: any = '1'\nexport const LGPT_C0CFG_RESERVED7_M: any = '1'\nexport const LGPT_C0CFG_RESERVED7_S: any = '1'\n/**\nSelect channel input.*/\nexport const LGPT_C0CFG_INPUT: any = '1'\nexport const LGPT_C0CFG_INPUT_M: any = '1'\nexport const LGPT_C0CFG_INPUT_S: any = '1'\n/**\nIO controller*/\nexport const LGPT_C0CFG_INPUT_IO: any = '1'\n\n/**\nEvent fabric*/\nexport const LGPT_C0CFG_INPUT_EV: any = '0'\n\n/**\nDetermines the edge that triggers the channel input event. This happens post filter.*/\nexport const LGPT_C0CFG_EDGE: any = '2'\nexport const LGPT_C0CFG_EDGE_M: any = '2'\nexport const LGPT_C0CFG_EDGE_S: any = '2'\n/**\nInput event is triggered at both edges.*/\nexport const LGPT_C0CFG_EDGE_BOTH: any = '3'\n\n/**\nInput event is triggered at falling edge.*/\nexport const LGPT_C0CFG_EDGE_FALL: any = '2'\n\n/**\nInput event is triggered at rising edge.*/\nexport const LGPT_C0CFG_EDGE_RISE: any = '1'\n\n/**\nInput is turned off.*/\nexport const LGPT_C0CFG_EDGE_NONE: any = '0'\n\n/**\nCapture-Compare action.\n\n\nCapture-Compare action defines 15 different channel functions that utilize capture, compare, and zero events. In every compare event the timer looks at the current value of CNTR. The corresponding output event will be set 1 timer period after CNTR = C0CC. */\nexport const LGPT_C0CFG_CCACT: any = '4'\nexport const LGPT_C0CFG_CCACT_M: any = '4'\nexport const LGPT_C0CFG_CCACT_S: any = '4'\n/**\nPulse on compare repeatedly. \n\n\nChannel function sequence: \n- Pulse enabled outputs when C0CC.VAL = CNTR.VAL.\n\n The output is high for two timer clock periods.*/\nexport const LGPT_C0CFG_CCACT_PULSE_ON_CMP: any = '15'\n\n/**\nToggle on compare repeatedly.\n\n\nChannel function sequence: \n- Toggle enabled outputs  when C0CC.VAL = CNTR.VAL.*/\nexport const LGPT_C0CFG_CCACT_TGL_ON_CMP: any = '14'\n\n/**\nSet on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs  when C0CC.VAL = CNTR.VAL.*/\nexport const LGPT_C0CFG_CCACT_SET_ON_CMP: any = '13'\n\n/**\nClear on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs  when C0CC.VAL = CNTR.VAL.*/\nexport const LGPT_C0CFG_CCACT_CLR_ON_CMP: any = '12'\n\n/**\nSet on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C0CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UP_PER for edge-aligned PWM generation. Duty cycle is given by: \n\nWhen C0CC.VAL $lt;= TGT.VAL: \n   Duty cycle = C0CC.VAL / ( TGT.VAL + 1 ).\n\nWhen C0CC.VAL $gt; TGT.VAL: \n   Duty cycle = 1.\n\nEnabled outputs are cleared when C0CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C0CFG_CCACT_SET_ON_0_TGL_ON_CMP: any = '11'\n\n/**\nClear on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C0CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UPDWN_PER for center-aligned PWM generation. Duty cycle is given by: \n\nWhen C0CC.VAL $lt;= TGT.VAL: \n   Duty cycle = 1 - ( C0CC.VAL / TGT.VAL ).\n\nWhen C0CC.VAL $gt; TGT.VAL: \n   Duty cycle = 0.\n\nEnabled outputs are set when C0CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C0CFG_CCACT_CLR_ON_0_TGL_ON_CMP: any = '10'\n\n/**\nSet on capture repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C0CC.VAL.\n\n*/\nexport const LGPT_C0CFG_CCACT_SET_ON_CAPT: any = '9'\n\n/**\nPeriod and pulse width measurement.\n\n\nContinuously capture period and pulse width of the signal selected by INPUT relative to the signal edge given by EDGE. \n\nSet enabled outputs and RIS.C0CC when C0CC.VAL contains signal period and PC0CC.VAL contains signal pulse width.\n\nNotes: \n- Make sure to configure INPUT and CCACT when CTL.MODE equals DIS, then set CTL.MODE to UP_ONCE or UP_PER. \n- The counter restarts in the selected timer mode when C0CC.VAL contains the signal period.\n- If more than one channel uses this function, the channels will perform this function one at a time. The channel with lowest number has priority and performs the function first. Next measurement starts when current measurement completes successfully or times out. A timeout occurs when counter equals target. \n- To observe a timeout event the RIS.TGT interrupt can be used, or another channel can be configured to SET_ON_CMP with compare value equal TGT.\n\nSignal property requirements:\n- Signal Period $gt;= 2 * ( 1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal Period $lt;= MAX(CNTR) * (1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal low and high phase $gt;= (1 + PRECFG.TICKDIV ) * timer clock period. */\nexport const LGPT_C0CFG_CCACT_PER_PULSE_WIDTH_MEAS: any = '8'\n\n/**\nPulse on compare, and then disable channel.\n\n\nChannel function sequence: \n- Pulse enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.\n\n The output is high for two timer clock periods.*/\nexport const LGPT_C0CFG_CCACT_PULSE_ON_CMP_DIS: any = '7'\n\n/**\nToggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Toggle enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT_C0CFG_CCACT_TGL_ON_CMP_DIS: any = '6'\n\n/**\nSet on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT_C0CFG_CCACT_SET_ON_CMP_DIS: any = '5'\n\n/**\nClear on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT_C0CFG_CCACT_CLR_ON_CMP_DIS: any = '4'\n\n/**\nSet on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are cleared when C0CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C0CFG_CCACT_SET_ON_0_TGL_ON_CMP_DIS: any = '3'\n\n/**\nClear on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are set when C0CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C0CFG_CCACT_CLR_ON_0_TGL_ON_CMP_DIS: any = '2'\n\n/**\nSet on capture, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C0CC.VAL.\n- Disable channel. \n\nPrimary use scenario is to select this function before starting the timer.\nFollow these steps to select this function while CTL.MODE is different from DIS:  \n - Set CCACT to SET_ON_CAPT with no output enable.\n - Configure INPUT (optional).\n - Wait for three timer clock periods as defined in PRECFG before setting CCACT to SET_ON_CAPT_DIS. Output enable is optional.\n\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\nexport const LGPT_C0CFG_CCACT_SET_ON_CAPT_DIS: any = '1'\n\n/**\nDisable channel.*/\nexport const LGPT_C0CFG_CCACT_DIS: any = '0'\n\n\n// -------- REGISTER C1CFG -------- //\n\n/**\nChannel 1 Configuration\n\n\nThis register configures channel function and enables outputs.\n\nEach channel has an edge-detection circuit. The the edge-detection circuit is: \n - enabled while CCACT selects a capture function and CTL.MODE is different from DIS.\n - flushed while CCACT selects a capture function and CTL.MODE is changed from DIS to another mode.\n\nThe flush action uses two system clock periods. It prevents capture events caused by expired signal values stored in the edge-detection circuit.\n\nThe channel input signal enters the edge-detection circuit. False capture events can occur when:\n- the edge-detection circuit contains expired signal samples and the circuit is enabled without flush as described above.\n- the CCACT field is reconfigured while CTL.MODE is different from DIS.\n\nPrimary use scenario is to select CCACT before starting the timer. Follow these steps to configure CCACT to a capture action while CTL.MODE is different from DIS:\n- Set EDGE to NONE.\n- Configure CCACT.\n- Wait for three system clock periods before setting EDGE different from NONE.\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C1CFG_RESERVED11: any = '21'\nexport const LGPT_C1CFG_RESERVED11_M: any = '21'\nexport const LGPT_C1CFG_RESERVED11_S: any = '21'\n/**\nOutput 2 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT2 becomes zero after a capture or compare event.*/\nexport const LGPT_C1CFG_OUT2: any = '1'\nexport const LGPT_C1CFG_OUT2_M: any = '1'\nexport const LGPT_C1CFG_OUT2_S: any = '1'\n/**\nChannel 1 controls output 2.*/\nexport const LGPT_C1CFG_OUT2_EN: any = '1'\n\n/**\nChannel 1 does not control output 2.*/\nexport const LGPT_C1CFG_OUT2_DIS: any = '0'\n\n/**\nOutput 1 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT1 becomes zero after a capture or compare event.*/\nexport const LGPT_C1CFG_OUT1: any = '1'\nexport const LGPT_C1CFG_OUT1_M: any = '1'\nexport const LGPT_C1CFG_OUT1_S: any = '1'\n/**\nChannel 1 controls output 1.*/\nexport const LGPT_C1CFG_OUT1_EN: any = '1'\n\n/**\nChannel 1 does not control output 1.*/\nexport const LGPT_C1CFG_OUT1_DIS: any = '0'\n\n/**\nOutput 0 enable.\n\nWhen 0 $lt; CCACT $lt; 8, OUT0 becomes zero after a capture or compare event.\n*/\nexport const LGPT_C1CFG_OUT0: any = '1'\nexport const LGPT_C1CFG_OUT0_M: any = '1'\nexport const LGPT_C1CFG_OUT0_S: any = '1'\n/**\nChannel 1 controls output 0.*/\nexport const LGPT_C1CFG_OUT0_EN: any = '1'\n\n/**\nChannel 1 does not control output 0.*/\nexport const LGPT_C1CFG_OUT0_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C1CFG_RESERVED7: any = '1'\nexport const LGPT_C1CFG_RESERVED7_M: any = '1'\nexport const LGPT_C1CFG_RESERVED7_S: any = '1'\n/**\nSelect channel input.*/\nexport const LGPT_C1CFG_INPUT: any = '1'\nexport const LGPT_C1CFG_INPUT_M: any = '1'\nexport const LGPT_C1CFG_INPUT_S: any = '1'\n/**\nIO controller*/\nexport const LGPT_C1CFG_INPUT_IO: any = '1'\n\n/**\nEvent fabric*/\nexport const LGPT_C1CFG_INPUT_EV: any = '0'\n\n/**\nDetermines the edge that triggers the channel input event. This happens post filter.*/\nexport const LGPT_C1CFG_EDGE: any = '2'\nexport const LGPT_C1CFG_EDGE_M: any = '2'\nexport const LGPT_C1CFG_EDGE_S: any = '2'\n/**\nInput event is triggered at both edges.*/\nexport const LGPT_C1CFG_EDGE_BOTH: any = '3'\n\n/**\nInput event is triggered at falling edge.*/\nexport const LGPT_C1CFG_EDGE_FALL: any = '2'\n\n/**\nInput event is triggered at rising edge.*/\nexport const LGPT_C1CFG_EDGE_RISE: any = '1'\n\n/**\nInput is turned off.*/\nexport const LGPT_C1CFG_EDGE_NONE: any = '0'\n\n/**\nCapture-Compare action.\n\n\nCapture-Compare action defines 15 different channel functions that utilize capture, compare, and zero events. In every compare event the timer looks at the current value of CNTR. The corresponding output event will be set 1 timer period after CNTR = C1CC. */\nexport const LGPT_C1CFG_CCACT: any = '4'\nexport const LGPT_C1CFG_CCACT_M: any = '4'\nexport const LGPT_C1CFG_CCACT_S: any = '4'\n/**\nPulse on compare repeatedly. \n\n\nChannel function sequence: \n- Pulse enabled outputs when C1CC.VAL = CNTR.VAL.\n\n The output is high for two timer clock periods.*/\nexport const LGPT_C1CFG_CCACT_PULSE_ON_CMP: any = '15'\n\n/**\nToggle on compare repeatedly.\n\n\nChannel function sequence: \n- Toggle enabled outputs  when C1CC.VAL = CNTR.VAL.*/\nexport const LGPT_C1CFG_CCACT_TGL_ON_CMP: any = '14'\n\n/**\nSet on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs  when C1CC.VAL = CNTR.VAL.*/\nexport const LGPT_C1CFG_CCACT_SET_ON_CMP: any = '13'\n\n/**\nClear on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs  when C1CC.VAL = CNTR.VAL.*/\nexport const LGPT_C1CFG_CCACT_CLR_ON_CMP: any = '12'\n\n/**\nSet on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C1CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UP_PER for edge-aligned PWM generation. Duty cycle is given by: \n\nWhen C1CC.VAL $lt;= TGT.VAL: \n   Duty cycle = C1CC.VAL / ( TGT.VAL + 1 ).\n\nWhen C1CC.VAL $gt; TGT.VAL: \n   Duty cycle = 1.\n\nEnabled outputs are cleared when C1CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C1CFG_CCACT_SET_ON_0_TGL_ON_CMP: any = '11'\n\n/**\nClear on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C1CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UPDWN_PER for center-aligned PWM generation. Duty cycle is given by: \n\nWhen C1CC.VAL $lt;= TGT.VAL: \n   Duty cycle = 1 - ( C1CC.VAL / TGT.VAL ).\n\nWhen C1CC.VAL $gt; TGT.VAL: \n   Duty cycle = 0.\n\nEnabled outputs are set when C1CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C1CFG_CCACT_CLR_ON_0_TGL_ON_CMP: any = '10'\n\n/**\nSet on capture repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C1CC.VAL.\n\n*/\nexport const LGPT_C1CFG_CCACT_SET_ON_CAPT: any = '9'\n\n/**\nPeriod and pulse width measurement.\n\n\nContinuously capture period and pulse width of the signal selected by INPUT relative to the signal edge given by EDGE. \n\nSet enabled outputs and RIS.C1CC when C1CC.VAL contains signal period and PC1CC.VAL contains signal pulse width. \n\nNotes: \n- Make sure to configure INPUT and CCACT when CTL.MODE equals DIS, then set CTL.MODE to UP_ONCE or UP_PER. \n- The counter restarts in the selected timer mode when C1CC.VAL contains the signal period.\n- If more than one channel uses this function, the channels will perform this function one at a time. The channel with lowest number has priority and performs the function first. Next measurement starts when current measurement completes successfully or times out. A timeout occurs when counter equals target. \n- To observe a timeout event the RIS.TGT interrupt can be used, or another channel can be configured to SET_ON_CMP with compare value equal TGT.\n\nSignal property requirements:\n- Signal Period $gt;= 2 * ( 1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal Period $lt;= MAX(CNTR) * (1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal low and high phase $gt;= (1 + PRECFG.TICKDIV ) * timer clock period.*/\nexport const LGPT_C1CFG_CCACT_PER_PULSE_WIDTH_MEAS: any = '8'\n\n/**\nPulse on compare, and then disable channel.\n\n\nChannel function sequence: \n- Pulse enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.\n\n The output is high for two timer clock periods.*/\nexport const LGPT_C1CFG_CCACT_PULSE_ON_CMP_DIS: any = '7'\n\n/**\nToggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Toggle enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT_C1CFG_CCACT_TGL_ON_CMP_DIS: any = '6'\n\n/**\nSet on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT_C1CFG_CCACT_SET_ON_CMP_DIS: any = '5'\n\n/**\nClear on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT_C1CFG_CCACT_CLR_ON_CMP_DIS: any = '4'\n\n/**\nSet on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are cleared when C1CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C1CFG_CCACT_SET_ON_0_TGL_ON_CMP_DIS: any = '3'\n\n/**\nClear on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are set when C1CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C1CFG_CCACT_CLR_ON_0_TGL_ON_CMP_DIS: any = '2'\n\n/**\nSet on capture, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C1CC.VAL.\n- Disable channel. \n\nPrimary use scenario is to select this function before starting the timer.\nFollow these steps to select this function while CTL.MODE is different from DIS:  \n - Set CCACT to SET_ON_CAPT with no output enable.\n - Configure INPUT (optional).\n - Wait for three timer clock periods as defined in PRECFG before setting CCACT to SET_ON_CAPT_DIS. Output enable is optional.\n\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\nexport const LGPT_C1CFG_CCACT_SET_ON_CAPT_DIS: any = '1'\n\n/**\nDisable channel.*/\nexport const LGPT_C1CFG_CCACT_DIS: any = '0'\n\n\n// -------- REGISTER C2CFG -------- //\n\n/**\nChannel 2 Configuration\n\n\nThis register configures channel function and enables outputs.\n\nEach channel has an edge-detection circuit. The the edge-detection circuit is: \n - enabled while CCACT selects a capture function and CTL.MODE is different from DIS.\n - flushed while CCACT selects a capture function and CTL.MODE is changed from DIS to another mode.\n\nThe flush action uses two system clock periods. It prevents capture events caused by expired signal values stored in the edge-detection circuit.\n\nThe channel input signal enters the edge-detection circuit. False capture events can occur when:\n- the edge-detection circuit contains expired signal samples and the circuit is enabled without flush as described above.\n- the CCACT field is reconfigured while CTL.MODE is different from DIS.\n\nPrimary use scenario is to select CCACT before starting the timer. Follow these steps to configure CCACT to a capture action while CTL.MODE is different from DIS:\n- Set EDGE to NONE.\n- Configure CCACT.\n- Wait for three system clock periods before setting EDGE different from NONE.\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C2CFG_RESERVED11: any = '21'\nexport const LGPT_C2CFG_RESERVED11_M: any = '21'\nexport const LGPT_C2CFG_RESERVED11_S: any = '21'\n/**\nOutput 2 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT2 becomes zero after a capture or compare event.*/\nexport const LGPT_C2CFG_OUT2: any = '1'\nexport const LGPT_C2CFG_OUT2_M: any = '1'\nexport const LGPT_C2CFG_OUT2_S: any = '1'\n/**\nChannel 2 controls output 2.*/\nexport const LGPT_C2CFG_OUT2_EN: any = '1'\n\n/**\nChannel 2 does not control output 2.*/\nexport const LGPT_C2CFG_OUT2_DIS: any = '0'\n\n/**\nOutput 1 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT1 becomes zero after a capture or compare event.*/\nexport const LGPT_C2CFG_OUT1: any = '1'\nexport const LGPT_C2CFG_OUT1_M: any = '1'\nexport const LGPT_C2CFG_OUT1_S: any = '1'\n/**\nChannel 2 controls output 1.*/\nexport const LGPT_C2CFG_OUT1_EN: any = '1'\n\n/**\nChannel 2 does not control output 1.*/\nexport const LGPT_C2CFG_OUT1_DIS: any = '0'\n\n/**\nOutput 0 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT0 becomes zero after a capture or compare event.*/\nexport const LGPT_C2CFG_OUT0: any = '1'\nexport const LGPT_C2CFG_OUT0_M: any = '1'\nexport const LGPT_C2CFG_OUT0_S: any = '1'\n/**\nChannel 2 controls output 0.*/\nexport const LGPT_C2CFG_OUT0_EN: any = '1'\n\n/**\nChannel 2 does not control output 0.*/\nexport const LGPT_C2CFG_OUT0_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C2CFG_RESERVED7: any = '1'\nexport const LGPT_C2CFG_RESERVED7_M: any = '1'\nexport const LGPT_C2CFG_RESERVED7_S: any = '1'\n/**\nSelect channel input.*/\nexport const LGPT_C2CFG_INPUT: any = '1'\nexport const LGPT_C2CFG_INPUT_M: any = '1'\nexport const LGPT_C2CFG_INPUT_S: any = '1'\n/**\nIO controller*/\nexport const LGPT_C2CFG_INPUT_IO: any = '1'\n\n/**\nEvent fabric*/\nexport const LGPT_C2CFG_INPUT_EV: any = '0'\n\n/**\nDetermines the edge that triggers the channel input event. This happens post filter.*/\nexport const LGPT_C2CFG_EDGE: any = '2'\nexport const LGPT_C2CFG_EDGE_M: any = '2'\nexport const LGPT_C2CFG_EDGE_S: any = '2'\n/**\nInput event is triggered at both edges.*/\nexport const LGPT_C2CFG_EDGE_BOTH: any = '3'\n\n/**\nInput event is triggered at falling edge.*/\nexport const LGPT_C2CFG_EDGE_FALL: any = '2'\n\n/**\nInput event is triggered at rising edge.*/\nexport const LGPT_C2CFG_EDGE_RISE: any = '1'\n\n/**\nInput is turned off.*/\nexport const LGPT_C2CFG_EDGE_NONE: any = '0'\n\n/**\nCapture-Compare action.\n\n\nCapture-Compare action defines 15 different channel functions that utilize capture, compare, and zero events. In every compare event the timer looks at the current value of CNTR. The corresponding output event will be set 1 timer period after CNTR = C2CC. */\nexport const LGPT_C2CFG_CCACT: any = '4'\nexport const LGPT_C2CFG_CCACT_M: any = '4'\nexport const LGPT_C2CFG_CCACT_S: any = '4'\n/**\nPulse on compare repeatedly. \n\n\nChannel function sequence: \n- Pulse enabled outputs when C2CC.VAL = CNTR.VAL.\n\n The output is high for two timer clock periods.*/\nexport const LGPT_C2CFG_CCACT_PULSE_ON_CMP: any = '15'\n\n/**\nToggle on compare repeatedly.\n\n\nChannel function sequence: \n- Toggle enabled outputs  when C2CC.VAL = CNTR.VAL.*/\nexport const LGPT_C2CFG_CCACT_TGL_ON_CMP: any = '14'\n\n/**\nSet on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs  when C2CC.VAL = CNTR.VAL.*/\nexport const LGPT_C2CFG_CCACT_SET_ON_CMP: any = '13'\n\n/**\nClear on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs  when C2CC.VAL = CNTR.VAL.*/\nexport const LGPT_C2CFG_CCACT_CLR_ON_CMP: any = '12'\n\n/**\nSet on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C2CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UP_PER for edge-aligned PWM generation. Duty cycle is given by: \n\nWhen C2CC.VAL $lt;= TGT.VAL: \n   Duty cycle = C2CC.VAL / ( TGT.VAL + 1 ).\n\nWhen C2CC.VAL $gt; TGT.VAL: \n   Duty cycle = 1.\n\nEnabled outputs are cleared when C2CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C2CFG_CCACT_SET_ON_0_TGL_ON_CMP: any = '11'\n\n/**\nClear on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C2CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UPDWN_PER for center-aligned PWM generation. Duty cycle is given by: \n\nWhen C2CC.VAL $lt;= TGT.VAL: \n   Duty cycle = 1 - ( C2CC.VAL / TGT.VAL ).\n\nWhen C2CC.VAL $gt; TGT.VAL: \n   Duty cycle = 0.\n\nEnabled outputs are set when C2CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C2CFG_CCACT_CLR_ON_0_TGL_ON_CMP: any = '10'\n\n/**\nSet on capture repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C2CC.VAL.\n\n*/\nexport const LGPT_C2CFG_CCACT_SET_ON_CAPT: any = '9'\n\n/**\nPeriod and pulse width measurement.\n\n\nContinuously capture period and pulse width of the signal selected by INPUT relative to the signal edge given by EDGE. \n\nSet enabled outputs and RIS.C2CC when C2CC.VAL contains signal period and PC2CC.VAL contains signal pulse width. \n\nNotes: \n- Make sure to configure INPUT and CCACT when CTL.MODE equals DIS, then set CTL.MODE to UP_ONCE or UP_PER. \n- The counter restarts in the selected timer mode when C2CC.VAL contains the signal period.\n- If more than one channel uses this function, the channels will perform this function one at a time. The channel with lowest number has priority and performs the function first. Next measurement starts when current measurement completes successfully or times out. A timeout occurs when counter equals target. \n- To observe a timeout event the RIS.TGT interrupt can be used, or another channel can be configured to SET_ON_CMP with compare value equal TGT.\n\nSignal property requirements:\n- Signal Period $gt;= 2 * ( 1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal Period $lt;= MAX(CNTR) * (1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal low and high phase $gt;= (1 + PRECFG.TICKDIV ) * timer clock period. */\nexport const LGPT_C2CFG_CCACT_PER_PULSE_WIDTH_MEAS: any = '8'\n\n/**\nPulse on compare, and then disable channel.\n\n\nChannel function sequence: \n- Pulse enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.\n\n The output is high for two timer clock periods.*/\nexport const LGPT_C2CFG_CCACT_PULSE_ON_CMP_DIS: any = '7'\n\n/**\nToggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Toggle enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT_C2CFG_CCACT_TGL_ON_CMP_DIS: any = '6'\n\n/**\nSet on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT_C2CFG_CCACT_SET_ON_CMP_DIS: any = '5'\n\n/**\nClear on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT_C2CFG_CCACT_CLR_ON_CMP_DIS: any = '4'\n\n/**\nSet on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are cleared when C2CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C2CFG_CCACT_SET_ON_0_TGL_ON_CMP_DIS: any = '3'\n\n/**\nClear on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are set when C2CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT_C2CFG_CCACT_CLR_ON_0_TGL_ON_CMP_DIS: any = '2'\n\n/**\nSet on capture, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C2CC.VAL.\n- Disable channel. \n\nPrimary use scenario is to select this function before starting the timer.\nFollow these steps to select this function while CTL.MODE is different from DIS:  \n - Set CCACT to SET_ON_CAPT with no output enable.\n - Configure INPUT (optional).\n - Wait for three timer clock periods as defined in PRECFG before setting CCACT to SET_ON_CAPT_DIS. Output enable is optional.\n\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\nexport const LGPT_C2CFG_CCACT_SET_ON_CAPT_DIS: any = '1'\n\n/**\nDisable channel.*/\nexport const LGPT_C2CFG_CCACT_DIS: any = '0'\n\n\n// -------- REGISTER PTGT -------- //\n\n/**\nPipeline Target\n\nA read or write to this register will clear the RIS.ZERO and RIS.TGT interrupt.\n\n\nIf CTL.MODE != QDEC.\nTarget value for next counter period.\nThe timer will copy PTGT.VAL to TGT.VAL on the upcoming CNTR zero crossing only if PTGT.VAL has been written. The copy does not happen when restarting the timer.\nThis is useful to avoid period jitter in PWM applications with time-varying period, sometimes referenced as phase corrected PWM.\n\nIf CTL.MODE = QDEC\nThe CNTR value is updated with VALUE on IDX if the counter is counting down. If the counter is counting up, CNTR is loaded with zero on IDX.\nIn this mode the VALUE is not loaded into TGT on zero crossing.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PTGT_RESERVED16: any = '16'\nexport const LGPT_PTGT_RESERVED16_M: any = '16'\nexport const LGPT_PTGT_RESERVED16_S: any = '16'\n/**\nThe pipleline target value.*/\nexport const LGPT_PTGT_VAL: any = '16'\nexport const LGPT_PTGT_VAL_M: any = '16'\nexport const LGPT_PTGT_VAL_S: any = '16'\n\n// -------- REGISTER PC0CC -------- //\n\n/**\nPipeline Channel 0 Capture Compare */\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PC0CC_RESERVED16: any = '16'\nexport const LGPT_PC0CC_RESERVED16_M: any = '16'\nexport const LGPT_PC0CC_RESERVED16_S: any = '16'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C0CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C0CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C0CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C0CFG.EDGE.*/\nexport const LGPT_PC0CC_VAL: any = '16'\nexport const LGPT_PC0CC_VAL_M: any = '16'\nexport const LGPT_PC0CC_VAL_S: any = '16'\n\n// -------- REGISTER PC1CC -------- //\n\n/**\nPipeline Channel 1 Capture Compare */\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PC1CC_RESERVED16: any = '16'\nexport const LGPT_PC1CC_RESERVED16_M: any = '16'\nexport const LGPT_PC1CC_RESERVED16_S: any = '16'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C1CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C1CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C1CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C1CFG.EDGE.*/\nexport const LGPT_PC1CC_VAL: any = '16'\nexport const LGPT_PC1CC_VAL_M: any = '16'\nexport const LGPT_PC1CC_VAL_S: any = '16'\n\n// -------- REGISTER PC2CC -------- //\n\n/**\nPipeline Channel 2 Capture Compare */\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PC2CC_RESERVED16: any = '16'\nexport const LGPT_PC2CC_RESERVED16_M: any = '16'\nexport const LGPT_PC2CC_RESERVED16_S: any = '16'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C2CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C2CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C2CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C2CFG.EDGE.*/\nexport const LGPT_PC2CC_VAL: any = '16'\nexport const LGPT_PC2CC_VAL_M: any = '16'\nexport const LGPT_PC2CC_VAL_S: any = '16'\n\n// -------- REGISTER TGT -------- //\n\n/**\nTarget\n\n\nUser defined counter target. \nA read or write to this register will clear the RIS.ZERO and RIS.TGT interrupt.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_TGT_RESERVED16: any = '16'\nexport const LGPT_TGT_RESERVED16_M: any = '16'\nexport const LGPT_TGT_RESERVED16_S: any = '16'\n/**\nUser defined counter target value.*/\nexport const LGPT_TGT_VAL: any = '16'\nexport const LGPT_TGT_VAL_M: any = '16'\nexport const LGPT_TGT_VAL_S: any = '16'\n\n// -------- REGISTER C0CC -------- //\n\n/**\nChannel 0 Capture Compare*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C0CC_RESERVED16: any = '16'\nexport const LGPT_C0CC_RESERVED16_M: any = '16'\nexport const LGPT_C0CC_RESERVED16_S: any = '16'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C0CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C0CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C0CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT_C0CC_VAL: any = '16'\nexport const LGPT_C0CC_VAL_M: any = '16'\nexport const LGPT_C0CC_VAL_S: any = '16'\n\n// -------- REGISTER C1CC -------- //\n\n/**\nChannel 1 Capture Compare*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C1CC_RESERVED16: any = '16'\nexport const LGPT_C1CC_RESERVED16_M: any = '16'\nexport const LGPT_C1CC_RESERVED16_S: any = '16'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C1CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C1CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C1CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT_C1CC_VAL: any = '16'\nexport const LGPT_C1CC_VAL_M: any = '16'\nexport const LGPT_C1CC_VAL_S: any = '16'\n\n// -------- REGISTER C2CC -------- //\n\n/**\nChannel 2 Capture Compare*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C2CC_RESERVED16: any = '16'\nexport const LGPT_C2CC_RESERVED16_M: any = '16'\nexport const LGPT_C2CC_RESERVED16_S: any = '16'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C2CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C2CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C2CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT_C2CC_VAL: any = '16'\nexport const LGPT_C2CC_VAL_M: any = '16'\nexport const LGPT_C2CC_VAL_S: any = '16'\n\n// -------- REGISTER PTGTNC -------- //\n\n/**\nPipeline Target No Clear\n\n\nUse this register to read or write to PTGT without clearing the RIS.ZERO and RIS.TGT interrupt.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PTGTNC_RESERVED16: any = '16'\nexport const LGPT_PTGTNC_RESERVED16_M: any = '16'\nexport const LGPT_PTGTNC_RESERVED16_S: any = '16'\n/**\nA read or write to this register will not clear the RIS.TGT interrupt.\n\n\nIf CTL.MODE != QDEC.\nTarget value for next counter period.\nThe timer copies VAL to TGT.VAL when CNTR.VAL becomes 0. The copy does not happen when restarting the timer.\nThis is useful to avoid period jitter in PWM applications with time-varying period, sometimes referenced as phase corrected PWM.\n\nIf CTL.MODE = QDEC.\nThe CNTR.VAL is updated with VAL on IDX. VAL is not loaded into TGT.VAL when CNTR.VAL becomes 0. */\nexport const LGPT_PTGTNC_VAL: any = '16'\nexport const LGPT_PTGTNC_VAL_M: any = '16'\nexport const LGPT_PTGTNC_VAL_S: any = '16'\n\n// -------- REGISTER PC0CCNC -------- //\n\n/**\nPipeline Channel 0 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PC0CCNC_RESERVED16: any = '16'\nexport const LGPT_PC0CCNC_RESERVED16_M: any = '16'\nexport const LGPT_PC0CCNC_RESERVED16_S: any = '16'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C0CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C0CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C0CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C0CFG.EDGE.*/\nexport const LGPT_PC0CCNC_VAL: any = '16'\nexport const LGPT_PC0CCNC_VAL_M: any = '16'\nexport const LGPT_PC0CCNC_VAL_S: any = '16'\n\n// -------- REGISTER PC1CCNC -------- //\n\n/**\nPipeline Channel 1 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PC1CCNC_RESERVED16: any = '16'\nexport const LGPT_PC1CCNC_RESERVED16_M: any = '16'\nexport const LGPT_PC1CCNC_RESERVED16_S: any = '16'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C1CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C1CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C1CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C1CFG.EDGE.*/\nexport const LGPT_PC1CCNC_VAL: any = '16'\nexport const LGPT_PC1CCNC_VAL_M: any = '16'\nexport const LGPT_PC1CCNC_VAL_S: any = '16'\n\n// -------- REGISTER PC2CCNC -------- //\n\n/**\nPipeline Channel 2 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_PC2CCNC_RESERVED16: any = '16'\nexport const LGPT_PC2CCNC_RESERVED16_M: any = '16'\nexport const LGPT_PC2CCNC_RESERVED16_S: any = '16'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C2CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C2CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C2CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C2CFG.EDGE.*/\nexport const LGPT_PC2CCNC_VAL: any = '16'\nexport const LGPT_PC2CCNC_VAL_M: any = '16'\nexport const LGPT_PC2CCNC_VAL_S: any = '16'\n\n// -------- REGISTER TGTNC -------- //\n\n/**\nTarget No Clear\n\n\nUse this register to read or write to TGT without clearing the RIS.ZERO and RIS.TGT interrupt.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_TGTNC_RESERVED16: any = '16'\nexport const LGPT_TGTNC_RESERVED16_M: any = '16'\nexport const LGPT_TGTNC_RESERVED16_S: any = '16'\n/**\nUser defined counter target value.*/\nexport const LGPT_TGTNC_VAL: any = '16'\nexport const LGPT_TGTNC_VAL_M: any = '16'\nexport const LGPT_TGTNC_VAL_S: any = '16'\n\n// -------- REGISTER C0CCNC -------- //\n\n/**\nChannel 0 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C0CCNC_RESERVED16: any = '16'\nexport const LGPT_C0CCNC_RESERVED16_M: any = '16'\nexport const LGPT_C0CCNC_RESERVED16_S: any = '16'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C0CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C0CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C0CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT_C0CCNC_VAL: any = '16'\nexport const LGPT_C0CCNC_VAL_M: any = '16'\nexport const LGPT_C0CCNC_VAL_S: any = '16'\n\n// -------- REGISTER C1CCNC -------- //\n\n/**\nChannel 1 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C1CCNC_RESERVED16: any = '16'\nexport const LGPT_C1CCNC_RESERVED16_M: any = '16'\nexport const LGPT_C1CCNC_RESERVED16_S: any = '16'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C1CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C1CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C1CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT_C1CCNC_VAL: any = '16'\nexport const LGPT_C1CCNC_VAL_M: any = '16'\nexport const LGPT_C1CCNC_VAL_S: any = '16'\n\n// -------- REGISTER C2CCNC -------- //\n\n/**\nChannel 2 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT_C2CCNC_RESERVED16: any = '16'\nexport const LGPT_C2CCNC_RESERVED16_M: any = '16'\nexport const LGPT_C2CCNC_RESERVED16_S: any = '16'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C2CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C2CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C2CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT_C2CCNC_VAL: any = '16'\nexport const LGPT_C2CCNC_VAL_M: any = '16'\nexport const LGPT_C2CCNC_VAL_S: any = '16'\n\n// -------- MODULE LGPT3 -------- //\n\nexport interface LGPT3_t {\n    DESC: em.$Reg\n    DESCEX: em.$Reg\n    STARTCFG: em.$Reg\n    CTL: em.$Reg\n    OUTCTL: em.$Reg\n    CNTR: em.$Reg\n    PRECFG: em.$Reg\n    PREEVENT: em.$Reg\n    CHFILT: em.$Reg\n    DMA: em.$Reg\n    DMARW: em.$Reg\n    ADCTRG: em.$Reg\n    IOCTL: em.$Reg\n    IMASK: em.$Reg\n    RIS: em.$Reg\n    MIS: em.$Reg\n    ISET: em.$Reg\n    ICLR: em.$Reg\n    IMSET: em.$Reg\n    IMCLR: em.$Reg\n    EMU: em.$Reg\n    C0CFG: em.$Reg\n    C1CFG: em.$Reg\n    C2CFG: em.$Reg\n    PTGT: em.$Reg\n    PC0CC: em.$Reg\n    PC1CC: em.$Reg\n    PC2CC: em.$Reg\n    TGT: em.$Reg\n    C0CC: em.$Reg\n    C1CC: em.$Reg\n    C2CC: em.$Reg\n    PTGTNC: em.$Reg\n    PC0CCNC: em.$Reg\n    PC1CCNC: em.$Reg\n    PC2CCNC: em.$Reg\n    TGTNC: em.$Reg\n    C0CCNC: em.$Reg\n    C1CCNC: em.$Reg\n    C2CCNC: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription Register.\n\n\nThis register provides IP module ID, revision information, instance index and standard MMR registers offset.*/\n/**\nModule identifier used to uniquely identify this IP.\n\n*/\nexport const LGPT3_DESC_MODID: any = '16'\nexport const LGPT3_DESC_MODID_M: any = '16'\nexport const LGPT3_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set of from aggregated IRQ registers till DTB.\n\n\n0: Standard IP MMRs do not exist\n\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)*/\nexport const LGPT3_DESC_STDIPOFF: any = '4'\nexport const LGPT3_DESC_STDIPOFF_M: any = '4'\nexport const LGPT3_DESC_STDIPOFF_S: any = '4'\n/**\nIP Instance ID number. If multiple instances of IP exist in the device, this field can identify the instance number.*/\nexport const LGPT3_DESC_INSTIDX: any = '4'\nexport const LGPT3_DESC_INSTIDX_M: any = '4'\nexport const LGPT3_DESC_INSTIDX_S: any = '4'\n/**\nMajor revision of IP.*/\nexport const LGPT3_DESC_MAJREV: any = '4'\nexport const LGPT3_DESC_MAJREV_M: any = '4'\nexport const LGPT3_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP.*/\nexport const LGPT3_DESC_MINREV: any = '4'\nexport const LGPT3_DESC_MINREV_M: any = '4'\nexport const LGPT3_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER DESCEX -------- //\n\n/**\nDescription Extended\n\n\nThis register describes the parameters of the LGPT.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_DESCEX_RESERVED20: any = '12'\nexport const LGPT3_DESCEX_RESERVED20_M: any = '12'\nexport const LGPT3_DESCEX_RESERVED20_S: any = '12'\n/**\nHas IR logic.*/\nexport const LGPT3_DESCEX_HIR: any = '1'\nexport const LGPT3_DESCEX_HIR_M: any = '1'\nexport const LGPT3_DESCEX_HIR_S: any = '1'\n/**\nHas Dead-Band, Fault, and Park logic.*/\nexport const LGPT3_DESCEX_HDBF: any = '1'\nexport const LGPT3_DESCEX_HDBF_M: any = '1'\nexport const LGPT3_DESCEX_HDBF_S: any = '1'\n/**\nPrescale width. The prescaler can maximum be configured to 2^PREW-1.*/\nexport const LGPT3_DESCEX_PREW: any = '4'\nexport const LGPT3_DESCEX_PREW_M: any = '4'\nexport const LGPT3_DESCEX_PREW_S: any = '4'\n/**\nHas Quadrature Decoder.*/\nexport const LGPT3_DESCEX_HQDEC: any = '1'\nexport const LGPT3_DESCEX_HQDEC_M: any = '1'\nexport const LGPT3_DESCEX_HQDEC_S: any = '1'\n/**\nHas channel input filter.*/\nexport const LGPT3_DESCEX_HCIF: any = '1'\nexport const LGPT3_DESCEX_HCIF_M: any = '1'\nexport const LGPT3_DESCEX_HCIF_S: any = '1'\n/**\nChannel input filter size. The prevailing state filter can maximum be configured to 2^CIFS-1.*/\nexport const LGPT3_DESCEX_CIFS: any = '4'\nexport const LGPT3_DESCEX_CIFS_M: any = '4'\nexport const LGPT3_DESCEX_CIFS_S: any = '4'\n/**\nHas uDMA output and logic.*/\nexport const LGPT3_DESCEX_HDMA: any = '1'\nexport const LGPT3_DESCEX_HDMA_M: any = '1'\nexport const LGPT3_DESCEX_HDMA_S: any = '1'\n/**\nHas interrupt output and logic.*/\nexport const LGPT3_DESCEX_HINT: any = '1'\nexport const LGPT3_DESCEX_HINT_M: any = '1'\nexport const LGPT3_DESCEX_HINT_S: any = '1'\n/**\nCounter bit-width.\n\nThe maximum counter value is equal to 2^CNTRW-1.\n*/\nexport const LGPT3_DESCEX_CNTRW: any = '2'\nexport const LGPT3_DESCEX_CNTRW_M: any = '2'\nexport const LGPT3_DESCEX_CNTRW_S: any = '2'\n/**\nRESERVED*/\nexport const LGPT3_DESCEX_CNTRW_RESERVED: any = '3'\n\n/**\n32-bit counter.*/\nexport const LGPT3_DESCEX_CNTRW_CNTR32: any = '2'\n\n/**\n24-bit counter.*/\nexport const LGPT3_DESCEX_CNTRW_CNTR24: any = '1'\n\n/**\n16-bit counter.*/\nexport const LGPT3_DESCEX_CNTRW_CNTR16: any = '0'\n\n/**\nNumber of channels.*/\nexport const LGPT3_DESCEX_NCH: any = '4'\nexport const LGPT3_DESCEX_NCH_M: any = '4'\nexport const LGPT3_DESCEX_NCH_S: any = '4'\n\n// -------- REGISTER STARTCFG -------- //\n\n/**\nStart Configuration\n\n\nThis register is only for when CTL.MODE is configured to one of the SYNC modes.\nThis register defines when this LGPT starts.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_STARTCFG_RESERVED2: any = '30'\nexport const LGPT3_STARTCFG_RESERVED2_M: any = '30'\nexport const LGPT3_STARTCFG_RESERVED2_S: any = '30'\n/**\nLGPT start\n\n*/\nexport const LGPT3_STARTCFG_LGPT0: any = '2'\nexport const LGPT3_STARTCFG_LGPT0_M: any = '2'\nexport const LGPT3_STARTCFG_LGPT0_S: any = '2'\n/**\nLGPT starts when synchronized event input is high. Configured here EVTSVT.LGPTSYNCSEL.*/\nexport const LGPT3_STARTCFG_LGPT0_EV_SYNC: any = '0'\n\n\n// -------- REGISTER CTL -------- //\n\n/**\nTimer Control*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_CTL_RESERVED11: any = '21'\nexport const LGPT3_CTL_RESERVED11_M: any = '21'\nexport const LGPT3_CTL_RESERVED11_S: any = '21'\n/**\nChannel 2 reset.*/\nexport const LGPT3_CTL_C2RST: any = '1'\nexport const LGPT3_CTL_C2RST_M: any = '1'\nexport const LGPT3_CTL_C2RST_S: any = '1'\n/**\nReset C2CC, PC2CC, and C2CFG.*/\nexport const LGPT3_CTL_C2RST_RST: any = '1'\n\n/**\nNo effect.*/\nexport const LGPT3_CTL_C2RST_NOEFF: any = '0'\n\n/**\nChannel 1 reset.*/\nexport const LGPT3_CTL_C1RST: any = '1'\nexport const LGPT3_CTL_C1RST_M: any = '1'\nexport const LGPT3_CTL_C1RST_S: any = '1'\n/**\nReset C1CC, PC1CC, and C1CFG.*/\nexport const LGPT3_CTL_C1RST_RST: any = '1'\n\n/**\nNo effect.*/\nexport const LGPT3_CTL_C1RST_NOEFF: any = '0'\n\n/**\nChannel 0 reset.*/\nexport const LGPT3_CTL_C0RST: any = '1'\nexport const LGPT3_CTL_C0RST_M: any = '1'\nexport const LGPT3_CTL_C0RST_S: any = '1'\n/**\nReset C0CC, PC0CC, and C0CFG.*/\nexport const LGPT3_CTL_C0RST_RST: any = '1'\n\n/**\nNo effect.*/\nexport const LGPT3_CTL_C0RST_NOEFF: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_CTL_RESERVED6: any = '2'\nexport const LGPT3_CTL_RESERVED6_M: any = '2'\nexport const LGPT3_CTL_RESERVED6_S: any = '2'\n/**\nInterrupt Phase.\n\nThis bit field controls when the RIS.TGT and RIS.ZERO interrupts are set.*/\nexport const LGPT3_CTL_INTP: any = '1'\nexport const LGPT3_CTL_INTP_M: any = '1'\nexport const LGPT3_CTL_INTP_S: any = '1'\n/**\nRIS.TGT and RIS.ZERO are set one timer clock cycle after CNTR = TARGET/ZERO.*/\nexport const LGPT3_CTL_INTP_LATE: any = '1'\n\n/**\nRIS.TGT and RIS.ZERO are set one system clock cycle after CNTR = TARGET/ZERO.*/\nexport const LGPT3_CTL_INTP_EARLY: any = '0'\n\n/**\nCompare direction.\n\n\nThis bit field controls the direction the counter must have in order to set the [RIS.CnCC] channel interrupts. This bitfield is only relevant if [CnCFG.CCACT] is configured to a compare action. */\nexport const LGPT3_CTL_CMPDIR: any = '2'\nexport const LGPT3_CTL_CMPDIR_M: any = '2'\nexport const LGPT3_CTL_CMPDIR_S: any = '2'\n/**\nRESERVED*/\nexport const LGPT3_CTL_CMPDIR_RESERVED: any = '3'\n\n/**\nCompare RIS fields are only set on down count.*/\nexport const LGPT3_CTL_CMPDIR_DOWN: any = '2'\n\n/**\nCompare RIS fields are only set on up count.*/\nexport const LGPT3_CTL_CMPDIR_UP: any = '1'\n\n/**\nCompare RIS fields are set on up count and down count.*/\nexport const LGPT3_CTL_CMPDIR_BOTH: any = '0'\n\n/**\nTimer mode control\n\n\nThe CNTR restarts from 0 when MODE is written to UP_ONCE, UP_PER, UPDWN_PER, QDEC, SYNC_UP_ONCE, SYNC_UP_PER or SYNC_UPDWN_PER.\n\nWhen writing MODE all internally queued updates to the channels and TGT is cleared.\n\nWhen configuring the timer, MODE should be the last thing to configure. If changing timer configuration after MODE has been set is necessary, instructions, if any, given in the configuration registers should be followed. See for example C0CFG.\n*/\nexport const LGPT3_CTL_MODE: any = '3'\nexport const LGPT3_CTL_MODE_M: any = '3'\nexport const LGPT3_CTL_MODE_S: any = '3'\n/**\nStart counting up and down periodically synchronous to another LGPT,  selected within STARTCFG. The timer is started by setting CTL.MODE = UPDWN_PER automatically. \n\nIt then operates as a normal timer in CTL.MODE = UPDWN_PER, counting from 0 to target value and back to 0, repeatedly.\n\nPeriod =  (target value * 2) * timer clock period*/\nexport const LGPT3_CTL_MODE_SYNC_UPDWN_PER: any = '7'\n\n/**\nStart counting up periodically synchronous to another LGPT,  selected within STARTCFG. The timer is started by setting CTL.MODE = UP_PER automatically. \n\nIt then operates as a normal timer in CTL.MODE = UP_PER, incrementing from 0 to target value, repeatedly.\n\nPeriod =  (target value * 2) * timer clock period\n*/\nexport const LGPT3_CTL_MODE_SYNC_UP_PER: any = '6'\n\n/**\nStart counting up once synchronous to another LGPT, selected within STARTCFG. The timer is started by setting CTL.MODE = UP_ONCE automatically. \n\nIt then functions as a normal timer in CTL.MODE = UP_ONCE, incrementing from 0 to target value,  then stops and sets MODE to DIS.\n*/\nexport const LGPT3_CTL_MODE_SYNC_UP_ONCE: any = '5'\n\n/**\nThe timer functions as a quadrature decoder. IOC input 0, IOC input 1 and IOC input 2 are used respectivly as PHA, PHB and IDX inputs. IDX can be turned off by setting C2CFG.EDGE = NONE.\n\nThe timer clock frequency sets the sample rate of the QDEC logic. This frequency can be configured in PRECFG.*/\nexport const LGPT3_CTL_MODE_QDEC: any = '4'\n\n/**\nCount up and down periodically. The timer counts from 0 to target value and back to 0, repeatedly.\n\n\nPeriod =  (target value * 2) * timer clock period*/\nexport const LGPT3_CTL_MODE_UPDWN_PER: any = '3'\n\n/**\nCount up periodically. The timer increments from 0 to target value, repeatedly.\n\n\nPeriod = (target value + 1) * timer clock period*/\nexport const LGPT3_CTL_MODE_UP_PER: any = '2'\n\n/**\nCount up once. The timer increments from 0 to target value,  then stops and sets MODE to DIS.*/\nexport const LGPT3_CTL_MODE_UP_ONCE: any = '1'\n\n/**\nDisable timer. Updates to counter, channels, and events stop.*/\nexport const LGPT3_CTL_MODE_DIS: any = '0'\n\n\n// -------- REGISTER OUTCTL -------- //\n\n/**\nOutput Control\n\n\nSet and clear individual outputs manually. Manual update of an output takes priority over automatic channel updates to the same output. It is not possible to set and clear an output at the same time, such requests will be neglected.\n\nAn output can be automatically cleared, set, toggled, or pulsed by each channel, listed in decreasing order of priority. The action with highest priority happens when multiple channels want to update an output at the same time.\n\nAll outputs are connected to the event fabric and the IO controller. The outputs going to the IO controller have an aditional complementary output, this output is the inverted IO output. Both the IO and the IO complementary outputs are passed through an IO Controller, see IOCTL.\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_OUTCTL_RESERVED6: any = '26'\nexport const LGPT3_OUTCTL_RESERVED6_M: any = '26'\nexport const LGPT3_OUTCTL_RESERVED6_S: any = '26'\n/**\nSet output 2.\n\n\nWrite 1 to set output 2.*/\nexport const LGPT3_OUTCTL_SETOUT2: any = '1'\nexport const LGPT3_OUTCTL_SETOUT2_M: any = '1'\nexport const LGPT3_OUTCTL_SETOUT2_S: any = '1'\n/**\nClear output 2.\n\n\nWrite 1 to clear output 2.*/\nexport const LGPT3_OUTCTL_CLROUT2: any = '1'\nexport const LGPT3_OUTCTL_CLROUT2_M: any = '1'\nexport const LGPT3_OUTCTL_CLROUT2_S: any = '1'\n/**\nSet output 1.\n\n\nWrite 1 to set output 1.*/\nexport const LGPT3_OUTCTL_SETOUT1: any = '1'\nexport const LGPT3_OUTCTL_SETOUT1_M: any = '1'\nexport const LGPT3_OUTCTL_SETOUT1_S: any = '1'\n/**\nClear output 1.\n\n\nWrite 1 to clear output 1.*/\nexport const LGPT3_OUTCTL_CLROUT1: any = '1'\nexport const LGPT3_OUTCTL_CLROUT1_M: any = '1'\nexport const LGPT3_OUTCTL_CLROUT1_S: any = '1'\n/**\nSet output 0.\n\n\nWrite 1 to set output 0.*/\nexport const LGPT3_OUTCTL_SETOUT0: any = '1'\nexport const LGPT3_OUTCTL_SETOUT0_M: any = '1'\nexport const LGPT3_OUTCTL_SETOUT0_S: any = '1'\n/**\nClear output 0.\n\n\nWrite 1 to clear output 0.*/\nexport const LGPT3_OUTCTL_CLROUT0: any = '1'\nexport const LGPT3_OUTCTL_CLROUT0_M: any = '1'\nexport const LGPT3_OUTCTL_CLROUT0_S: any = '1'\n\n// -------- REGISTER CNTR -------- //\n\n/**\nCounter\n\nThe counter of this timer. After CTL.MODE is set the counter updates at the rate specified in PRECFG.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_CNTR_RESERVED24: any = '8'\nexport const LGPT3_CNTR_RESERVED24_M: any = '8'\nexport const LGPT3_CNTR_RESERVED24_S: any = '8'\n/**\nCurrent counter value.\n\nIf CTL.MODE = QDEC this can be used to set the initial counter value during QDEC.  Writing to CNTR in other modes than QDEC is possible, but may result in unpredictable behavior.*/\nexport const LGPT3_CNTR_VAL: any = '24'\nexport const LGPT3_CNTR_VAL_M: any = '24'\nexport const LGPT3_CNTR_VAL_S: any = '24'\n\n// -------- REGISTER PRECFG -------- //\n\n/**\nClock Prescaler Configuration\n\n\nThis register is used to set the timer clock period. The prescaler is a counter which counts down from the value TICKDIV. When the prescaler counter reaches zero, CNTR is updated. The field TICKDIV effectively divides the prescaler tick source. The timer clock frequency can be calculated as TICKSRC/(TICKDIV+1).*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PRECFG_RESERVED16: any = '16'\nexport const LGPT3_PRECFG_RESERVED16_M: any = '16'\nexport const LGPT3_PRECFG_RESERVED16_S: any = '16'\n/**\nTick division.\n\n\nTICKDIV determines the timer clock frequency for the counter, and timer output updates. The timer clock frequency is the clock selected by TICKSRC divided by (TICKDIV + 1). This inverse is the timer clock period.\n\n0x00: Divide by 1.\n0x01: Divide by 2.\n... \n0xFF: Divide by 256.*/\nexport const LGPT3_PRECFG_TICKDIV: any = '8'\nexport const LGPT3_PRECFG_TICKDIV_M: any = '8'\nexport const LGPT3_PRECFG_TICKDIV_S: any = '8'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PRECFG_RESERVED2: any = '6'\nexport const LGPT3_PRECFG_RESERVED2_M: any = '6'\nexport const LGPT3_PRECFG_RESERVED2_S: any = '6'\n/**\nPrescaler tick source.\n\n\nTICKSRC determines the source which decrements the prescaler.*/\nexport const LGPT3_PRECFG_TICKSRC: any = '2'\nexport const LGPT3_PRECFG_TICKSRC_M: any = '2'\nexport const LGPT3_PRECFG_TICKSRC_S: any = '2'\n/**\nPrescaler is updated at both edges of TICKEN.*/\nexport const LGPT3_PRECFG_TICKSRC_BOTH_TICK: any = '3'\n\n/**\nPrescaler is updated at the falling edge of TICKEN.*/\nexport const LGPT3_PRECFG_TICKSRC_FALL_TICK: any = '2'\n\n/**\nPrescaler is updated at the rising edge of TICKEN.*/\nexport const LGPT3_PRECFG_TICKSRC_RISE_TICK: any = '1'\n\n/**\nPrescaler is updated at the system clock.*/\nexport const LGPT3_PRECFG_TICKSRC_CLK: any = '0'\n\n\n// -------- REGISTER PREEVENT -------- //\n\n/**\nPrescaler Event\n\n\nThis register is used to output a logic high signal before the zero crossing of the prescaler counter. The output is routed to the IOC.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PREEVENT_RESERVED8: any = '24'\nexport const LGPT3_PREEVENT_RESERVED8_M: any = '24'\nexport const LGPT3_PREEVENT_RESERVED8_S: any = '24'\n/**\nSets the HIGH time of the prescaler event output. \n\n\nEvent goes high when the prescaler counter equals VAL. Event goes low when prescaler counter is 0.\n\nNote:\n- Can be used to precharge or turn an external component on for a short time before sampling, like in QDEC.\n- If there is a requirement to create such events that have very short periods compared to timer clock period, use two timers. One timer acts as prescaler and event generator for another timer.*/\nexport const LGPT3_PREEVENT_VAL: any = '8'\nexport const LGPT3_PREEVENT_VAL_M: any = '8'\nexport const LGPT3_PREEVENT_VAL_S: any = '8'\n\n// -------- REGISTER CHFILT -------- //\n\n/**\nChannel Input Filter\n\n\nThis register is used to configure the filter on the channel inputs. The configuration is for all inputs.\nThe filter is enabled when a channel is in capture mode.\n\nThe input to the filter is passed to the edge detection logic if LOAD + 1 consecutive input samples are equal. The filter functions as a down counter, counting down every input sample.\nIf two consecutive samples are unequal, the filter counter restarts from LOAD.\nIf the filter counter reaches zero, the input signal is valid and passed to the edge detection logic.\n\nThe channel filter should only be configured while the CTL.MODE = DIS. Configuring the filter while the timer is running can result in unexpected behavior.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_CHFILT_RESERVED16: any = '16'\nexport const LGPT3_CHFILT_RESERVED16_M: any = '16'\nexport const LGPT3_CHFILT_RESERVED16_S: any = '16'\n/**\nThe input of the channel filter is passed to the edge detection logic after LOAD + 1 consecutive equal samples.*/\nexport const LGPT3_CHFILT_LOAD: any = '8'\nexport const LGPT3_CHFILT_LOAD_M: any = '8'\nexport const LGPT3_CHFILT_LOAD_S: any = '8'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_CHFILT_RESERVED2: any = '6'\nexport const LGPT3_CHFILT_RESERVED2_M: any = '6'\nexport const LGPT3_CHFILT_RESERVED2_S: any = '6'\n/**\nChannel filter mode*/\nexport const LGPT3_CHFILT_MODE: any = '2'\nexport const LGPT3_CHFILT_MODE_M: any = '2'\nexport const LGPT3_CHFILT_MODE_S: any = '2'\n/**\nFilter is clocked by timer clock.*/\nexport const LGPT3_CHFILT_MODE_TIMERCLK: any = '3'\n\n/**\nFilter is clocked by PRECFG.TICKSRC.*/\nexport const LGPT3_CHFILT_MODE_TICKSRC: any = '2'\n\n/**\nFilter is clocked by system clock.*/\nexport const LGPT3_CHFILT_MODE_CLK: any = '1'\n\n/**\nFilter is bypassed. No Filter is used.*/\nexport const LGPT3_CHFILT_MODE_BYPASS: any = '0'\n\n\n// -------- REGISTER DMA -------- //\n\n/**\nDirect Memory Accsess\n\n\nThis register is used to enable DMA requests from the timer and set the register addresses which the DMA will access (read/write).\nChoose DMA request source by setting the REQ field. The setting of the corresponding interrupt in the RIS registers also sets the DMA request. \nUpon a DMA request defined by REQ an internal address pointer is set to RWADDR*4. Every access to DMARW will increment the internal pointer by 4 such that the next DMA access will be to the next register.\nThe internal pointer will stop after RWCNTR increments. Further access will be ignored.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_DMA_RESERVED20: any = '12'\nexport const LGPT3_DMA_RESERVED20_M: any = '12'\nexport const LGPT3_DMA_RESERVED20_S: any = '12'\n/**\nThe read/write counter. RWCNTR+1 is the number of times the DMA can access (read/write) the DMARW register. For each DMA access to DMARW an internal counter is incremented, writing to the next address field. RWADDR + 4*RWCNTR is the final register address which can be accessed by the DMA.*/\nexport const LGPT3_DMA_RWCNTR: any = '4'\nexport const LGPT3_DMA_RWCNTR_M: any = '4'\nexport const LGPT3_DMA_RWCNTR_S: any = '4'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_DMA_RESERVED15: any = '1'\nexport const LGPT3_DMA_RESERVED15_M: any = '1'\nexport const LGPT3_DMA_RESERVED15_S: any = '1'\n/**\nThe base address which the DMA access when reading/writing DMARW.  The base address is set by taking the 9 LSB of the physical address and divide by 4.\n\nFor example, if you wanted the RWADDR to point to the PTGT register you should set RWADDR = 0x0FC/4.*/\nexport const LGPT3_DMA_RWADDR: any = '7'\nexport const LGPT3_DMA_RWADDR_M: any = '7'\nexport const LGPT3_DMA_RWADDR_S: any = '7'\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_DMA_RESERVED4: any = '4'\nexport const LGPT3_DMA_RESERVED4_M: any = '4'\nexport const LGPT3_DMA_RESERVED4_S: any = '4'\n/**\n*/\nexport const LGPT3_DMA_REQ: any = '4'\nexport const LGPT3_DMA_REQ_M: any = '4'\nexport const LGPT3_DMA_REQ_S: any = '4'\n/**\nSetting of RIS.C11CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C11CC: any = '15'\n\n/**\nSetting of RIS.C10CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C10CC: any = '14'\n\n/**\nSetting of RIS.C9CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C9CC: any = '13'\n\n/**\nSetting of RIS.C8CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C8CC: any = '12'\n\n/**\nSetting of RIS.C7CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C7CC: any = '11'\n\n/**\nSetting of RIS.C6CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C6CC: any = '10'\n\n/**\nSetting of RIS.C5CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C5CC: any = '9'\n\n/**\nSetting of RIS.C4CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C4CC: any = '8'\n\n/**\nSetting of RIS.C3CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C3CC: any = '7'\n\n/**\nSetting of RIS.C2CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C2CC: any = '6'\n\n/**\nSetting of RIS.C1CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C1CC: any = '5'\n\n/**\nSetting of RIS.C0CC generates a DMA request.*/\nexport const LGPT3_DMA_REQ_C0CC: any = '4'\n\n/**\nSetting of RIS.FAULT generates a DMA request.*/\nexport const LGPT3_DMA_REQ_FAULT: any = '3'\n\n/**\nSetting of RIS.ZERO generates a DMA request.*/\nexport const LGPT3_DMA_REQ_ZERO: any = '2'\n\n/**\nSetting of RIS.TGT generates a DMA request.\n\n*/\nexport const LGPT3_DMA_REQ_TGT: any = '1'\n\n/**\nDisabled*/\nexport const LGPT3_DMA_REQ_DIS: any = '0'\n\n\n// -------- REGISTER DMARW -------- //\n\n/**\nDirect Memory Access\n\n\nThis register is used by the DMA to access (read/write) register inside this LGPT module.\nEach access to this register will increment the internal DMA address counter. See DMA for description.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_DMARW_RESERVED24: any = '8'\nexport const LGPT3_DMARW_RESERVED24_M: any = '8'\nexport const LGPT3_DMARW_RESERVED24_S: any = '8'\n/**\nDMA read write value.\n\n\nThe value that is read/written from/to the registers.*/\nexport const LGPT3_DMARW_VAL: any = '24'\nexport const LGPT3_DMARW_VAL_M: any = '24'\nexport const LGPT3_DMARW_VAL_S: any = '24'\n\n// -------- REGISTER ADCTRG -------- //\n\n/**\nADC Trigger\n\n\nThis register is used to enable ADC trigger from the timer. \nChoose ADC trigger source by setting the SRC field. The setting of the corresponding interrupt in the RIS registers also sets the ADC trigger. */\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_ADCTRG_RESERVED4: any = '28'\nexport const LGPT3_ADCTRG_RESERVED4_M: any = '28'\nexport const LGPT3_ADCTRG_RESERVED4_S: any = '28'\n/**\n*/\nexport const LGPT3_ADCTRG_SRC: any = '4'\nexport const LGPT3_ADCTRG_SRC_M: any = '4'\nexport const LGPT3_ADCTRG_SRC_S: any = '4'\n/**\nSetting of RIS.C11CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C11CC: any = '15'\n\n/**\nSetting of RIS.C10CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C10CC: any = '14'\n\n/**\nSetting of RIS.C9CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C9CC: any = '13'\n\n/**\nSetting of RIS.C8CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C8CC: any = '12'\n\n/**\nSetting of RIS.C7CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C7CC: any = '11'\n\n/**\nSetting of RIS.C6CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C6CC: any = '10'\n\n/**\nSetting of RIS.C5CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C5CC: any = '9'\n\n/**\nSetting of RIS.C4CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C4CC: any = '8'\n\n/**\nSetting of RIS.C3CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C3CC: any = '7'\n\n/**\nSetting of RIS.C2CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C2CC: any = '6'\n\n/**\nSetting of RIS.C1CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C1CC: any = '5'\n\n/**\nSetting of RIS.C0CC generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_C0CC: any = '4'\n\n/**\nSetting of RIS.FAULT generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_FAULT: any = '3'\n\n/**\nSetting of RIS.ZERO generates an ADC trigger.*/\nexport const LGPT3_ADCTRG_SRC_ZERO: any = '2'\n\n/**\nSetting of RIS.TGT generates an ADC trigger.\n\n*/\nexport const LGPT3_ADCTRG_SRC_TGT: any = '1'\n\n/**\nDisabled*/\nexport const LGPT3_ADCTRG_SRC_DIS: any = '0'\n\n\n// -------- REGISTER IOCTL -------- //\n\n/**\nIO Controller\n\n\nThis register overrides the IO outputs.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_IOCTL_RESERVED12: any = '20'\nexport const LGPT3_IOCTL_RESERVED12_M: any = '20'\nexport const LGPT3_IOCTL_RESERVED12_S: any = '20'\n/**\nIO complementary output 2 control\n\n\nThis bit field controls IO complementary output 2. */\nexport const LGPT3_IOCTL_COUT2: any = '2'\nexport const LGPT3_IOCTL_COUT2_M: any = '2'\nexport const LGPT3_IOCTL_COUT2_S: any = '2'\n/**\nInverted value. The IO complementary output is inverted.*/\nexport const LGPT3_IOCTL_COUT2_INV: any = '3'\n\n/**\nDriven high. The IO complementary output is driven high.*/\nexport const LGPT3_IOCTL_COUT2_HIGH: any = '2'\n\n/**\nDriven low. The IO complementary output is driven low.*/\nexport const LGPT3_IOCTL_COUT2_LOW: any = '1'\n\n/**\nNormal output. The IO complementary output is not changed.*/\nexport const LGPT3_IOCTL_COUT2_NRM: any = '0'\n\n/**\nIO output 2 control\n\n\nThis bit field controls IO output 2. */\nexport const LGPT3_IOCTL_OUT2: any = '2'\nexport const LGPT3_IOCTL_OUT2_M: any = '2'\nexport const LGPT3_IOCTL_OUT2_S: any = '2'\n/**\nInverted value. The IO output is inverted.*/\nexport const LGPT3_IOCTL_OUT2_INV: any = '3'\n\n/**\nDriven high. The IO output is driven high.*/\nexport const LGPT3_IOCTL_OUT2_HIGH: any = '2'\n\n/**\nDriven low. The IO output is driven low.*/\nexport const LGPT3_IOCTL_OUT2_LOW: any = '1'\n\n/**\nNormal output. The IO output is not changed.*/\nexport const LGPT3_IOCTL_OUT2_NRM: any = '0'\n\n/**\nIO complementary output 1 control\n\n\nThis bit field controls IO complementary output 1. */\nexport const LGPT3_IOCTL_COUT1: any = '2'\nexport const LGPT3_IOCTL_COUT1_M: any = '2'\nexport const LGPT3_IOCTL_COUT1_S: any = '2'\n/**\nInverted value. The IO complementary output is inverted.*/\nexport const LGPT3_IOCTL_COUT1_INV: any = '3'\n\n/**\nDriven high. The IO complementary output is driven high.*/\nexport const LGPT3_IOCTL_COUT1_HIGH: any = '2'\n\n/**\nDriven low. The IO complementary output is driven low.*/\nexport const LGPT3_IOCTL_COUT1_LOW: any = '1'\n\n/**\nNormal output. The IO complementary output is not changed.*/\nexport const LGPT3_IOCTL_COUT1_NRM: any = '0'\n\n/**\nIO output 1 control\n\n\nThis bit field controls IO output 1. */\nexport const LGPT3_IOCTL_OUT1: any = '2'\nexport const LGPT3_IOCTL_OUT1_M: any = '2'\nexport const LGPT3_IOCTL_OUT1_S: any = '2'\n/**\nInverted value. The IO output is inverted.*/\nexport const LGPT3_IOCTL_OUT1_INV: any = '3'\n\n/**\nDriven high. The IO output is driven high.*/\nexport const LGPT3_IOCTL_OUT1_HIGH: any = '2'\n\n/**\nDriven low. The IO output is driven low.*/\nexport const LGPT3_IOCTL_OUT1_LOW: any = '1'\n\n/**\nNormal output. The IO output is not changed.*/\nexport const LGPT3_IOCTL_OUT1_NRM: any = '0'\n\n/**\nIO complementary output 0 control\n\n\nThis bit field controls IO complementary output 0. */\nexport const LGPT3_IOCTL_COUT0: any = '2'\nexport const LGPT3_IOCTL_COUT0_M: any = '2'\nexport const LGPT3_IOCTL_COUT0_S: any = '2'\n/**\nInverted value. The IO complementary output is inverted.*/\nexport const LGPT3_IOCTL_COUT0_INV: any = '3'\n\n/**\nDriven high. The IO complementary output is driven high.*/\nexport const LGPT3_IOCTL_COUT0_HIGH: any = '2'\n\n/**\nDriven low. The IO complementary output is driven low.*/\nexport const LGPT3_IOCTL_COUT0_LOW: any = '1'\n\n/**\nNormal output. The IO complementary output is not changed.*/\nexport const LGPT3_IOCTL_COUT0_NRM: any = '0'\n\n/**\nIO output 0 control\n\n\nThis bit field controls IO output 0. */\nexport const LGPT3_IOCTL_OUT0: any = '2'\nexport const LGPT3_IOCTL_OUT0_M: any = '2'\nexport const LGPT3_IOCTL_OUT0_S: any = '2'\n/**\nInverted value. The IO output is inverted.*/\nexport const LGPT3_IOCTL_OUT0_INV: any = '3'\n\n/**\nDriven high. The IO output is driven high.*/\nexport const LGPT3_IOCTL_OUT0_HIGH: any = '2'\n\n/**\nDriven low. The IO output is driven low.*/\nexport const LGPT3_IOCTL_OUT0_LOW: any = '1'\n\n/**\nNormal output. The IO output is not changed.*/\nexport const LGPT3_IOCTL_OUT0_NRM: any = '0'\n\n\n// -------- REGISTER IMASK -------- //\n\n/**\nInterrupt mask. \n\n\nThis register selects interrupt sources which are allowed to pass from RIS to MIS when the corresponding bit-fields are set to 1.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_IMASK_RESERVED11: any = '21'\nexport const LGPT3_IMASK_RESERVED11_M: any = '21'\nexport const LGPT3_IMASK_RESERVED11_S: any = '21'\n/**\nEnable RIS.C2CC interrupt.*/\nexport const LGPT3_IMASK_C2CC: any = '1'\nexport const LGPT3_IMASK_C2CC_M: any = '1'\nexport const LGPT3_IMASK_C2CC_S: any = '1'\n/**\nEnable*/\nexport const LGPT3_IMASK_C2CC_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT3_IMASK_C2CC_DIS: any = '0'\n\n/**\nEnable RIS.C1CC interrupt.*/\nexport const LGPT3_IMASK_C1CC: any = '1'\nexport const LGPT3_IMASK_C1CC_M: any = '1'\nexport const LGPT3_IMASK_C1CC_S: any = '1'\n/**\nEnable*/\nexport const LGPT3_IMASK_C1CC_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT3_IMASK_C1CC_DIS: any = '0'\n\n/**\nEnable RIS.C0CC interrupt.*/\nexport const LGPT3_IMASK_C0CC: any = '1'\nexport const LGPT3_IMASK_C0CC_M: any = '1'\nexport const LGPT3_IMASK_C0CC_S: any = '1'\n/**\nEnable*/\nexport const LGPT3_IMASK_C0CC_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT3_IMASK_C0CC_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_IMASK_RESERVED7: any = '1'\nexport const LGPT3_IMASK_RESERVED7_M: any = '1'\nexport const LGPT3_IMASK_RESERVED7_S: any = '1'\n/**\nEnable RIS.FAULT interrupt.*/\nexport const LGPT3_IMASK_FAULT: any = '1'\nexport const LGPT3_IMASK_FAULT_M: any = '1'\nexport const LGPT3_IMASK_FAULT_S: any = '1'\n/**\nEnable*/\nexport const LGPT3_IMASK_FAULT_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT3_IMASK_FAULT_DIS: any = '0'\n\n/**\nEnable RIS.IDX interrupt.*/\nexport const LGPT3_IMASK_IDX: any = '1'\nexport const LGPT3_IMASK_IDX_M: any = '1'\nexport const LGPT3_IMASK_IDX_S: any = '1'\n/**\nEnable*/\nexport const LGPT3_IMASK_IDX_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT3_IMASK_IDX_DIS: any = '0'\n\n/**\nEnable RIS.DIRCHNG interrupt.*/\nexport const LGPT3_IMASK_DIRCHNG: any = '1'\nexport const LGPT3_IMASK_DIRCHNG_M: any = '1'\nexport const LGPT3_IMASK_DIRCHNG_S: any = '1'\n/**\nEnable*/\nexport const LGPT3_IMASK_DIRCHNG_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT3_IMASK_DIRCHNG_DIS: any = '0'\n\n/**\nEnable RIS.CNTRCHNG interrupt.*/\nexport const LGPT3_IMASK_CNTRCHNG: any = '1'\nexport const LGPT3_IMASK_CNTRCHNG_M: any = '1'\nexport const LGPT3_IMASK_CNTRCHNG_S: any = '1'\n/**\nEnable*/\nexport const LGPT3_IMASK_CNTRCHNG_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT3_IMASK_CNTRCHNG_DIS: any = '0'\n\n/**\nEnable RIS.DBLTRANS interrupt.*/\nexport const LGPT3_IMASK_DBLTRANS: any = '1'\nexport const LGPT3_IMASK_DBLTRANS_M: any = '1'\nexport const LGPT3_IMASK_DBLTRANS_S: any = '1'\n/**\nEnable*/\nexport const LGPT3_IMASK_DBLTRANS_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT3_IMASK_DBLTRANS_DIS: any = '0'\n\n/**\nEnable RIS.ZERO interrupt.*/\nexport const LGPT3_IMASK_ZERO: any = '1'\nexport const LGPT3_IMASK_ZERO_M: any = '1'\nexport const LGPT3_IMASK_ZERO_S: any = '1'\n/**\nEnable*/\nexport const LGPT3_IMASK_ZERO_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT3_IMASK_ZERO_DIS: any = '0'\n\n/**\nEnable RIS.TGT interrupt.*/\nexport const LGPT3_IMASK_TGT: any = '1'\nexport const LGPT3_IMASK_TGT_M: any = '1'\nexport const LGPT3_IMASK_TGT_S: any = '1'\n/**\nEnable*/\nexport const LGPT3_IMASK_TGT_EN: any = '1'\n\n/**\nDisable*/\nexport const LGPT3_IMASK_TGT_DIS: any = '0'\n\n\n// -------- REGISTER RIS -------- //\n\n/**\nRaw interrupt status. \n\n\nThis register reflects the state of all pending interrupts, regardless of masking. This register allows the user to implement a poll scheme. A flag set in this register can be cleared by writing 1 to the corresponding ICLR register bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_RIS_RESERVED11: any = '21'\nexport const LGPT3_RIS_RESERVED11_M: any = '21'\nexport const LGPT3_RIS_RESERVED11_S: any = '21'\n/**\nStatus of the C2CC interrupt. The interrupt is set when C2CC has capture or compare event. */\nexport const LGPT3_RIS_C2CC: any = '1'\nexport const LGPT3_RIS_C2CC_M: any = '1'\nexport const LGPT3_RIS_C2CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_RIS_C2CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_RIS_C2CC_CLR: any = '0'\n\n/**\nStatus of the C1CC interrupt. The interrupt is set when C1CC has capture or compare event. */\nexport const LGPT3_RIS_C1CC: any = '1'\nexport const LGPT3_RIS_C1CC_M: any = '1'\nexport const LGPT3_RIS_C1CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_RIS_C1CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_RIS_C1CC_CLR: any = '0'\n\n/**\nStatus of the C0CC interrupt. The interrupt is set when C0CC has capture or compare event. */\nexport const LGPT3_RIS_C0CC: any = '1'\nexport const LGPT3_RIS_C0CC_M: any = '1'\nexport const LGPT3_RIS_C0CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_RIS_C0CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_RIS_C0CC_CLR: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_RIS_RESERVED7: any = '1'\nexport const LGPT3_RIS_RESERVED7_M: any = '1'\nexport const LGPT3_RIS_RESERVED7_S: any = '1'\n/**\nStatus of the FAULT interrupt. The interrupt is set immediately on active fault input.*/\nexport const LGPT3_RIS_FAULT: any = '1'\nexport const LGPT3_RIS_FAULT_M: any = '1'\nexport const LGPT3_RIS_FAULT_S: any = '1'\n/**\nSet*/\nexport const LGPT3_RIS_FAULT_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_RIS_FAULT_CLR: any = '0'\n\n/**\nStatus of the IDX interrupt. The interrupt is set when IDX is active. */\nexport const LGPT3_RIS_IDX: any = '1'\nexport const LGPT3_RIS_IDX_M: any = '1'\nexport const LGPT3_RIS_IDX_S: any = '1'\n/**\nSet*/\nexport const LGPT3_RIS_IDX_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_RIS_IDX_CLR: any = '0'\n\n/**\nStatus of the DIRCHNG interrupt. The interrupt is set when the direction of the counter changes. */\nexport const LGPT3_RIS_DIRCHNG: any = '1'\nexport const LGPT3_RIS_DIRCHNG_M: any = '1'\nexport const LGPT3_RIS_DIRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT3_RIS_DIRCHNG_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_RIS_DIRCHNG_CLR: any = '0'\n\n/**\nStatus of the CNTRCHNG interrupt. The interrupt is set when the counter increments or decrements.*/\nexport const LGPT3_RIS_CNTRCHNG: any = '1'\nexport const LGPT3_RIS_CNTRCHNG_M: any = '1'\nexport const LGPT3_RIS_CNTRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT3_RIS_CNTRCHNG_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_RIS_CNTRCHNG_CLR: any = '0'\n\n/**\nStatus of the DBLTRANS interrupt. The interrupt is set when a double transition has happened during QDEC mode.*/\nexport const LGPT3_RIS_DBLTRANS: any = '1'\nexport const LGPT3_RIS_DBLTRANS_M: any = '1'\nexport const LGPT3_RIS_DBLTRANS_S: any = '1'\n/**\nSet*/\nexport const LGPT3_RIS_DBLTRANS_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_RIS_DBLTRANS_CLR: any = '0'\n\n/**\nStatus of the ZERO interrupt. The interrupt is set when CNTR = 0. */\nexport const LGPT3_RIS_ZERO: any = '1'\nexport const LGPT3_RIS_ZERO_M: any = '1'\nexport const LGPT3_RIS_ZERO_S: any = '1'\n/**\nSet*/\nexport const LGPT3_RIS_ZERO_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_RIS_ZERO_CLR: any = '0'\n\n/**\nStatus of the TGT interrupt. The interrupt is set when CNTR = TGT. */\nexport const LGPT3_RIS_TGT: any = '1'\nexport const LGPT3_RIS_TGT_M: any = '1'\nexport const LGPT3_RIS_TGT_S: any = '1'\n/**\nSet*/\nexport const LGPT3_RIS_TGT_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_RIS_TGT_CLR: any = '0'\n\n\n// -------- REGISTER MIS -------- //\n\n/**\nMasked interrupt status. \n\n\nThis register is simply a bitwise AND of the contents of IMASK and RIS.*] registers. A flag set in this register can be cleared by writing 1 to the corresponding ICLR register bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_MIS_RESERVED11: any = '21'\nexport const LGPT3_MIS_RESERVED11_M: any = '21'\nexport const LGPT3_MIS_RESERVED11_S: any = '21'\n/**\nMasked status of the RIS.C2CC interrupt. */\nexport const LGPT3_MIS_C2CC: any = '1'\nexport const LGPT3_MIS_C2CC_M: any = '1'\nexport const LGPT3_MIS_C2CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_MIS_C2CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_MIS_C2CC_CLR: any = '0'\n\n/**\nMasked status of the RIS.C1CC interrupt.*/\nexport const LGPT3_MIS_C1CC: any = '1'\nexport const LGPT3_MIS_C1CC_M: any = '1'\nexport const LGPT3_MIS_C1CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_MIS_C1CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_MIS_C1CC_CLR: any = '0'\n\n/**\nMasked status of the RIS.C0CC interrupt.*/\nexport const LGPT3_MIS_C0CC: any = '1'\nexport const LGPT3_MIS_C0CC_M: any = '1'\nexport const LGPT3_MIS_C0CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_MIS_C0CC_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_MIS_C0CC_CLR: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_MIS_RESERVED7: any = '1'\nexport const LGPT3_MIS_RESERVED7_M: any = '1'\nexport const LGPT3_MIS_RESERVED7_S: any = '1'\n/**\nMasked status of the RIS.FAULT interrupt.*/\nexport const LGPT3_MIS_FAULT: any = '1'\nexport const LGPT3_MIS_FAULT_M: any = '1'\nexport const LGPT3_MIS_FAULT_S: any = '1'\n/**\nSet*/\nexport const LGPT3_MIS_FAULT_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_MIS_FAULT_CLR: any = '0'\n\n/**\nMasked status of the RIS.IDX interrupt.*/\nexport const LGPT3_MIS_IDX: any = '1'\nexport const LGPT3_MIS_IDX_M: any = '1'\nexport const LGPT3_MIS_IDX_S: any = '1'\n/**\nSet*/\nexport const LGPT3_MIS_IDX_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_MIS_IDX_CLR: any = '0'\n\n/**\nMasked status of the RIS.DIRCHNG interrupt.*/\nexport const LGPT3_MIS_DIRCHNG: any = '1'\nexport const LGPT3_MIS_DIRCHNG_M: any = '1'\nexport const LGPT3_MIS_DIRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT3_MIS_DIRCHNG_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_MIS_DIRCHNG_CLR: any = '0'\n\n/**\nMasked status of the RIS.CNTRCHNG interrupt.*/\nexport const LGPT3_MIS_CNTRCHNG: any = '1'\nexport const LGPT3_MIS_CNTRCHNG_M: any = '1'\nexport const LGPT3_MIS_CNTRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT3_MIS_CNTRCHNG_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_MIS_CNTRCHNG_CLR: any = '0'\n\n/**\nMasked status of the RIS.DBLTRANS interrupt.*/\nexport const LGPT3_MIS_DBLTRANS: any = '1'\nexport const LGPT3_MIS_DBLTRANS_M: any = '1'\nexport const LGPT3_MIS_DBLTRANS_S: any = '1'\n/**\nSet*/\nexport const LGPT3_MIS_DBLTRANS_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_MIS_DBLTRANS_CLR: any = '0'\n\n/**\nMasked status of the RIS.ZERO interrupt.*/\nexport const LGPT3_MIS_ZERO: any = '1'\nexport const LGPT3_MIS_ZERO_M: any = '1'\nexport const LGPT3_MIS_ZERO_S: any = '1'\n/**\nSet*/\nexport const LGPT3_MIS_ZERO_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_MIS_ZERO_CLR: any = '0'\n\n/**\nMasked status of the RIS.TGT interrupt.*/\nexport const LGPT3_MIS_TGT: any = '1'\nexport const LGPT3_MIS_TGT_M: any = '1'\nexport const LGPT3_MIS_TGT_S: any = '1'\n/**\nSet*/\nexport const LGPT3_MIS_TGT_SET: any = '1'\n\n/**\nCleared*/\nexport const LGPT3_MIS_TGT_CLR: any = '0'\n\n\n// -------- REGISTER ISET -------- //\n\n/**\nInterrupt set register. \n\n\nThis register can used by software for diagnostics and safety checking purposes. Writing a 1 to a bit in this register will set the event and the corresponding RIS bit also gets set. If the corresponding IMASK bit is set, then the corresponding MIS register bit also gets set.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_ISET_RESERVED11: any = '21'\nexport const LGPT3_ISET_RESERVED11_M: any = '21'\nexport const LGPT3_ISET_RESERVED11_S: any = '21'\n/**\nSet the RIS.C2CC interrupt. */\nexport const LGPT3_ISET_C2CC: any = '1'\nexport const LGPT3_ISET_C2CC_M: any = '1'\nexport const LGPT3_ISET_C2CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_ISET_C2CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ISET_C2CC_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.C1CC interrupt.*/\nexport const LGPT3_ISET_C1CC: any = '1'\nexport const LGPT3_ISET_C1CC_M: any = '1'\nexport const LGPT3_ISET_C1CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_ISET_C1CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ISET_C1CC_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.C0CC interrupt.*/\nexport const LGPT3_ISET_C0CC: any = '1'\nexport const LGPT3_ISET_C0CC_M: any = '1'\nexport const LGPT3_ISET_C0CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_ISET_C0CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ISET_C0CC_NO_EFFECT: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_ISET_RESERVED7: any = '1'\nexport const LGPT3_ISET_RESERVED7_M: any = '1'\nexport const LGPT3_ISET_RESERVED7_S: any = '1'\n/**\nSet the RIS.FAULT interrupt.*/\nexport const LGPT3_ISET_FAULT: any = '1'\nexport const LGPT3_ISET_FAULT_M: any = '1'\nexport const LGPT3_ISET_FAULT_S: any = '1'\n/**\nSet*/\nexport const LGPT3_ISET_FAULT_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ISET_FAULT_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.IDX interrupt.*/\nexport const LGPT3_ISET_IDX: any = '1'\nexport const LGPT3_ISET_IDX_M: any = '1'\nexport const LGPT3_ISET_IDX_S: any = '1'\n/**\nSet*/\nexport const LGPT3_ISET_IDX_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ISET_IDX_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.DIRCHNG interrupt.*/\nexport const LGPT3_ISET_DIRCHNG: any = '1'\nexport const LGPT3_ISET_DIRCHNG_M: any = '1'\nexport const LGPT3_ISET_DIRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT3_ISET_DIRCHNG_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ISET_DIRCHNG_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.CNTRCHNG interrupt.*/\nexport const LGPT3_ISET_CNTRCHNG: any = '1'\nexport const LGPT3_ISET_CNTRCHNG_M: any = '1'\nexport const LGPT3_ISET_CNTRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT3_ISET_CNTRCHNG_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ISET_CNTRCHNG_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.DBLTRANS interrupt.*/\nexport const LGPT3_ISET_DBLTRANS: any = '1'\nexport const LGPT3_ISET_DBLTRANS_M: any = '1'\nexport const LGPT3_ISET_DBLTRANS_S: any = '1'\n/**\nSet*/\nexport const LGPT3_ISET_DBLTRANS_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ISET_DBLTRANS_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.ZERO interrupt.*/\nexport const LGPT3_ISET_ZERO: any = '1'\nexport const LGPT3_ISET_ZERO_M: any = '1'\nexport const LGPT3_ISET_ZERO_S: any = '1'\n/**\nSet*/\nexport const LGPT3_ISET_ZERO_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ISET_ZERO_NO_EFFECT: any = '0'\n\n/**\nSet the RIS.TGT interrupt.*/\nexport const LGPT3_ISET_TGT: any = '1'\nexport const LGPT3_ISET_TGT_M: any = '1'\nexport const LGPT3_ISET_TGT_S: any = '1'\n/**\nSet*/\nexport const LGPT3_ISET_TGT_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ISET_TGT_NO_EFFECT: any = '0'\n\n\n// -------- REGISTER ICLR -------- //\n\n/**\nInterrupt clear register. \n\n\nThis register allows software to clear interrupts. Writing a 1 to a bit in this register will clear the event and the corresponding RIS bit also gets cleared. If the corresponding IMASK bit is set, then the corresponding MIS register bit also gets cleared.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_ICLR_RESERVED11: any = '21'\nexport const LGPT3_ICLR_RESERVED11_M: any = '21'\nexport const LGPT3_ICLR_RESERVED11_S: any = '21'\n/**\nClear the RIS.C2CC interrupt. */\nexport const LGPT3_ICLR_C2CC: any = '1'\nexport const LGPT3_ICLR_C2CC_M: any = '1'\nexport const LGPT3_ICLR_C2CC_S: any = '1'\n/**\nClear*/\nexport const LGPT3_ICLR_C2CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ICLR_C2CC_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.C1CC interrupt.*/\nexport const LGPT3_ICLR_C1CC: any = '1'\nexport const LGPT3_ICLR_C1CC_M: any = '1'\nexport const LGPT3_ICLR_C1CC_S: any = '1'\n/**\nClear*/\nexport const LGPT3_ICLR_C1CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ICLR_C1CC_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.C0CC interrupt.*/\nexport const LGPT3_ICLR_C0CC: any = '1'\nexport const LGPT3_ICLR_C0CC_M: any = '1'\nexport const LGPT3_ICLR_C0CC_S: any = '1'\n/**\nClear*/\nexport const LGPT3_ICLR_C0CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ICLR_C0CC_NO_EFFECT: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_ICLR_RESERVED7: any = '1'\nexport const LGPT3_ICLR_RESERVED7_M: any = '1'\nexport const LGPT3_ICLR_RESERVED7_S: any = '1'\n/**\nClear the RIS.FAULT interrupt.*/\nexport const LGPT3_ICLR_FAULT: any = '1'\nexport const LGPT3_ICLR_FAULT_M: any = '1'\nexport const LGPT3_ICLR_FAULT_S: any = '1'\n/**\nClear*/\nexport const LGPT3_ICLR_FAULT_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ICLR_FAULT_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.IDX interrupt.*/\nexport const LGPT3_ICLR_IDX: any = '1'\nexport const LGPT3_ICLR_IDX_M: any = '1'\nexport const LGPT3_ICLR_IDX_S: any = '1'\n/**\nClear*/\nexport const LGPT3_ICLR_IDX_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ICLR_IDX_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.DIRCHNG interrupt.*/\nexport const LGPT3_ICLR_DIRCHNG: any = '1'\nexport const LGPT3_ICLR_DIRCHNG_M: any = '1'\nexport const LGPT3_ICLR_DIRCHNG_S: any = '1'\n/**\nClear*/\nexport const LGPT3_ICLR_DIRCHNG_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ICLR_DIRCHNG_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.CNTRCHNG interrupt.*/\nexport const LGPT3_ICLR_CNTRCHNG: any = '1'\nexport const LGPT3_ICLR_CNTRCHNG_M: any = '1'\nexport const LGPT3_ICLR_CNTRCHNG_S: any = '1'\n/**\nClear*/\nexport const LGPT3_ICLR_CNTRCHNG_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ICLR_CNTRCHNG_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.DBLTRANS interrupt.*/\nexport const LGPT3_ICLR_DBLTRANS: any = '1'\nexport const LGPT3_ICLR_DBLTRANS_M: any = '1'\nexport const LGPT3_ICLR_DBLTRANS_S: any = '1'\n/**\nClear*/\nexport const LGPT3_ICLR_DBLTRANS_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ICLR_DBLTRANS_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.ZERO interrupt.*/\nexport const LGPT3_ICLR_ZERO: any = '1'\nexport const LGPT3_ICLR_ZERO_M: any = '1'\nexport const LGPT3_ICLR_ZERO_S: any = '1'\n/**\nClear*/\nexport const LGPT3_ICLR_ZERO_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ICLR_ZERO_NO_EFFECT: any = '0'\n\n/**\nClear the RIS.TGT interrupt.*/\nexport const LGPT3_ICLR_TGT: any = '1'\nexport const LGPT3_ICLR_TGT_M: any = '1'\nexport const LGPT3_ICLR_TGT_S: any = '1'\n/**\nClear*/\nexport const LGPT3_ICLR_TGT_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_ICLR_TGT_NO_EFFECT: any = '0'\n\n\n// -------- REGISTER IMSET -------- //\n\n/**\nInterrupt mask set register. \n\n\nWriting a 1 to a bit in this register will set the corresponding IMASK bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_IMSET_RESERVED11: any = '21'\nexport const LGPT3_IMSET_RESERVED11_M: any = '21'\nexport const LGPT3_IMSET_RESERVED11_S: any = '21'\n/**\nSet the MIS.C2CC mask. */\nexport const LGPT3_IMSET_C2CC: any = '1'\nexport const LGPT3_IMSET_C2CC_M: any = '1'\nexport const LGPT3_IMSET_C2CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_IMSET_C2CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMSET_C2CC_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.C1CC mask.*/\nexport const LGPT3_IMSET_C1CC: any = '1'\nexport const LGPT3_IMSET_C1CC_M: any = '1'\nexport const LGPT3_IMSET_C1CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_IMSET_C1CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMSET_C1CC_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.C0CC mask.*/\nexport const LGPT3_IMSET_C0CC: any = '1'\nexport const LGPT3_IMSET_C0CC_M: any = '1'\nexport const LGPT3_IMSET_C0CC_S: any = '1'\n/**\nSet*/\nexport const LGPT3_IMSET_C0CC_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMSET_C0CC_NO_EFFECT: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_IMSET_RESERVED7: any = '1'\nexport const LGPT3_IMSET_RESERVED7_M: any = '1'\nexport const LGPT3_IMSET_RESERVED7_S: any = '1'\n/**\nSet the MIS.FAULT mask.*/\nexport const LGPT3_IMSET_FAULT: any = '1'\nexport const LGPT3_IMSET_FAULT_M: any = '1'\nexport const LGPT3_IMSET_FAULT_S: any = '1'\n/**\nSet*/\nexport const LGPT3_IMSET_FAULT_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMSET_FAULT_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.IDX mask.*/\nexport const LGPT3_IMSET_IDX: any = '1'\nexport const LGPT3_IMSET_IDX_M: any = '1'\nexport const LGPT3_IMSET_IDX_S: any = '1'\n/**\nSet*/\nexport const LGPT3_IMSET_IDX_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMSET_IDX_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.DIRCHNG mask.*/\nexport const LGPT3_IMSET_DIRCHNG: any = '1'\nexport const LGPT3_IMSET_DIRCHNG_M: any = '1'\nexport const LGPT3_IMSET_DIRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT3_IMSET_DIRCHNG_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMSET_DIRCHNG_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.CNTRCHNG mask.*/\nexport const LGPT3_IMSET_CNTRCHNG: any = '1'\nexport const LGPT3_IMSET_CNTRCHNG_M: any = '1'\nexport const LGPT3_IMSET_CNTRCHNG_S: any = '1'\n/**\nSet*/\nexport const LGPT3_IMSET_CNTRCHNG_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMSET_CNTRCHNG_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.DBLTRANS mask.*/\nexport const LGPT3_IMSET_DBLTRANS: any = '1'\nexport const LGPT3_IMSET_DBLTRANS_M: any = '1'\nexport const LGPT3_IMSET_DBLTRANS_S: any = '1'\n/**\nSet*/\nexport const LGPT3_IMSET_DBLTRANS_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMSET_DBLTRANS_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.ZERO mask.*/\nexport const LGPT3_IMSET_ZERO: any = '1'\nexport const LGPT3_IMSET_ZERO_M: any = '1'\nexport const LGPT3_IMSET_ZERO_S: any = '1'\n/**\nSet*/\nexport const LGPT3_IMSET_ZERO_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMSET_ZERO_NO_EFFECT: any = '0'\n\n/**\nSet the MIS.TGT mask.*/\nexport const LGPT3_IMSET_TGT: any = '1'\nexport const LGPT3_IMSET_TGT_M: any = '1'\nexport const LGPT3_IMSET_TGT_S: any = '1'\n/**\nSet*/\nexport const LGPT3_IMSET_TGT_SET: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMSET_TGT_NO_EFFECT: any = '0'\n\n\n// -------- REGISTER IMCLR -------- //\n\n/**\nInterrupt mask clear register. \n\n\nWriting a 1 to a bit in this register will clear the corresponding IMASK bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_IMCLR_RESERVED11: any = '21'\nexport const LGPT3_IMCLR_RESERVED11_M: any = '21'\nexport const LGPT3_IMCLR_RESERVED11_S: any = '21'\n/**\nClear the MIS.C2CC mask. */\nexport const LGPT3_IMCLR_C2CC: any = '1'\nexport const LGPT3_IMCLR_C2CC_M: any = '1'\nexport const LGPT3_IMCLR_C2CC_S: any = '1'\n/**\nClear*/\nexport const LGPT3_IMCLR_C2CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMCLR_C2CC_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.C1CC mask.*/\nexport const LGPT3_IMCLR_C1CC: any = '1'\nexport const LGPT3_IMCLR_C1CC_M: any = '1'\nexport const LGPT3_IMCLR_C1CC_S: any = '1'\n/**\nClear*/\nexport const LGPT3_IMCLR_C1CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMCLR_C1CC_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.C0CC mask.*/\nexport const LGPT3_IMCLR_C0CC: any = '1'\nexport const LGPT3_IMCLR_C0CC_M: any = '1'\nexport const LGPT3_IMCLR_C0CC_S: any = '1'\n/**\nClear*/\nexport const LGPT3_IMCLR_C0CC_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMCLR_C0CC_NO_EFFECT: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_IMCLR_RESERVED7: any = '1'\nexport const LGPT3_IMCLR_RESERVED7_M: any = '1'\nexport const LGPT3_IMCLR_RESERVED7_S: any = '1'\n/**\nClear the MIS.FAULT mask.*/\nexport const LGPT3_IMCLR_FAULT: any = '1'\nexport const LGPT3_IMCLR_FAULT_M: any = '1'\nexport const LGPT3_IMCLR_FAULT_S: any = '1'\n/**\nClear*/\nexport const LGPT3_IMCLR_FAULT_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMCLR_FAULT_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.IDX mask.*/\nexport const LGPT3_IMCLR_IDX: any = '1'\nexport const LGPT3_IMCLR_IDX_M: any = '1'\nexport const LGPT3_IMCLR_IDX_S: any = '1'\n/**\nClear*/\nexport const LGPT3_IMCLR_IDX_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMCLR_IDX_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.DIRCHNG mask.*/\nexport const LGPT3_IMCLR_DIRCHNG: any = '1'\nexport const LGPT3_IMCLR_DIRCHNG_M: any = '1'\nexport const LGPT3_IMCLR_DIRCHNG_S: any = '1'\n/**\nClear*/\nexport const LGPT3_IMCLR_DIRCHNG_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMCLR_DIRCHNG_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.CNTRCHNG mask.*/\nexport const LGPT3_IMCLR_CNTRCHNG: any = '1'\nexport const LGPT3_IMCLR_CNTRCHNG_M: any = '1'\nexport const LGPT3_IMCLR_CNTRCHNG_S: any = '1'\n/**\nClear*/\nexport const LGPT3_IMCLR_CNTRCHNG_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMCLR_CNTRCHNG_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.DBLTRANS mask.*/\nexport const LGPT3_IMCLR_DBLTRANS: any = '1'\nexport const LGPT3_IMCLR_DBLTRANS_M: any = '1'\nexport const LGPT3_IMCLR_DBLTRANS_S: any = '1'\n/**\nClear*/\nexport const LGPT3_IMCLR_DBLTRANS_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMCLR_DBLTRANS_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.ZERO mask.*/\nexport const LGPT3_IMCLR_ZERO: any = '1'\nexport const LGPT3_IMCLR_ZERO_M: any = '1'\nexport const LGPT3_IMCLR_ZERO_S: any = '1'\n/**\nClear*/\nexport const LGPT3_IMCLR_ZERO_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMCLR_ZERO_NO_EFFECT: any = '0'\n\n/**\nClear the MIS.TGT mask.*/\nexport const LGPT3_IMCLR_TGT: any = '1'\nexport const LGPT3_IMCLR_TGT_M: any = '1'\nexport const LGPT3_IMCLR_TGT_S: any = '1'\n/**\nClear*/\nexport const LGPT3_IMCLR_TGT_CLR: any = '1'\n\n/**\nNo effect*/\nexport const LGPT3_IMCLR_TGT_NO_EFFECT: any = '0'\n\n\n// -------- REGISTER EMU -------- //\n\n/**\nDebug control\n\n\nThis register can be used to freeze the timer when CPU halts when HALT is set to 1. When HALT is set to 0, or when the CPU releases debug halt, the filters and edge detection logic is flushed and the timer starts. For setting a predefined output value during a CPU debug halt, PARK, if the timer has this register, should be configured additionally. If this timer does not have the PARK register a predefined output value during CPU halt is not possible.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_EMU_RESERVED2: any = '30'\nexport const LGPT3_EMU_RESERVED2_M: any = '30'\nexport const LGPT3_EMU_RESERVED2_S: any = '30'\n/**\nHalt control.\n\n\nConfigure when the counter shall stop upon CPU halt. This bitfield only applies if HALT = 1.*/\nexport const LGPT3_EMU_CTL: any = '1'\nexport const LGPT3_EMU_CTL_M: any = '1'\nexport const LGPT3_EMU_CTL_S: any = '1'\n/**\nZero condition. The counter stops when CNTR = 0.*/\nexport const LGPT3_EMU_CTL_ZERCOND: any = '1'\n\n/**\nImmediate reaction. The counter stops immediately on debug halt.*/\nexport const LGPT3_EMU_CTL_IMMEDIATE: any = '0'\n\n/**\nHalt LGPT when CPU is halted in debug.*/\nexport const LGPT3_EMU_HALT: any = '1'\nexport const LGPT3_EMU_HALT_M: any = '1'\nexport const LGPT3_EMU_HALT_S: any = '1'\n/**\nEnable.*/\nexport const LGPT3_EMU_HALT_EN: any = '1'\n\n/**\nDisable.*/\nexport const LGPT3_EMU_HALT_DIS: any = '0'\n\n\n// -------- REGISTER C0CFG -------- //\n\n/**\nChannel 0 Configuration\n\n\nThis register configures channel function and enables outputs.\n\nEach channel has an edge-detection circuit. The the edge-detection circuit is: \n - enabled while CCACT selects a capture function and CTL.MODE is different from DIS.\n - flushed while CCACT selects a capture function and CTL.MODE is changed from DIS to another mode.\n\nThe flush action uses two system clock periods. It prevents capture events caused by expired signal values stored in the edge-detection circuit.\n\nThe channel input signal enters the edge-detection circuit. False capture events can occur when:\n- the edge-detection circuit contains expired signal samples and the circuit is enabled without flush as described above.\n- the CCACT field is reconfigured while CTL.MODE is different from DIS.\n\nPrimary use scenario is to select CCACT before starting the timer. Follow these steps to configure CCACT to a capture action while CTL.MODE is different from DIS:\n- Set EDGE to NONE.\n- Configure CCACT.\n- Wait for three system clock periods before setting EDGE different from NONE.\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C0CFG_RESERVED11: any = '21'\nexport const LGPT3_C0CFG_RESERVED11_M: any = '21'\nexport const LGPT3_C0CFG_RESERVED11_S: any = '21'\n/**\nOutput 2 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT2 becomes zero after a capture or compare event.*/\nexport const LGPT3_C0CFG_OUT2: any = '1'\nexport const LGPT3_C0CFG_OUT2_M: any = '1'\nexport const LGPT3_C0CFG_OUT2_S: any = '1'\n/**\nChannel 0 controls output 2.*/\nexport const LGPT3_C0CFG_OUT2_EN: any = '1'\n\n/**\nChannel 0 does not control output 2.*/\nexport const LGPT3_C0CFG_OUT2_DIS: any = '0'\n\n/**\nOutput 1 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT1 becomes zero after a capture or compare event.*/\nexport const LGPT3_C0CFG_OUT1: any = '1'\nexport const LGPT3_C0CFG_OUT1_M: any = '1'\nexport const LGPT3_C0CFG_OUT1_S: any = '1'\n/**\nChannel 0 controls output 1.*/\nexport const LGPT3_C0CFG_OUT1_EN: any = '1'\n\n/**\nChannel 0 does not control output 1.*/\nexport const LGPT3_C0CFG_OUT1_DIS: any = '0'\n\n/**\nOutput 0 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT0 becomes zero after a capture or compare event.*/\nexport const LGPT3_C0CFG_OUT0: any = '1'\nexport const LGPT3_C0CFG_OUT0_M: any = '1'\nexport const LGPT3_C0CFG_OUT0_S: any = '1'\n/**\nChannel 0 controls output 0.*/\nexport const LGPT3_C0CFG_OUT0_EN: any = '1'\n\n/**\nChannel 0 does not control output 0.*/\nexport const LGPT3_C0CFG_OUT0_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C0CFG_RESERVED7: any = '1'\nexport const LGPT3_C0CFG_RESERVED7_M: any = '1'\nexport const LGPT3_C0CFG_RESERVED7_S: any = '1'\n/**\nSelect channel input.*/\nexport const LGPT3_C0CFG_INPUT: any = '1'\nexport const LGPT3_C0CFG_INPUT_M: any = '1'\nexport const LGPT3_C0CFG_INPUT_S: any = '1'\n/**\nIO controller*/\nexport const LGPT3_C0CFG_INPUT_IO: any = '1'\n\n/**\nEvent fabric*/\nexport const LGPT3_C0CFG_INPUT_EV: any = '0'\n\n/**\nDetermines the edge that triggers the channel input event. This happens post filter.*/\nexport const LGPT3_C0CFG_EDGE: any = '2'\nexport const LGPT3_C0CFG_EDGE_M: any = '2'\nexport const LGPT3_C0CFG_EDGE_S: any = '2'\n/**\nInput event is triggered at both edges.*/\nexport const LGPT3_C0CFG_EDGE_BOTH: any = '3'\n\n/**\nInput event is triggered at falling edge.*/\nexport const LGPT3_C0CFG_EDGE_FALL: any = '2'\n\n/**\nInput event is triggered at rising edge.*/\nexport const LGPT3_C0CFG_EDGE_RISE: any = '1'\n\n/**\nInput is turned off.*/\nexport const LGPT3_C0CFG_EDGE_NONE: any = '0'\n\n/**\nCapture-Compare action.\n\n\nCapture-Compare action defines 15 different channel functions that utilize capture, compare, and zero events. In every compare event the timer looks at the current value of CNTR. The corresponding output event will be set 1 timer period after CNTR = C0CC. */\nexport const LGPT3_C0CFG_CCACT: any = '4'\nexport const LGPT3_C0CFG_CCACT_M: any = '4'\nexport const LGPT3_C0CFG_CCACT_S: any = '4'\n/**\nPulse on compare repeatedly. \n\n\nChannel function sequence: \n- Pulse enabled outputs when C0CC.VAL = CNTR.VAL.\n\n The output is high for two timer clock periods.*/\nexport const LGPT3_C0CFG_CCACT_PULSE_ON_CMP: any = '15'\n\n/**\nToggle on compare repeatedly.\n\n\nChannel function sequence: \n- Toggle enabled outputs  when C0CC.VAL = CNTR.VAL.*/\nexport const LGPT3_C0CFG_CCACT_TGL_ON_CMP: any = '14'\n\n/**\nSet on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs  when C0CC.VAL = CNTR.VAL.*/\nexport const LGPT3_C0CFG_CCACT_SET_ON_CMP: any = '13'\n\n/**\nClear on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs  when C0CC.VAL = CNTR.VAL.*/\nexport const LGPT3_C0CFG_CCACT_CLR_ON_CMP: any = '12'\n\n/**\nSet on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C0CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UP_PER for edge-aligned PWM generation. Duty cycle is given by: \n\nWhen C0CC.VAL $lt;= TGT.VAL: \n   Duty cycle = C0CC.VAL / ( TGT.VAL + 1 ).\n\nWhen C0CC.VAL $gt; TGT.VAL: \n   Duty cycle = 1.\n\nEnabled outputs are cleared when C0CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C0CFG_CCACT_SET_ON_0_TGL_ON_CMP: any = '11'\n\n/**\nClear on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C0CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UPDWN_PER for center-aligned PWM generation. Duty cycle is given by: \n\nWhen C0CC.VAL $lt;= TGT.VAL: \n   Duty cycle = 1 - ( C0CC.VAL / TGT.VAL ).\n\nWhen C0CC.VAL $gt; TGT.VAL: \n   Duty cycle = 0.\n\nEnabled outputs are set when C0CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C0CFG_CCACT_CLR_ON_0_TGL_ON_CMP: any = '10'\n\n/**\nSet on capture repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C0CC.VAL.\n\n*/\nexport const LGPT3_C0CFG_CCACT_SET_ON_CAPT: any = '9'\n\n/**\nPeriod and pulse width measurement.\n\n\nContinuously capture period and pulse width of the signal selected by INPUT relative to the signal edge given by EDGE. \n\nSet enabled outputs and RIS.C0CC when C0CC.VAL contains signal period and PC0CC.VAL contains signal pulse width.\n\nNotes: \n- Make sure to configure INPUT and CCACT when CTL.MODE equals DIS, then set CTL.MODE to UP_ONCE or UP_PER. \n- The counter restarts in the selected timer mode when C0CC.VAL contains the signal period.\n- If more than one channel uses this function, the channels will perform this function one at a time. The channel with lowest number has priority and performs the function first. Next measurement starts when current measurement completes successfully or times out. A timeout occurs when counter equals target. \n- To observe a timeout event the RIS.TGT interrupt can be used, or another channel can be configured to SET_ON_CMP with compare value equal TGT.\n\nSignal property requirements:\n- Signal Period $gt;= 2 * ( 1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal Period $lt;= MAX(CNTR) * (1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal low and high phase $gt;= (1 + PRECFG.TICKDIV ) * timer clock period. */\nexport const LGPT3_C0CFG_CCACT_PER_PULSE_WIDTH_MEAS: any = '8'\n\n/**\nPulse on compare, and then disable channel.\n\n\nChannel function sequence: \n- Pulse enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.\n\n The output is high for two timer clock periods.*/\nexport const LGPT3_C0CFG_CCACT_PULSE_ON_CMP_DIS: any = '7'\n\n/**\nToggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Toggle enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT3_C0CFG_CCACT_TGL_ON_CMP_DIS: any = '6'\n\n/**\nSet on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT3_C0CFG_CCACT_SET_ON_CMP_DIS: any = '5'\n\n/**\nClear on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT3_C0CFG_CCACT_CLR_ON_CMP_DIS: any = '4'\n\n/**\nSet on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are cleared when C0CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C0CFG_CCACT_SET_ON_0_TGL_ON_CMP_DIS: any = '3'\n\n/**\nClear on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C0CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are set when C0CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C0CFG_CCACT_CLR_ON_0_TGL_ON_CMP_DIS: any = '2'\n\n/**\nSet on capture, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C0CC.VAL.\n- Disable channel. \n\nPrimary use scenario is to select this function before starting the timer.\nFollow these steps to select this function while CTL.MODE is different from DIS:  \n - Set CCACT to SET_ON_CAPT with no output enable.\n - Configure INPUT (optional).\n - Wait for three timer clock periods as defined in PRECFG before setting CCACT to SET_ON_CAPT_DIS. Output enable is optional.\n\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\nexport const LGPT3_C0CFG_CCACT_SET_ON_CAPT_DIS: any = '1'\n\n/**\nDisable channel.*/\nexport const LGPT3_C0CFG_CCACT_DIS: any = '0'\n\n\n// -------- REGISTER C1CFG -------- //\n\n/**\nChannel 1 Configuration\n\n\nThis register configures channel function and enables outputs.\n\nEach channel has an edge-detection circuit. The the edge-detection circuit is: \n - enabled while CCACT selects a capture function and CTL.MODE is different from DIS.\n - flushed while CCACT selects a capture function and CTL.MODE is changed from DIS to another mode.\n\nThe flush action uses two system clock periods. It prevents capture events caused by expired signal values stored in the edge-detection circuit.\n\nThe channel input signal enters the edge-detection circuit. False capture events can occur when:\n- the edge-detection circuit contains expired signal samples and the circuit is enabled without flush as described above.\n- the CCACT field is reconfigured while CTL.MODE is different from DIS.\n\nPrimary use scenario is to select CCACT before starting the timer. Follow these steps to configure CCACT to a capture action while CTL.MODE is different from DIS:\n- Set EDGE to NONE.\n- Configure CCACT.\n- Wait for three system clock periods before setting EDGE different from NONE.\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C1CFG_RESERVED11: any = '21'\nexport const LGPT3_C1CFG_RESERVED11_M: any = '21'\nexport const LGPT3_C1CFG_RESERVED11_S: any = '21'\n/**\nOutput 2 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT2 becomes zero after a capture or compare event.*/\nexport const LGPT3_C1CFG_OUT2: any = '1'\nexport const LGPT3_C1CFG_OUT2_M: any = '1'\nexport const LGPT3_C1CFG_OUT2_S: any = '1'\n/**\nChannel 1 controls output 2.*/\nexport const LGPT3_C1CFG_OUT2_EN: any = '1'\n\n/**\nChannel 1 does not control output 2.*/\nexport const LGPT3_C1CFG_OUT2_DIS: any = '0'\n\n/**\nOutput 1 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT1 becomes zero after a capture or compare event.*/\nexport const LGPT3_C1CFG_OUT1: any = '1'\nexport const LGPT3_C1CFG_OUT1_M: any = '1'\nexport const LGPT3_C1CFG_OUT1_S: any = '1'\n/**\nChannel 1 controls output 1.*/\nexport const LGPT3_C1CFG_OUT1_EN: any = '1'\n\n/**\nChannel 1 does not control output 1.*/\nexport const LGPT3_C1CFG_OUT1_DIS: any = '0'\n\n/**\nOutput 0 enable.\n\nWhen 0 $lt; CCACT $lt; 8, OUT0 becomes zero after a capture or compare event.\n*/\nexport const LGPT3_C1CFG_OUT0: any = '1'\nexport const LGPT3_C1CFG_OUT0_M: any = '1'\nexport const LGPT3_C1CFG_OUT0_S: any = '1'\n/**\nChannel 1 controls output 0.*/\nexport const LGPT3_C1CFG_OUT0_EN: any = '1'\n\n/**\nChannel 1 does not control output 0.*/\nexport const LGPT3_C1CFG_OUT0_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C1CFG_RESERVED7: any = '1'\nexport const LGPT3_C1CFG_RESERVED7_M: any = '1'\nexport const LGPT3_C1CFG_RESERVED7_S: any = '1'\n/**\nSelect channel input.*/\nexport const LGPT3_C1CFG_INPUT: any = '1'\nexport const LGPT3_C1CFG_INPUT_M: any = '1'\nexport const LGPT3_C1CFG_INPUT_S: any = '1'\n/**\nIO controller*/\nexport const LGPT3_C1CFG_INPUT_IO: any = '1'\n\n/**\nEvent fabric*/\nexport const LGPT3_C1CFG_INPUT_EV: any = '0'\n\n/**\nDetermines the edge that triggers the channel input event. This happens post filter.*/\nexport const LGPT3_C1CFG_EDGE: any = '2'\nexport const LGPT3_C1CFG_EDGE_M: any = '2'\nexport const LGPT3_C1CFG_EDGE_S: any = '2'\n/**\nInput event is triggered at both edges.*/\nexport const LGPT3_C1CFG_EDGE_BOTH: any = '3'\n\n/**\nInput event is triggered at falling edge.*/\nexport const LGPT3_C1CFG_EDGE_FALL: any = '2'\n\n/**\nInput event is triggered at rising edge.*/\nexport const LGPT3_C1CFG_EDGE_RISE: any = '1'\n\n/**\nInput is turned off.*/\nexport const LGPT3_C1CFG_EDGE_NONE: any = '0'\n\n/**\nCapture-Compare action.\n\n\nCapture-Compare action defines 15 different channel functions that utilize capture, compare, and zero events. In every compare event the timer looks at the current value of CNTR. The corresponding output event will be set 1 timer period after CNTR = C1CC. */\nexport const LGPT3_C1CFG_CCACT: any = '4'\nexport const LGPT3_C1CFG_CCACT_M: any = '4'\nexport const LGPT3_C1CFG_CCACT_S: any = '4'\n/**\nPulse on compare repeatedly. \n\n\nChannel function sequence: \n- Pulse enabled outputs when C1CC.VAL = CNTR.VAL.\n\n The output is high for two timer clock periods.*/\nexport const LGPT3_C1CFG_CCACT_PULSE_ON_CMP: any = '15'\n\n/**\nToggle on compare repeatedly.\n\n\nChannel function sequence: \n- Toggle enabled outputs  when C1CC.VAL = CNTR.VAL.*/\nexport const LGPT3_C1CFG_CCACT_TGL_ON_CMP: any = '14'\n\n/**\nSet on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs  when C1CC.VAL = CNTR.VAL.*/\nexport const LGPT3_C1CFG_CCACT_SET_ON_CMP: any = '13'\n\n/**\nClear on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs  when C1CC.VAL = CNTR.VAL.*/\nexport const LGPT3_C1CFG_CCACT_CLR_ON_CMP: any = '12'\n\n/**\nSet on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C1CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UP_PER for edge-aligned PWM generation. Duty cycle is given by: \n\nWhen C1CC.VAL $lt;= TGT.VAL: \n   Duty cycle = C1CC.VAL / ( TGT.VAL + 1 ).\n\nWhen C1CC.VAL $gt; TGT.VAL: \n   Duty cycle = 1.\n\nEnabled outputs are cleared when C1CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C1CFG_CCACT_SET_ON_0_TGL_ON_CMP: any = '11'\n\n/**\nClear on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C1CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UPDWN_PER for center-aligned PWM generation. Duty cycle is given by: \n\nWhen C1CC.VAL $lt;= TGT.VAL: \n   Duty cycle = 1 - ( C1CC.VAL / TGT.VAL ).\n\nWhen C1CC.VAL $gt; TGT.VAL: \n   Duty cycle = 0.\n\nEnabled outputs are set when C1CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C1CFG_CCACT_CLR_ON_0_TGL_ON_CMP: any = '10'\n\n/**\nSet on capture repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C1CC.VAL.\n\n*/\nexport const LGPT3_C1CFG_CCACT_SET_ON_CAPT: any = '9'\n\n/**\nPeriod and pulse width measurement.\n\n\nContinuously capture period and pulse width of the signal selected by INPUT relative to the signal edge given by EDGE. \n\nSet enabled outputs and RIS.C1CC when C1CC.VAL contains signal period and PC1CC.VAL contains signal pulse width. \n\nNotes: \n- Make sure to configure INPUT and CCACT when CTL.MODE equals DIS, then set CTL.MODE to UP_ONCE or UP_PER. \n- The counter restarts in the selected timer mode when C1CC.VAL contains the signal period.\n- If more than one channel uses this function, the channels will perform this function one at a time. The channel with lowest number has priority and performs the function first. Next measurement starts when current measurement completes successfully or times out. A timeout occurs when counter equals target. \n- To observe a timeout event the RIS.TGT interrupt can be used, or another channel can be configured to SET_ON_CMP with compare value equal TGT.\n\nSignal property requirements:\n- Signal Period $gt;= 2 * ( 1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal Period $lt;= MAX(CNTR) * (1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal low and high phase $gt;= (1 + PRECFG.TICKDIV ) * timer clock period.*/\nexport const LGPT3_C1CFG_CCACT_PER_PULSE_WIDTH_MEAS: any = '8'\n\n/**\nPulse on compare, and then disable channel.\n\n\nChannel function sequence: \n- Pulse enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.\n\n The output is high for two timer clock periods.*/\nexport const LGPT3_C1CFG_CCACT_PULSE_ON_CMP_DIS: any = '7'\n\n/**\nToggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Toggle enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT3_C1CFG_CCACT_TGL_ON_CMP_DIS: any = '6'\n\n/**\nSet on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT3_C1CFG_CCACT_SET_ON_CMP_DIS: any = '5'\n\n/**\nClear on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT3_C1CFG_CCACT_CLR_ON_CMP_DIS: any = '4'\n\n/**\nSet on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are cleared when C1CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C1CFG_CCACT_SET_ON_0_TGL_ON_CMP_DIS: any = '3'\n\n/**\nClear on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C1CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are set when C1CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C1CFG_CCACT_CLR_ON_0_TGL_ON_CMP_DIS: any = '2'\n\n/**\nSet on capture, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C1CC.VAL.\n- Disable channel. \n\nPrimary use scenario is to select this function before starting the timer.\nFollow these steps to select this function while CTL.MODE is different from DIS:  \n - Set CCACT to SET_ON_CAPT with no output enable.\n - Configure INPUT (optional).\n - Wait for three timer clock periods as defined in PRECFG before setting CCACT to SET_ON_CAPT_DIS. Output enable is optional.\n\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\nexport const LGPT3_C1CFG_CCACT_SET_ON_CAPT_DIS: any = '1'\n\n/**\nDisable channel.*/\nexport const LGPT3_C1CFG_CCACT_DIS: any = '0'\n\n\n// -------- REGISTER C2CFG -------- //\n\n/**\nChannel 2 Configuration\n\n\nThis register configures channel function and enables outputs.\n\nEach channel has an edge-detection circuit. The the edge-detection circuit is: \n - enabled while CCACT selects a capture function and CTL.MODE is different from DIS.\n - flushed while CCACT selects a capture function and CTL.MODE is changed from DIS to another mode.\n\nThe flush action uses two system clock periods. It prevents capture events caused by expired signal values stored in the edge-detection circuit.\n\nThe channel input signal enters the edge-detection circuit. False capture events can occur when:\n- the edge-detection circuit contains expired signal samples and the circuit is enabled without flush as described above.\n- the CCACT field is reconfigured while CTL.MODE is different from DIS.\n\nPrimary use scenario is to select CCACT before starting the timer. Follow these steps to configure CCACT to a capture action while CTL.MODE is different from DIS:\n- Set EDGE to NONE.\n- Configure CCACT.\n- Wait for three system clock periods before setting EDGE different from NONE.\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C2CFG_RESERVED11: any = '21'\nexport const LGPT3_C2CFG_RESERVED11_M: any = '21'\nexport const LGPT3_C2CFG_RESERVED11_S: any = '21'\n/**\nOutput 2 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT2 becomes zero after a capture or compare event.*/\nexport const LGPT3_C2CFG_OUT2: any = '1'\nexport const LGPT3_C2CFG_OUT2_M: any = '1'\nexport const LGPT3_C2CFG_OUT2_S: any = '1'\n/**\nChannel 2 controls output 2.*/\nexport const LGPT3_C2CFG_OUT2_EN: any = '1'\n\n/**\nChannel 2 does not control output 2.*/\nexport const LGPT3_C2CFG_OUT2_DIS: any = '0'\n\n/**\nOutput 1 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT1 becomes zero after a capture or compare event.*/\nexport const LGPT3_C2CFG_OUT1: any = '1'\nexport const LGPT3_C2CFG_OUT1_M: any = '1'\nexport const LGPT3_C2CFG_OUT1_S: any = '1'\n/**\nChannel 2 controls output 1.*/\nexport const LGPT3_C2CFG_OUT1_EN: any = '1'\n\n/**\nChannel 2 does not control output 1.*/\nexport const LGPT3_C2CFG_OUT1_DIS: any = '0'\n\n/**\nOutput 0 enable.\n\n\nWhen 0 $lt; CCACT $lt; 8, OUT0 becomes zero after a capture or compare event.*/\nexport const LGPT3_C2CFG_OUT0: any = '1'\nexport const LGPT3_C2CFG_OUT0_M: any = '1'\nexport const LGPT3_C2CFG_OUT0_S: any = '1'\n/**\nChannel 2 controls output 0.*/\nexport const LGPT3_C2CFG_OUT0_EN: any = '1'\n\n/**\nChannel 2 does not control output 0.*/\nexport const LGPT3_C2CFG_OUT0_DIS: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C2CFG_RESERVED7: any = '1'\nexport const LGPT3_C2CFG_RESERVED7_M: any = '1'\nexport const LGPT3_C2CFG_RESERVED7_S: any = '1'\n/**\nSelect channel input.*/\nexport const LGPT3_C2CFG_INPUT: any = '1'\nexport const LGPT3_C2CFG_INPUT_M: any = '1'\nexport const LGPT3_C2CFG_INPUT_S: any = '1'\n/**\nIO controller*/\nexport const LGPT3_C2CFG_INPUT_IO: any = '1'\n\n/**\nEvent fabric*/\nexport const LGPT3_C2CFG_INPUT_EV: any = '0'\n\n/**\nDetermines the edge that triggers the channel input event. This happens post filter.*/\nexport const LGPT3_C2CFG_EDGE: any = '2'\nexport const LGPT3_C2CFG_EDGE_M: any = '2'\nexport const LGPT3_C2CFG_EDGE_S: any = '2'\n/**\nInput event is triggered at both edges.*/\nexport const LGPT3_C2CFG_EDGE_BOTH: any = '3'\n\n/**\nInput event is triggered at falling edge.*/\nexport const LGPT3_C2CFG_EDGE_FALL: any = '2'\n\n/**\nInput event is triggered at rising edge.*/\nexport const LGPT3_C2CFG_EDGE_RISE: any = '1'\n\n/**\nInput is turned off.*/\nexport const LGPT3_C2CFG_EDGE_NONE: any = '0'\n\n/**\nCapture-Compare action.\n\n\nCapture-Compare action defines 15 different channel functions that utilize capture, compare, and zero events. In every compare event the timer looks at the current value of CNTR. The corresponding output event will be set 1 timer period after CNTR = C2CC. */\nexport const LGPT3_C2CFG_CCACT: any = '4'\nexport const LGPT3_C2CFG_CCACT_M: any = '4'\nexport const LGPT3_C2CFG_CCACT_S: any = '4'\n/**\nPulse on compare repeatedly. \n\n\nChannel function sequence: \n- Pulse enabled outputs when C2CC.VAL = CNTR.VAL.\n\n The output is high for two timer clock periods.*/\nexport const LGPT3_C2CFG_CCACT_PULSE_ON_CMP: any = '15'\n\n/**\nToggle on compare repeatedly.\n\n\nChannel function sequence: \n- Toggle enabled outputs  when C2CC.VAL = CNTR.VAL.*/\nexport const LGPT3_C2CFG_CCACT_TGL_ON_CMP: any = '14'\n\n/**\nSet on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs  when C2CC.VAL = CNTR.VAL.*/\nexport const LGPT3_C2CFG_CCACT_SET_ON_CMP: any = '13'\n\n/**\nClear on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs  when C2CC.VAL = CNTR.VAL.*/\nexport const LGPT3_C2CFG_CCACT_CLR_ON_CMP: any = '12'\n\n/**\nSet on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C2CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UP_PER for edge-aligned PWM generation. Duty cycle is given by: \n\nWhen C2CC.VAL $lt;= TGT.VAL: \n   Duty cycle = C2CC.VAL / ( TGT.VAL + 1 ).\n\nWhen C2CC.VAL $gt; TGT.VAL: \n   Duty cycle = 1.\n\nEnabled outputs are cleared when C2CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C2CFG_CCACT_SET_ON_0_TGL_ON_CMP: any = '11'\n\n/**\nClear on zero, toggle on compare repeatedly.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C2CC.VAL = CNTR.VAL.\n\nSet CTL.MODE to UPDWN_PER for center-aligned PWM generation. Duty cycle is given by: \n\nWhen C2CC.VAL $lt;= TGT.VAL: \n   Duty cycle = 1 - ( C2CC.VAL / TGT.VAL ).\n\nWhen C2CC.VAL $gt; TGT.VAL: \n   Duty cycle = 0.\n\nEnabled outputs are set when C2CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C2CFG_CCACT_CLR_ON_0_TGL_ON_CMP: any = '10'\n\n/**\nSet on capture repeatedly.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C2CC.VAL.\n\n*/\nexport const LGPT3_C2CFG_CCACT_SET_ON_CAPT: any = '9'\n\n/**\nPeriod and pulse width measurement.\n\n\nContinuously capture period and pulse width of the signal selected by INPUT relative to the signal edge given by EDGE. \n\nSet enabled outputs and RIS.C2CC when C2CC.VAL contains signal period and PC2CC.VAL contains signal pulse width. \n\nNotes: \n- Make sure to configure INPUT and CCACT when CTL.MODE equals DIS, then set CTL.MODE to UP_ONCE or UP_PER. \n- The counter restarts in the selected timer mode when C2CC.VAL contains the signal period.\n- If more than one channel uses this function, the channels will perform this function one at a time. The channel with lowest number has priority and performs the function first. Next measurement starts when current measurement completes successfully or times out. A timeout occurs when counter equals target. \n- To observe a timeout event the RIS.TGT interrupt can be used, or another channel can be configured to SET_ON_CMP with compare value equal TGT.\n\nSignal property requirements:\n- Signal Period $gt;= 2 * ( 1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal Period $lt;= MAX(CNTR) * (1 + PRECFG.TICKDIV ) * timer clock period.\n- Signal low and high phase $gt;= (1 + PRECFG.TICKDIV ) * timer clock period. */\nexport const LGPT3_C2CFG_CCACT_PER_PULSE_WIDTH_MEAS: any = '8'\n\n/**\nPulse on compare, and then disable channel.\n\n\nChannel function sequence: \n- Pulse enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.\n\n The output is high for two timer clock periods.*/\nexport const LGPT3_C2CFG_CCACT_PULSE_ON_CMP_DIS: any = '7'\n\n/**\nToggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Toggle enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT3_C2CFG_CCACT_TGL_ON_CMP_DIS: any = '6'\n\n/**\nSet on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT3_C2CFG_CCACT_SET_ON_CMP_DIS: any = '5'\n\n/**\nClear on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.*/\nexport const LGPT3_C2CFG_CCACT_CLR_ON_CMP_DIS: any = '4'\n\n/**\nSet on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are cleared when C2CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C2CFG_CCACT_SET_ON_0_TGL_ON_CMP_DIS: any = '3'\n\n/**\nClear on zero, toggle on compare, and then disable channel.\n\n\nChannel function sequence: \n- Clear enabled outputs when CNTR.VAL = 0.\n- Toggle enabled outputs when C2CC.VAL = CNTR.VAL.\n- Disable channel.\n\nEnabled outputs are set when C2CC.VAL = 0 and CNTR.VAL = 0.*/\nexport const LGPT3_C2CFG_CCACT_CLR_ON_0_TGL_ON_CMP_DIS: any = '2'\n\n/**\nSet on capture, and then disable channel.\n\n\nChannel function sequence: \n- Set enabled outputs on capture event and copy CNTR.VAL to C2CC.VAL.\n- Disable channel. \n\nPrimary use scenario is to select this function before starting the timer.\nFollow these steps to select this function while CTL.MODE is different from DIS:  \n - Set CCACT to SET_ON_CAPT with no output enable.\n - Configure INPUT (optional).\n - Wait for three timer clock periods as defined in PRECFG before setting CCACT to SET_ON_CAPT_DIS. Output enable is optional.\n\nThese steps prevent capture events caused by expired signal values in edge-detection circuit.*/\nexport const LGPT3_C2CFG_CCACT_SET_ON_CAPT_DIS: any = '1'\n\n/**\nDisable channel.*/\nexport const LGPT3_C2CFG_CCACT_DIS: any = '0'\n\n\n// -------- REGISTER PTGT -------- //\n\n/**\nPipeline Target\n\nA read or write to this register will clear the RIS.ZERO and RIS.TGT interrupt.\n\n\nIf CTL.MODE != QDEC.\nTarget value for next counter period.\nThe timer will copy PTGT.VAL to TGT.VAL on the upcoming CNTR zero crossing only if PTGT.VAL has been written. The copy does not happen when restarting the timer.\nThis is useful to avoid period jitter in PWM applications with time-varying period, sometimes referenced as phase corrected PWM.\n\nIf CTL.MODE = QDEC\nThe CNTR value is updated with VALUE on IDX if the counter is counting down. If the counter is counting up, CNTR is loaded with zero on IDX.\nIn this mode the VALUE is not loaded into TGT on zero crossing.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PTGT_RESERVED24: any = '8'\nexport const LGPT3_PTGT_RESERVED24_M: any = '8'\nexport const LGPT3_PTGT_RESERVED24_S: any = '8'\n/**\nThe pipleline target value.*/\nexport const LGPT3_PTGT_VAL: any = '24'\nexport const LGPT3_PTGT_VAL_M: any = '24'\nexport const LGPT3_PTGT_VAL_S: any = '24'\n\n// -------- REGISTER PC0CC -------- //\n\n/**\nPipeline Channel 0 Capture Compare */\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PC0CC_RESERVED24: any = '8'\nexport const LGPT3_PC0CC_RESERVED24_M: any = '8'\nexport const LGPT3_PC0CC_RESERVED24_S: any = '8'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C0CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C0CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C0CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C0CFG.EDGE.*/\nexport const LGPT3_PC0CC_VAL: any = '24'\nexport const LGPT3_PC0CC_VAL_M: any = '24'\nexport const LGPT3_PC0CC_VAL_S: any = '24'\n\n// -------- REGISTER PC1CC -------- //\n\n/**\nPipeline Channel 1 Capture Compare */\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PC1CC_RESERVED24: any = '8'\nexport const LGPT3_PC1CC_RESERVED24_M: any = '8'\nexport const LGPT3_PC1CC_RESERVED24_S: any = '8'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C1CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C1CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C1CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C1CFG.EDGE.*/\nexport const LGPT3_PC1CC_VAL: any = '24'\nexport const LGPT3_PC1CC_VAL_M: any = '24'\nexport const LGPT3_PC1CC_VAL_S: any = '24'\n\n// -------- REGISTER PC2CC -------- //\n\n/**\nPipeline Channel 2 Capture Compare */\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PC2CC_RESERVED24: any = '8'\nexport const LGPT3_PC2CC_RESERVED24_M: any = '8'\nexport const LGPT3_PC2CC_RESERVED24_S: any = '8'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C2CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C2CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C2CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C2CFG.EDGE.*/\nexport const LGPT3_PC2CC_VAL: any = '24'\nexport const LGPT3_PC2CC_VAL_M: any = '24'\nexport const LGPT3_PC2CC_VAL_S: any = '24'\n\n// -------- REGISTER TGT -------- //\n\n/**\nTarget\n\n\nUser defined counter target. \nA read or write to this register will clear the RIS.ZERO and RIS.TGT interrupt.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_TGT_RESERVED24: any = '8'\nexport const LGPT3_TGT_RESERVED24_M: any = '8'\nexport const LGPT3_TGT_RESERVED24_S: any = '8'\n/**\nUser defined counter target value.*/\nexport const LGPT3_TGT_VAL: any = '24'\nexport const LGPT3_TGT_VAL_M: any = '24'\nexport const LGPT3_TGT_VAL_S: any = '24'\n\n// -------- REGISTER C0CC -------- //\n\n/**\nChannel 0 Capture Compare*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C0CC_RESERVED24: any = '8'\nexport const LGPT3_C0CC_RESERVED24_M: any = '8'\nexport const LGPT3_C0CC_RESERVED24_S: any = '8'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C0CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C0CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C0CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT3_C0CC_VAL: any = '24'\nexport const LGPT3_C0CC_VAL_M: any = '24'\nexport const LGPT3_C0CC_VAL_S: any = '24'\n\n// -------- REGISTER C1CC -------- //\n\n/**\nChannel 1 Capture Compare*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C1CC_RESERVED24: any = '8'\nexport const LGPT3_C1CC_RESERVED24_M: any = '8'\nexport const LGPT3_C1CC_RESERVED24_S: any = '8'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C1CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C1CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C1CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT3_C1CC_VAL: any = '24'\nexport const LGPT3_C1CC_VAL_M: any = '24'\nexport const LGPT3_C1CC_VAL_S: any = '24'\n\n// -------- REGISTER C2CC -------- //\n\n/**\nChannel 2 Capture Compare*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C2CC_RESERVED24: any = '8'\nexport const LGPT3_C2CC_RESERVED24_M: any = '8'\nexport const LGPT3_C2CC_RESERVED24_S: any = '8'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will clear the RIS.C2CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C2CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C2CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT3_C2CC_VAL: any = '24'\nexport const LGPT3_C2CC_VAL_M: any = '24'\nexport const LGPT3_C2CC_VAL_S: any = '24'\n\n// -------- REGISTER PTGTNC -------- //\n\n/**\nPipeline Target No Clear\n\n\nUse this register to read or write to PTGT without clearing the RIS.ZERO and RIS.TGT interrupt.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PTGTNC_RESERVED24: any = '8'\nexport const LGPT3_PTGTNC_RESERVED24_M: any = '8'\nexport const LGPT3_PTGTNC_RESERVED24_S: any = '8'\n/**\nA read or write to this register will not clear the RIS.TGT interrupt.\n\n\nIf CTL.MODE != QDEC.\nTarget value for next counter period.\nThe timer copies VAL to TGT.VAL when CNTR.VAL becomes 0. The copy does not happen when restarting the timer.\nThis is useful to avoid period jitter in PWM applications with time-varying period, sometimes referenced as phase corrected PWM.\n\nIf CTL.MODE = QDEC.\nThe CNTR.VAL is updated with VAL on IDX. VAL is not loaded into TGT.VAL when CNTR.VAL becomes 0. */\nexport const LGPT3_PTGTNC_VAL: any = '24'\nexport const LGPT3_PTGTNC_VAL_M: any = '24'\nexport const LGPT3_PTGTNC_VAL_S: any = '24'\n\n// -------- REGISTER PC0CCNC -------- //\n\n/**\nPipeline Channel 0 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PC0CCNC_RESERVED24: any = '8'\nexport const LGPT3_PC0CCNC_RESERVED24_M: any = '8'\nexport const LGPT3_PC0CCNC_RESERVED24_S: any = '8'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C0CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C0CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C0CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C0CFG.EDGE.*/\nexport const LGPT3_PC0CCNC_VAL: any = '24'\nexport const LGPT3_PC0CCNC_VAL_M: any = '24'\nexport const LGPT3_PC0CCNC_VAL_S: any = '24'\n\n// -------- REGISTER PC1CCNC -------- //\n\n/**\nPipeline Channel 1 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PC1CCNC_RESERVED24: any = '8'\nexport const LGPT3_PC1CCNC_RESERVED24_M: any = '8'\nexport const LGPT3_PC1CCNC_RESERVED24_S: any = '8'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C1CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C1CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C1CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C1CFG.EDGE.*/\nexport const LGPT3_PC1CCNC_VAL: any = '24'\nexport const LGPT3_PC1CCNC_VAL_M: any = '24'\nexport const LGPT3_PC1CCNC_VAL_S: any = '24'\n\n// -------- REGISTER PC2CCNC -------- //\n\n/**\nPipeline Channel 2 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_PC2CCNC_RESERVED24: any = '8'\nexport const LGPT3_PC2CCNC_RESERVED24_M: any = '8'\nexport const LGPT3_PC2CCNC_RESERVED24_S: any = '8'\n/**\nPipeline Capture Compare value.\n\n\nUser defined pipeline compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C2CC interrupt.\n\nCompare mode: \nAn update of VAL will be transferred to C2CC.VAL when the next CNTR.VAL is zero and CTL.MODE is different from DIS. This is useful for PWM generation and prevents jitter on the edges of the generated signal.\n\nCapture mode: \nWhen C2CFG.CCACT equals PER_PULSE_WIDTH_MEAS then VAL contains the width of the low or high phase of the selected signal. This is specified by C2CFG.EDGE.*/\nexport const LGPT3_PC2CCNC_VAL: any = '24'\nexport const LGPT3_PC2CCNC_VAL_M: any = '24'\nexport const LGPT3_PC2CCNC_VAL_S: any = '24'\n\n// -------- REGISTER TGTNC -------- //\n\n/**\nTarget No Clear\n\n\nUse this register to read or write to TGT without clearing the RIS.ZERO and RIS.TGT interrupt.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_TGTNC_RESERVED24: any = '8'\nexport const LGPT3_TGTNC_RESERVED24_M: any = '8'\nexport const LGPT3_TGTNC_RESERVED24_S: any = '8'\n/**\nUser defined counter target value.*/\nexport const LGPT3_TGTNC_VAL: any = '24'\nexport const LGPT3_TGTNC_VAL_M: any = '24'\nexport const LGPT3_TGTNC_VAL_S: any = '24'\n\n// -------- REGISTER C0CCNC -------- //\n\n/**\nChannel 0 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C0CCNC_RESERVED24: any = '8'\nexport const LGPT3_C0CCNC_RESERVED24_M: any = '8'\nexport const LGPT3_C0CCNC_RESERVED24_S: any = '8'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C0CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C0CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C0CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT3_C0CCNC_VAL: any = '24'\nexport const LGPT3_C0CCNC_VAL_M: any = '24'\nexport const LGPT3_C0CCNC_VAL_S: any = '24'\n\n// -------- REGISTER C1CCNC -------- //\n\n/**\nChannel 1 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C1CCNC_RESERVED24: any = '8'\nexport const LGPT3_C1CCNC_RESERVED24_M: any = '8'\nexport const LGPT3_C1CCNC_RESERVED24_S: any = '8'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C1CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C1CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C1CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT3_C1CCNC_VAL: any = '24'\nexport const LGPT3_C1CCNC_VAL_M: any = '24'\nexport const LGPT3_C1CCNC_VAL_S: any = '24'\n\n// -------- REGISTER C2CCNC -------- //\n\n/**\nChannel 2 Capture Compare No Clear*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const LGPT3_C2CCNC_RESERVED24: any = '8'\nexport const LGPT3_C2CCNC_RESERVED24_M: any = '8'\nexport const LGPT3_C2CCNC_RESERVED24_S: any = '8'\n/**\nCapture Compare value.\n\n\nUser defined compare value or channel-updated capture value.\n\nA read or write to this register will not clear the RIS.C2CC interrupt.\n\nCompare mode: \nVAL is compared against CNTR.VAL and an event is generated as specified by C2CFG.CCACT when these are equal. \n\nCapture mode: \nThe current counter value is stored in VAL when a capture event occurs. C2CFG.CCACT determines if VAL is a signal period or a regular capture value.*/\nexport const LGPT3_C2CCNC_VAL: any = '24'\nexport const LGPT3_C2CCNC_VAL_M: any = '24'\nexport const LGPT3_C2CCNC_VAL_S: any = '24'\n\n// -------- MODULE PMCTL -------- //\n\nexport interface PMCTL_t {\n    DESC: em.$Reg\n    DESCEX: em.$Reg\n    SHTDWN: em.$Reg\n    SLPCTL: em.$Reg\n    WUSTA: em.$Reg\n    VDDRCTL: em.$Reg\n    SYSFSET: em.$Reg\n    SYSFCLR: em.$Reg\n    SYSFSTA: em.$Reg\n    RSTCTL: em.$Reg\n    RSTSTA: em.$Reg\n    BOOTSTA: em.$Reg\n    AONRSTA1: em.$Reg\n    AONRSET1: em.$Reg\n    AONRCLR1: em.$Reg\n    ETPP: em.$Reg\n    RETCFG0: em.$Reg\n    RETCFG1: em.$Reg\n    RETCFG2: em.$Reg\n    RETCFG3: em.$Reg\n    RETCFG4: em.$Reg\n    RETCFG5: em.$Reg\n    RETCFG6: em.$Reg\n    RETCFG7: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription Register. \n\nThis register provides IP module ID, revision information, instance index and standard MMR registers offset.*/\n/**\nModule identifier used to uniquely identify this IP.*/\nexport const PMCTL_DESC_MODID: any = '16'\nexport const PMCTL_DESC_MODID_M: any = '16'\nexport const PMCTL_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set of from aggregated IRQ registers till DTB.\n\n\n0: Standard IP MMRs do not exist\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)*/\nexport const PMCTL_DESC_STDIPOFF: any = '4'\nexport const PMCTL_DESC_STDIPOFF_M: any = '4'\nexport const PMCTL_DESC_STDIPOFF_S: any = '4'\n/**\nIP Instance ID number. If multiple instances of IP exist in the device, this field can identify the instance number (0-15).*/\nexport const PMCTL_DESC_INSTIDX: any = '4'\nexport const PMCTL_DESC_INSTIDX_M: any = '4'\nexport const PMCTL_DESC_INSTIDX_S: any = '4'\n/**\nMajor revision of IP (0-15).*/\nexport const PMCTL_DESC_MAJREV: any = '4'\nexport const PMCTL_DESC_MAJREV_M: any = '4'\nexport const PMCTL_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP (0-15).*/\nexport const PMCTL_DESC_MINREV: any = '4'\nexport const PMCTL_DESC_MINREV_M: any = '4'\nexport const PMCTL_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER DESCEX -------- //\n\n/**\nExtended Description Register.\n\nThis register shows ULL IP availability and memory size configuration.*/\n/**\nSystem flash availability*/\nexport const PMCTL_DESCEX_FLASHSZ: any = '2'\nexport const PMCTL_DESCEX_FLASHSZ_M: any = '2'\nexport const PMCTL_DESCEX_FLASHSZ_S: any = '2'\n/**\nFlash size set to level 3 (Max size)*/\nexport const PMCTL_DESCEX_FLASHSZ_SZ3: any = '3'\n\n/**\nFlash size set to level 2*/\nexport const PMCTL_DESCEX_FLASHSZ_SZ2: any = '2'\n\n/**\nFlash size set to level 1*/\nexport const PMCTL_DESCEX_FLASHSZ_SZ1: any = '1'\n\n/**\nFlash size set to level 0 (Min size)*/\nexport const PMCTL_DESCEX_FLASHSZ_SZ0: any = '0'\n\n/**\nSystem SRAM availability*/\nexport const PMCTL_DESCEX_SRAMSZ: any = '2'\nexport const PMCTL_DESCEX_SRAMSZ_M: any = '2'\nexport const PMCTL_DESCEX_SRAMSZ_S: any = '2'\n/**\nSRAM size set to level 3 (Max size)*/\nexport const PMCTL_DESCEX_SRAMSZ_SZ3: any = '3'\n\n/**\nSRAM size set to level 2*/\nexport const PMCTL_DESCEX_SRAMSZ_SZ2: any = '2'\n\n/**\nSRAM size set to level 1*/\nexport const PMCTL_DESCEX_SRAMSZ_SZ1: any = '1'\n\n/**\nSRAM size set to level 0 (Min size)*/\nexport const PMCTL_DESCEX_SRAMSZ_SZ0: any = '0'\n\n/**\n TSD (thermal shutdown) IP status on device*/\nexport const PMCTL_DESCEX_TSD: any = '1'\nexport const PMCTL_DESCEX_TSD_M: any = '1'\nexport const PMCTL_DESCEX_TSD_S: any = '1'\n/**\nIP is available*/\nexport const PMCTL_DESCEX_TSD_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const PMCTL_DESCEX_TSD_IP_UNAVAIL: any = '0'\n\n/**\nLPCMP (low power comparator) IP status on device*/\nexport const PMCTL_DESCEX_LPCMP: any = '1'\nexport const PMCTL_DESCEX_LPCMP_M: any = '1'\nexport const PMCTL_DESCEX_LPCMP_S: any = '1'\n/**\nIP is available*/\nexport const PMCTL_DESCEX_LPCMP_IP_AVAIL: any = '1'\n\n/**\nIP is unavailable*/\nexport const PMCTL_DESCEX_LPCMP_IP_UNAVAIL: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_DESCEX_RESERVED0: any = '26'\nexport const PMCTL_DESCEX_RESERVED0_M: any = '26'\nexport const PMCTL_DESCEX_RESERVED0_S: any = '26'\n\n// -------- REGISTER SHTDWN -------- //\n\n/**\nShutdown Register.\n\nThis register controls SHUTDOWN mode entry.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_SHTDWN_RESERVED16: any = '16'\nexport const PMCTL_SHTDWN_RESERVED16_M: any = '16'\nexport const PMCTL_SHTDWN_RESERVED16_S: any = '16'\n/**\nSetting a valid key will trigger the device to enter SHUTDOWN mode.\n\n*/\nexport const PMCTL_SHTDWN_KEY: any = '16'\nexport const PMCTL_SHTDWN_KEY_M: any = '16'\nexport const PMCTL_SHTDWN_KEY_S: any = '16'\n/**\nThis is the only valid key value that will trigger SHUTDOWN mode.\n\nAll other values are invalid and will have no effect.*/\nexport const PMCTL_SHTDWN_KEY_VALID: any = '42405'\n\n\n// -------- REGISTER SLPCTL -------- //\n\n/**\nSleep Control Register.\n\nThis register controls I/O pad sleep mode. When I/O pad sleep mode is enabled all I/O pad outputs and I/O pad configurations are latched. Inputs are transparent if I/O pad is configured as input.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_SLPCTL_RESERVED1: any = '31'\nexport const PMCTL_SLPCTL_RESERVED1_M: any = '31'\nexport const PMCTL_SLPCTL_RESERVED1_S: any = '31'\n/**\nThe boot code will set this bit field and disable sleep mode, automatically unless waking up from a SHUTDOWN RSTSTA.SDDET is set.\n\nApplication software must reconfigure the state for all IO's before setting this bit field upon waking up from a SHUTDOWN to avoid glitches on pins.*/\nexport const PMCTL_SLPCTL_SLPN: any = '1'\nexport const PMCTL_SLPCTL_SLPN_M: any = '1'\nexport const PMCTL_SLPCTL_SLPN_S: any = '1'\n/**\nI/O pad sleep mode is disabled*/\nexport const PMCTL_SLPCTL_SLPN_DIS: any = '1'\n\n/**\nI/O pad sleep mode is enabled*/\nexport const PMCTL_SLPCTL_SLPN_EN: any = '0'\n\n\n// -------- REGISTER WUSTA -------- //\n\n/**\nWakeup Status Register\n\nThis register shows the device wakeup source. Used to distinguish between wakeup from STANDBY, SHUTDOWN and reset.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_WUSTA_RESERVED2: any = '30'\nexport const PMCTL_WUSTA_RESERVED2_M: any = '30'\nexport const PMCTL_WUSTA_RESERVED2_S: any = '30'\n/**\nThis field shows the device wakeup source.\n\n*/\nexport const PMCTL_WUSTA_SRC: any = '2'\nexport const PMCTL_WUSTA_SRC_M: any = '2'\nexport const PMCTL_WUSTA_SRC_S: any = '2'\n/**\nWakeup from STANDBY mode.*/\nexport const PMCTL_WUSTA_SRC_STBY: any = '2'\n\n/**\nWakeup from system reset / SHUTDOWN mode. \n\nSee RSTSTA for more status information.*/\nexport const PMCTL_WUSTA_SRC_RST_SHTDWN: any = '1'\n\n\n// -------- REGISTER VDDRCTL -------- //\n\n/**\nVDDR Control Register.\n\nThis register contains VDDR regulator settings for the device.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_VDDRCTL_RESERVED2: any = '30'\nexport const PMCTL_VDDRCTL_RESERVED2_M: any = '30'\nexport const PMCTL_VDDRCTL_RESERVED2_S: any = '30'\n/**\nSelect between continuous or duty-cycled VDDR regulation in STANDBY mode.*/\nexport const PMCTL_VDDRCTL_STBY: any = '1'\nexport const PMCTL_VDDRCTL_STBY_M: any = '1'\nexport const PMCTL_VDDRCTL_STBY_S: any = '1'\n/**\nContinuous VDDR regulation in STANDBY mode.*/\nexport const PMCTL_VDDRCTL_STBY_PSUEDO: any = '1'\n\n/**\nDuty-cycled VDDR regulation in STANDBY mode.*/\nexport const PMCTL_VDDRCTL_STBY_NORMAL: any = '0'\n\n/**\nSelect between GLDO and DCDC as VDDR regulator (in ACTIVE, IDLE and STANDBY mode).*/\nexport const PMCTL_VDDRCTL_SELECT: any = '1'\nexport const PMCTL_VDDRCTL_SELECT_M: any = '1'\nexport const PMCTL_VDDRCTL_SELECT_S: any = '1'\n/**\nDCDC enabled for regulation of VDDR voltage*/\nexport const PMCTL_VDDRCTL_SELECT_DCDC: any = '1'\n\n/**\nGLDO enabled for regulation of VDDR voltage*/\nexport const PMCTL_VDDRCTL_SELECT_GLDO: any = '0'\n\n\n// -------- REGISTER SYSFSET -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSET_RESERVED3: any = '29'\nexport const PMCTL_SYSFSET_RESERVED3_M: any = '29'\nexport const PMCTL_SYSFSET_RESERVED3_S: any = '29'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSET_FLAG2: any = '1'\nexport const PMCTL_SYSFSET_FLAG2_M: any = '1'\nexport const PMCTL_SYSFSET_FLAG2_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSET_FLAG2_SET: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSET_FLAG2_NOEFF: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSET_FLAG1: any = '1'\nexport const PMCTL_SYSFSET_FLAG1_M: any = '1'\nexport const PMCTL_SYSFSET_FLAG1_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSET_FLAG1_SET: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSET_FLAG1_NOEFF: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSET_FLAG0: any = '1'\nexport const PMCTL_SYSFSET_FLAG0_M: any = '1'\nexport const PMCTL_SYSFSET_FLAG0_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSET_FLAG0_SET: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSET_FLAG0_NOEFF: any = '0'\n\n\n// -------- REGISTER SYSFCLR -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFCLR_RESERVED3: any = '29'\nexport const PMCTL_SYSFCLR_RESERVED3_M: any = '29'\nexport const PMCTL_SYSFCLR_RESERVED3_S: any = '29'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFCLR_FLAG2: any = '1'\nexport const PMCTL_SYSFCLR_FLAG2_M: any = '1'\nexport const PMCTL_SYSFCLR_FLAG2_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFCLR_FLAG2_CLR: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFCLR_FLAG2_NOEFF: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFCLR_FLAG1: any = '1'\nexport const PMCTL_SYSFCLR_FLAG1_M: any = '1'\nexport const PMCTL_SYSFCLR_FLAG1_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFCLR_FLAG1_CLR: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFCLR_FLAG1_NOEFF: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFCLR_FLAG0: any = '1'\nexport const PMCTL_SYSFCLR_FLAG0_M: any = '1'\nexport const PMCTL_SYSFCLR_FLAG0_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFCLR_FLAG0_CLR: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFCLR_FLAG0_NOEFF: any = '0'\n\n\n// -------- REGISTER SYSFSTA -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSTA_RESERVED3: any = '29'\nexport const PMCTL_SYSFSTA_RESERVED3_M: any = '29'\nexport const PMCTL_SYSFSTA_RESERVED3_S: any = '29'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSTA_FLAG2: any = '1'\nexport const PMCTL_SYSFSTA_FLAG2_M: any = '1'\nexport const PMCTL_SYSFSTA_FLAG2_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSTA_FLAG2_VAL1: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSTA_FLAG2_VAL0: any = '0'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSTA_FLAG1: any = '1'\nexport const PMCTL_SYSFSTA_FLAG1_M: any = '1'\nexport const PMCTL_SYSFSTA_FLAG1_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSTA_FLAG1_VAL1: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSTA_FLAG0: any = '1'\nexport const PMCTL_SYSFSTA_FLAG0_M: any = '1'\nexport const PMCTL_SYSFSTA_FLAG0_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSTA_FLAG0_VAL1: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_SYSFSTA_FLAG0_VAL0: any = '0'\n\n\n// -------- REGISTER RSTCTL -------- //\n\n/**\nReset Control Register.\n\nThis register configures and controls system reset.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_RSTCTL_RESERVED3: any = '29'\nexport const PMCTL_RSTCTL_RESERVED3_M: any = '29'\nexport const PMCTL_RSTCTL_RESERVED3_S: any = '29'\n/**\nLF clock loss reset enable.\n\nTrigger system reset when LF clock loss is detected, which reset the entire device and causes a reboot of the system.\nThe system reset event is captured as RSTSTA.RESETSRC set to SYSRESET and RSTSTA.SYSSRC set to LFLOSSEV.*/\nexport const PMCTL_RSTCTL_LFLOSS: any = '1'\nexport const PMCTL_RSTCTL_LFLOSS_M: any = '1'\nexport const PMCTL_RSTCTL_LFLOSS_S: any = '1'\n/**\nLF clock loss detection will trigger a system reset.*/\nexport const PMCTL_RSTCTL_LFLOSS_ARMED: any = '1'\n\n/**\nLF clock loss detection will not trigger a system reset.*/\nexport const PMCTL_RSTCTL_LFLOSS_DISARMED: any = '0'\n\n/**\nTSD (Thermal Shutdown) enable.  \n\nTSD will trigger an immediate system reset, which reset the entire device and causes a reboot of the system.\nThe device will be in reset until released by the TSD IP.\nThe system reset event is captured as RSTSTA.TSDEV flag set.*/\nexport const PMCTL_RSTCTL_TSDEN: any = '1'\nexport const PMCTL_RSTCTL_TSDEN_M: any = '1'\nexport const PMCTL_RSTCTL_TSDEN_S: any = '1'\n/**\nTemperature shutdown comparator enable. \n\nNote: If TSD IP not present, see DESCEX.TSD, enable will have no effect.*/\nexport const PMCTL_RSTCTL_TSDEN_EN: any = '1'\n\n/**\nNo effect*/\nexport const PMCTL_RSTCTL_TSDEN_NOEFF: any = '0'\n\n/**\nTrigger system reset, which will reset the entire device and causes a reboot of the system.\n\nThe system reset event is captured as RSTSTA.RESETSRC set to SYSRESET and RSTSTA.SYSSRC set to SYSRSTEV.*/\nexport const PMCTL_RSTCTL_SYSRST: any = '1'\nexport const PMCTL_RSTCTL_SYSRST_M: any = '1'\nexport const PMCTL_RSTCTL_SYSRST_S: any = '1'\n/**\nTrigger a system reset.*/\nexport const PMCTL_RSTCTL_SYSRST_SET: any = '1'\n\n/**\nNo effect*/\nexport const PMCTL_RSTCTL_SYSRST_NOEFF: any = '0'\n\n\n// -------- REGISTER RSTSTA -------- //\n\n/**\nReset Status. \n\nThis register contains the reset source and SHUTDOWN wakeup source for the system.\nCheck WUSTA.SRC first to ensure that wakeup from STANDBY is not set.\nThe capture feature is not rearmed until all of the possible reset sources have been released and the result has been copied to this register. \nDuring the copy and rearm process it is one 24MHz period in which an eventual new system reset will be reported as Power on reset regardless of the root cause.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_RSTSTA_RESERVED18: any = '14'\nexport const PMCTL_RSTSTA_RESERVED18_M: any = '14'\nexport const PMCTL_RSTSTA_RESERVED18_S: any = '14'\n/**\nWakeup from SHUTDOWN flag.\n\nNote: This flag will be cleared when SLPCTL.SLPN is asserted.*/\nexport const PMCTL_RSTSTA_SDDET: any = '1'\nexport const PMCTL_RSTSTA_SDDET_M: any = '1'\nexport const PMCTL_RSTSTA_SDDET_S: any = '1'\n/**\nWakeup from SHUTDOWN mode*/\nexport const PMCTL_RSTSTA_SDDET_TRIG: any = '1'\n\n/**\nWakeup from SHUTDOWN mode not triggered*/\nexport const PMCTL_RSTSTA_SDDET_NO_TRIG: any = '0'\n\n/**\nWakeup from SHUTDOWN on an I/O event flag.\n\nNote: This flag will be cleared when SLPCTL.SLPN is asserted.*/\nexport const PMCTL_RSTSTA_IOWUSD: any = '1'\nexport const PMCTL_RSTSTA_IOWUSD_M: any = '1'\nexport const PMCTL_RSTSTA_IOWUSD_S: any = '1'\n/**\nWakeup from SHUTDOWN triggered by an I/O event.*/\nexport const PMCTL_RSTSTA_IOWUSD_TRIG: any = '1'\n\n/**\nWakeup from SHUTDOWN not triggered by an I/O event.*/\nexport const PMCTL_RSTSTA_IOWUSD_NO_TRIG: any = '0'\n\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_RSTSTA_RESERVED8: any = '8'\nexport const PMCTL_RSTSTA_RESERVED8_M: any = '8'\nexport const PMCTL_RSTSTA_RESERVED8_S: any = '8'\n/**\nShows which reset event that triggered SYSRESET in RESETSRC*/\nexport const PMCTL_RSTSTA_SYSSRC: any = '4'\nexport const PMCTL_RSTSTA_SYSSRC_M: any = '4'\nexport const PMCTL_RSTSTA_SYSSRC_S: any = '4'\n/**\nDigital Error reset event*/\nexport const PMCTL_RSTSTA_SYSSRC_DERREV: any = '15'\n\n/**\nAnalog Error reset event*/\nexport const PMCTL_RSTSTA_SYSSRC_AERREV: any = '14'\n\n/**\nAnalog FSM timeout event*/\nexport const PMCTL_RSTSTA_SYSSRC_AFSMEV: any = '6'\n\n/**\nSerial Wire Debug reset event*/\nexport const PMCTL_RSTSTA_SYSSRC_SWDRSTEV: any = '5'\n\n/**\nSystem reset event*/\nexport const PMCTL_RSTSTA_SYSSRC_SYSRSTEV: any = '4'\n\n/**\nWatchdog timeout event*/\nexport const PMCTL_RSTSTA_SYSSRC_WDTEV: any = '3'\n\n/**\nCPU LOCKUP event*/\nexport const PMCTL_RSTSTA_SYSSRC_LOCKUPEV: any = '2'\n\n/**\nCPU reset event*/\nexport const PMCTL_RSTSTA_SYSSRC_CPURSTEV: any = '1'\n\n/**\nLF clock loss event*/\nexport const PMCTL_RSTSTA_SYSSRC_LFLOSSEV: any = '0'\n\n/**\nSystem reset triggered by TSD event*/\nexport const PMCTL_RSTSTA_TSDEV: any = '1'\nexport const PMCTL_RSTSTA_TSDEV_M: any = '1'\nexport const PMCTL_RSTSTA_TSDEV_S: any = '1'\n/**\nSystem reset triggered by TSD event*/\nexport const PMCTL_RSTSTA_TSDEV_TRIG: any = '1'\n\n/**\nTSD event not triggered*/\nexport const PMCTL_RSTSTA_TSDEV_NO_TRIG: any = '0'\n\n/**\nShows the root cause of the last system reset. More than one reported reset source can have been active during the last system reset, but only the root cause is reported.\n\nIf reset cause is SYSRESET or PINRESET, the other reset flags must be read to determine actual root cause.*/\nexport const PMCTL_RSTSTA_RESETSRC: any = '3'\nexport const PMCTL_RSTSTA_RESETSRC_M: any = '3'\nexport const PMCTL_RSTSTA_RESETSRC_S: any = '3'\n/**\nDigital system reset. Actual root cause is given by SYSSRC.*/\nexport const PMCTL_RSTSTA_RESETSRC_SYSRESET: any = '6'\n\n/**\nBrown out detect on VDDR*/\nexport const PMCTL_RSTSTA_RESETSRC_VDDRLOSS: any = '4'\n\n/**\nBrown out detect on VDDS*/\nexport const PMCTL_RSTSTA_RESETSRC_VDDSLOSS: any = '2'\n\n/**\nReset pin. TSD will also trigger a pin reset, so actual root cause is given by TSDEV reset flag status.*/\nexport const PMCTL_RSTSTA_RESETSRC_PINRESET: any = '1'\n\n/**\nPower on reset*/\nexport const PMCTL_RSTSTA_RESETSRC_PWRON: any = '0'\n\n\n// -------- REGISTER BOOTSTA -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_RESERVED8: any = '24'\nexport const PMCTL_BOOTSTA_RESERVED8_M: any = '24'\nexport const PMCTL_BOOTSTA_RESERVED8_S: any = '24'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG: any = '8'\nexport const PMCTL_BOOTSTA_FLAG_M: any = '8'\nexport const PMCTL_BOOTSTA_FLAG_S: any = '8'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_APP_FAULT_HANDLER: any = '255'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_APP_FAIL_APPTRANSFER: any = '254'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_APP_FAIL_NOAPP: any = '253'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_APP_WAITLOOP_DBGPROBE: any = '193'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_MODE_APP: any = '192'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BLDR_FAULT_HANDLER: any = '191'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BLDR_FAIL_APPTRANSFER: any = '190'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BLDR_FAIL_EXECUTION_CONTEXT: any = '189'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BLDR_CMD_PROCESSING: any = '188'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BLDR_CMD_IDLE: any = '187'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BLDR_STARTED: any = '186'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BLDR_WAITLOOP_DBGPROBE: any = '129'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_MODE_BLDR: any = '128'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BOOT_FAULT_HANDLER: any = '63'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BOOT_FAIL_SRAM_REPAIR: any = '62'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BOOT_WAITLOOP_DBGPROBE: any = '56'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BOOT_EXITED_SACI: any = '55'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BOOT_WAIT_SWD_DISCONNECT: any = '54'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BOOT_ENTERED_SACI: any = '32'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BOOT_GENERAL_TRIMS: any = '3'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BOOT_SRAM_REP_DONE: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BOOT_COLD_BOOT: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_BOOTSTA_FLAG_BOOT_RESET: any = '0'\n\n\n// -------- REGISTER AONRSTA1 -------- //\n\n/**\nAON Register Status 1.\n\nThis register contains the general purpose AON flags for SW, and is updated through AONRSET1.FLAG and AONRCLR1.FLAG.\nThe register is only reset on a POR event.\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_AONRSTA1_RESERVED18: any = '14'\nexport const PMCTL_AONRSTA1_RESERVED18_M: any = '14'\nexport const PMCTL_AONRSTA1_RESERVED18_S: any = '14'\n/**\nState of the AON register flags*/\nexport const PMCTL_AONRSTA1_FLAG: any = '18'\nexport const PMCTL_AONRSTA1_FLAG_M: any = '18'\nexport const PMCTL_AONRSTA1_FLAG_S: any = '18'\n\n// -------- REGISTER AONRSET1 -------- //\n\n/**\nAON Register Set 1.\n\nThis register sets the AON flags that can be read through AONRSTA1.FLAG.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_AONRSET1_RESERVED18: any = '14'\nexport const PMCTL_AONRSET1_RESERVED18_M: any = '14'\nexport const PMCTL_AONRSET1_RESERVED18_S: any = '14'\n/**\nWrite 1 to set AONRSTA1.FLAG*/\nexport const PMCTL_AONRSET1_FLAG: any = '18'\nexport const PMCTL_AONRSET1_FLAG_M: any = '18'\nexport const PMCTL_AONRSET1_FLAG_S: any = '18'\n/**\nSet all flags*/\nexport const PMCTL_AONRSET1_FLAG_ALL_SET: any = '262143'\n\n/**\nNo flags changed status*/\nexport const PMCTL_AONRSET1_FLAG_NOEFF: any = '0'\n\n\n// -------- REGISTER AONRCLR1 -------- //\n\n/**\nAON Register Clear 1.\n\nThis register clears the AON flags that can be read through AONRSTA1.FLAG.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const PMCTL_AONRCLR1_RESERVED18: any = '14'\nexport const PMCTL_AONRCLR1_RESERVED18_M: any = '14'\nexport const PMCTL_AONRCLR1_RESERVED18_S: any = '14'\n/**\nWrite 1 to clear AONRSTA1.FLAG*/\nexport const PMCTL_AONRCLR1_FLAG: any = '18'\nexport const PMCTL_AONRCLR1_FLAG_M: any = '18'\nexport const PMCTL_AONRCLR1_FLAG_S: any = '18'\n/**\nClear all flags*/\nexport const PMCTL_AONRCLR1_FLAG_ALL_CLR: any = '262143'\n\n/**\nNo flags changed status*/\nexport const PMCTL_AONRCLR1_FLAG_NOEFF: any = '0'\n\n\n// -------- REGISTER ETPP -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_ETPP_RESERVED0: any = '32'\nexport const PMCTL_ETPP_RESERVED0_M: any = '32'\nexport const PMCTL_ETPP_RESERVED0_S: any = '32'\n\n// -------- REGISTER RETCFG0 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG0_RESERVED1: any = '31'\nexport const PMCTL_RETCFG0_RESERVED1_M: any = '31'\nexport const PMCTL_RETCFG0_RESERVED1_S: any = '31'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG0_VAL: any = '1'\nexport const PMCTL_RETCFG0_VAL_M: any = '1'\nexport const PMCTL_RETCFG0_VAL_S: any = '1'\n\n// -------- REGISTER RETCFG1 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG1_RESERVED1: any = '31'\nexport const PMCTL_RETCFG1_RESERVED1_M: any = '31'\nexport const PMCTL_RETCFG1_RESERVED1_S: any = '31'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG1_VAL: any = '1'\nexport const PMCTL_RETCFG1_VAL_M: any = '1'\nexport const PMCTL_RETCFG1_VAL_S: any = '1'\n\n// -------- REGISTER RETCFG2 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG2_RESERVED3: any = '29'\nexport const PMCTL_RETCFG2_RESERVED3_M: any = '29'\nexport const PMCTL_RETCFG2_RESERVED3_S: any = '29'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG2_VAL: any = '3'\nexport const PMCTL_RETCFG2_VAL_M: any = '3'\nexport const PMCTL_RETCFG2_VAL_S: any = '3'\n\n// -------- REGISTER RETCFG3 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG3_RESERVED0: any = '32'\nexport const PMCTL_RETCFG3_RESERVED0_M: any = '32'\nexport const PMCTL_RETCFG3_RESERVED0_S: any = '32'\n\n// -------- REGISTER RETCFG4 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG4_RESERVED0: any = '32'\nexport const PMCTL_RETCFG4_RESERVED0_M: any = '32'\nexport const PMCTL_RETCFG4_RESERVED0_S: any = '32'\n\n// -------- REGISTER RETCFG5 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG5_RESERVED0: any = '32'\nexport const PMCTL_RETCFG5_RESERVED0_M: any = '32'\nexport const PMCTL_RETCFG5_RESERVED0_S: any = '32'\n\n// -------- REGISTER RETCFG6 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG6_RESERVED0: any = '32'\nexport const PMCTL_RETCFG6_RESERVED0_M: any = '32'\nexport const PMCTL_RETCFG6_RESERVED0_S: any = '32'\n\n// -------- REGISTER RETCFG7 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const PMCTL_RETCFG7_RESERVED0: any = '32'\nexport const PMCTL_RETCFG7_RESERVED0_M: any = '32'\nexport const PMCTL_RETCFG7_RESERVED0_S: any = '32'\n\n// -------- MODULE RTC -------- //\n\nexport interface RTC_t {\n    DESC: em.$Reg\n    CTL: em.$Reg\n    ARMSET: em.$Reg\n    ARMCLR: em.$Reg\n    TIME8U: em.$Reg\n    TIME524M: em.$Reg\n    CH0CC8U: em.$Reg\n    CH1CC8U: em.$Reg\n    CH1CFG: em.$Reg\n    IMASK: em.$Reg\n    RIS: em.$Reg\n    MIS: em.$Reg\n    ISET: em.$Reg\n    ICLR: em.$Reg\n    IMSET: em.$Reg\n    IMCLR: em.$Reg\n    EMU: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription Register. This register provides IP module ID, revision information, instance index and standard MMR registers offset.*/\n/**\nModule identifier used to uniquely identify this IP.*/\nexport const RTC_DESC_MODID: any = '16'\nexport const RTC_DESC_MODID_M: any = '16'\nexport const RTC_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set of from aggregated IRQ registers till DTB.\n\n\n0: Standard IP MMRs do not exist\n\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)*/\nexport const RTC_DESC_STDIPOFF: any = '4'\nexport const RTC_DESC_STDIPOFF_M: any = '4'\nexport const RTC_DESC_STDIPOFF_S: any = '4'\n/**\nIP Instance ID number. If multiple instances of IP exist in the device, this field can identify the instance number (0-15).*/\nexport const RTC_DESC_INSTIDX: any = '4'\nexport const RTC_DESC_INSTIDX_M: any = '4'\nexport const RTC_DESC_INSTIDX_S: any = '4'\n/**\nMajor revision of IP (0-15).*/\nexport const RTC_DESC_MAJREV: any = '4'\nexport const RTC_DESC_MAJREV_M: any = '4'\nexport const RTC_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP (0-15).*/\nexport const RTC_DESC_MINREV: any = '4'\nexport const RTC_DESC_MINREV_M: any = '4'\nexport const RTC_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER CTL -------- //\n\n/**\nRTC Control register. This register controls resetting the of RTC counter*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_CTL_RESERVED1: any = '31'\nexport const RTC_CTL_RESERVED1_M: any = '31'\nexport const RTC_CTL_RESERVED1_S: any = '31'\n/**\nRTC counter reset. Writing 1 to this bit will reset the RTC counter, and cause it to resume counting from 0x0*/\nexport const RTC_CTL_RST: any = '1'\nexport const RTC_CTL_RST_M: any = '1'\nexport const RTC_CTL_RST_S: any = '1'\n/**\nReset the timer.*/\nexport const RTC_CTL_RST_CLR: any = '1'\n\n/**\nNo effect*/\nexport const RTC_CTL_RST_NOEFF: any = '0'\n\n\n// -------- REGISTER ARMSET -------- //\n\n/**\nRTC channel mode set register. Read to each bit field of this register provides the current channel mode.   \n\n- Read of 1'b0 indicates the channel is unarmed.\n- Read of 1'b1 indicates the channel is either in capture or compare mode.\n\nA write to each bitfield of this register the following effect:\n- Write of 1'b0 has no effect on channel mode.\n- Write of 1'b1 has no effect on the compare channel. While write of 1'b1 for capture channel will arm it in capture mode if it is disabled.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_ARMSET_RESERVED2: any = '30'\nexport const RTC_ARMSET_RESERVED2_M: any = '30'\nexport const RTC_ARMSET_RESERVED2_S: any = '30'\n/**\nArming Channel 1 for capture operation.*/\nexport const RTC_ARMSET_CH1: any = '1'\nexport const RTC_ARMSET_CH1_M: any = '1'\nexport const RTC_ARMSET_CH1_S: any = '1'\n/**\nEnable the Channel 1 for capture operation*/\nexport const RTC_ARMSET_CH1_SET: any = '1'\n\n/**\nNo effect on the channel*/\nexport const RTC_ARMSET_CH1_NOEFF: any = '0'\n\n/**\nNo effect on arming the channel. Read will give the status of the Channel 0.*/\nexport const RTC_ARMSET_CH0: any = '1'\nexport const RTC_ARMSET_CH0_M: any = '1'\nexport const RTC_ARMSET_CH0_S: any = '1'\n/**\nNo effect on the compare channel*/\nexport const RTC_ARMSET_CH0_SET: any = '1'\n\n/**\nNo effect on the channel*/\nexport const RTC_ARMSET_CH0_NOEFF: any = '0'\n\n\n// -------- REGISTER ARMCLR -------- //\n\n/**\nRTC channel mode clear register. Read to each bit field of this register provides the current channel mode. \n\n- Read of 1'b0 indicates the channel is unarmed.\n- Read of 1'b1 indicates the channel is either in capture or compare mode.\n\nA write to each bitfield of this register the following effect:\n- Write of 1'b0 has no effect on channel mode.\n- Write of 1'b1 for capture/compare channel will disarm it without triggering event unless a compare/capture event happens in the same cycle.\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_ARMCLR_RESERVED2: any = '30'\nexport const RTC_ARMCLR_RESERVED2_M: any = '30'\nexport const RTC_ARMCLR_RESERVED2_S: any = '30'\n/**\nDisarming Channel 1*/\nexport const RTC_ARMCLR_CH1: any = '1'\nexport const RTC_ARMCLR_CH1_M: any = '1'\nexport const RTC_ARMCLR_CH1_S: any = '1'\n/**\nSet channel in UNARMED state without triggering event unless a capture event happens in the same cycle*/\nexport const RTC_ARMCLR_CH1_CLR: any = '1'\n\n/**\nNo effect on the channel*/\nexport const RTC_ARMCLR_CH1_NOEFF: any = '0'\n\n/**\nDisarming Channel 0*/\nexport const RTC_ARMCLR_CH0: any = '1'\nexport const RTC_ARMCLR_CH0_M: any = '1'\nexport const RTC_ARMCLR_CH0_S: any = '1'\n/**\nSet channel in UNARMED state without triggering event unless a compare event happens in the same cycle*/\nexport const RTC_ARMCLR_CH0_CLR: any = '1'\n\n/**\nNo effect on the channel*/\nexport const RTC_ARMCLR_CH0_NOEFF: any = '0'\n\n\n// -------- REGISTER TIME8U -------- //\n\n/**\nRTC Time value register. 32-bit unsigned integer representing [34:3] time slice of the real time clock counter. The counter runs on LFCLK. This field has a resolution of 8us, and range of about 9.5 hours.*/\n/**\nUnsigned integer representing [34:3]slice of real time counter.\n\n*/\nexport const RTC_TIME8U_VAL: any = '32'\nexport const RTC_TIME8U_VAL_M: any = '32'\nexport const RTC_TIME8U_VAL_S: any = '32'\n\n// -------- REGISTER TIME524M -------- //\n\n/**\nRTC time value register. 32-bit unsigned integer representing [50:19] time slice of the real time clock counter. This field has a resolution of about 0.5s and a range of about 71.4 years.*/\n/**\nUnsigned integer representing. [50:19]slice of real time counter.*/\nexport const RTC_TIME524M_VAL: any = '32'\nexport const RTC_TIME524M_VAL_M: any = '32'\nexport const RTC_TIME524M_VAL_S: any = '32'\n\n// -------- REGISTER CH0CC8U -------- //\n\n/**\nChannel 0 compare value. A write to this register automatically enables the channel to trigger an event when RTC timer reaches the programmed value or if the programmed value is 1 sec in the past.*/\n/**\nRTC Channel 0 compare value. This value is compared against TIME8U.VAL. A Channel 0 event is generated when TIME8U.VAL value reaches or exceeds this compare value.*/\nexport const RTC_CH0CC8U_VAL: any = '32'\nexport const RTC_CH0CC8U_VAL_M: any = '32'\nexport const RTC_CH0CC8U_VAL_S: any = '32'\n\n// -------- REGISTER CH1CC8U -------- //\n\n/**\nChannel 1 capture value. This register captures the RTC time slice [34:3] on each selected edge of the capture event when the ARMSET.CH1 = 1.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_CH1CC8U_RESERVED21: any = '11'\nexport const RTC_CH1CC8U_RESERVED21_M: any = '11'\nexport const RTC_CH1CC8U_RESERVED21_S: any = '11'\n/**\nTIME8U.VAL captured value at the last selected edge of capture event.*/\nexport const RTC_CH1CC8U_VAL: any = '21'\nexport const RTC_CH1CC8U_VAL_M: any = '21'\nexport const RTC_CH1CC8U_VAL_S: any = '21'\n\n// -------- REGISTER CH1CFG -------- //\n\n/**\nChannel 1 configuration register. This register can be used to select the capture edge for generating the capture event.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_CH1CFG_RESERVED1: any = '31'\nexport const RTC_CH1CFG_RESERVED1_M: any = '31'\nexport const RTC_CH1CFG_RESERVED1_S: any = '31'\n/**\nEdge detect configuration for capture source*/\nexport const RTC_CH1CFG_EDGE: any = '1'\nexport const RTC_CH1CFG_EDGE_M: any = '1'\nexport const RTC_CH1CFG_EDGE_S: any = '1'\n/**\nFalling Edge.*/\nexport const RTC_CH1CFG_EDGE_FALL: any = '1'\n\n/**\nRising Edge.*/\nexport const RTC_CH1CFG_EDGE_RISE: any = '0'\n\n\n// -------- REGISTER IMASK -------- //\n\n/**\nInterrupt Mask. If a bit is set, then corresponding interrupt is un-masked. Un-masking the interrupt causes the raw interrupt to be visible in IIDX, as well as MIS.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_IMASK_RESERVED2: any = '30'\nexport const RTC_IMASK_RESERVED2_M: any = '30'\nexport const RTC_IMASK_RESERVED2_S: any = '30'\n/**\nChannel 1 Event Interrupt Mask.*/\nexport const RTC_IMASK_EV1: any = '1'\nexport const RTC_IMASK_EV1_M: any = '1'\nexport const RTC_IMASK_EV1_S: any = '1'\n/**\nEnable Interrrupt Mask*/\nexport const RTC_IMASK_EV1_EN: any = '1'\n\n/**\nClear Interrupt Mask*/\nexport const RTC_IMASK_EV1_DIS: any = '0'\n\n/**\nChannel 0 Event Interrupt Mask.*/\nexport const RTC_IMASK_EV0: any = '1'\nexport const RTC_IMASK_EV0_M: any = '1'\nexport const RTC_IMASK_EV0_S: any = '1'\n/**\nEnable Interrrupt Mask*/\nexport const RTC_IMASK_EV0_EN: any = '1'\n\n/**\nDisable Interrupt Mask*/\nexport const RTC_IMASK_EV0_DIS: any = '0'\n\n\n// -------- REGISTER RIS -------- //\n\n/**\nInterrupt mask. This register selects interrupt sources which are allowed to pass from RIS to MIS when the corresponding bit-fields are set to 1.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_RIS_RESERVED2: any = '30'\nexport const RTC_RIS_RESERVED2_M: any = '30'\nexport const RTC_RIS_RESERVED2_S: any = '30'\n/**\nRaw interrupt status for Channel 1 event.\n\nThis bit is set to 1 when a capture event is received on Channel 1. \nThis bit will be cleared when the bit in ICLR.EV1 is set to 1 or when the captured time value is read from the CH1CC8U register.*/\nexport const RTC_RIS_EV1: any = '1'\nexport const RTC_RIS_EV1_M: any = '1'\nexport const RTC_RIS_EV1_S: any = '1'\n/**\nInterrupt occured*/\nexport const RTC_RIS_EV1_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const RTC_RIS_EV1_CLR: any = '0'\n\n/**\nRaw interrupt status for Channel 0 event.\n\nThis bit is set to 1 when a compare event occurs on Channel 0. \nThis bit will be cleared. When the corresponding bit in ICLR.EV0 is set to 1. Or when a new compare value is written in CH0CC8U register*/\nexport const RTC_RIS_EV0: any = '1'\nexport const RTC_RIS_EV0_M: any = '1'\nexport const RTC_RIS_EV0_S: any = '1'\n/**\nInterrupt occured*/\nexport const RTC_RIS_EV0_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const RTC_RIS_EV0_CLR: any = '0'\n\n\n// -------- REGISTER MIS -------- //\n\n/**\nMasked interrupt status. This register is simply a bitwise AND of the contents of IMASK and RIS.*] registers. A flag set in this register can be cleared by writing 1 to the corresponding ICLR register bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_MIS_RESERVED2: any = '30'\nexport const RTC_MIS_RESERVED2_M: any = '30'\nexport const RTC_MIS_RESERVED2_S: any = '30'\n/**\nMasked interrupt status for channel 1 event.*/\nexport const RTC_MIS_EV1: any = '1'\nexport const RTC_MIS_EV1_M: any = '1'\nexport const RTC_MIS_EV1_S: any = '1'\n/**\nInterrupt occured*/\nexport const RTC_MIS_EV1_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const RTC_MIS_EV1_CLR: any = '0'\n\n/**\nMasked interrupt status for channel 0 event.*/\nexport const RTC_MIS_EV0: any = '1'\nexport const RTC_MIS_EV0_M: any = '1'\nexport const RTC_MIS_EV0_S: any = '1'\n/**\nInterrupt occured*/\nexport const RTC_MIS_EV0_SET: any = '1'\n\n/**\nInterrupt did not occur*/\nexport const RTC_MIS_EV0_CLR: any = '0'\n\n\n// -------- REGISTER ISET -------- //\n\n/**\nInterrupt set register. This register can used by software for diagnostics and safety checking purposes. Writing a 1 to a bit in this register will set the event and the corresponding RIS bit also gets set. If the corresponding IMASK bit is set, then the corresponding MIS register bit also gets set.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_ISET_RESERVED2: any = '30'\nexport const RTC_ISET_RESERVED2_M: any = '30'\nexport const RTC_ISET_RESERVED2_S: any = '30'\n/**\nSet Channel 1 event Interrupt.*/\nexport const RTC_ISET_EV1: any = '1'\nexport const RTC_ISET_EV1_M: any = '1'\nexport const RTC_ISET_EV1_S: any = '1'\n/**\nSet interrupt*/\nexport const RTC_ISET_EV1_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const RTC_ISET_EV1_NO_EFFECT: any = '0'\n\n/**\nSet Channel 0 event Interrupt.*/\nexport const RTC_ISET_EV0: any = '1'\nexport const RTC_ISET_EV0_M: any = '1'\nexport const RTC_ISET_EV0_S: any = '1'\n/**\nSet interrupt*/\nexport const RTC_ISET_EV0_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const RTC_ISET_EV0_NO_EFFECT: any = '0'\n\n\n// -------- REGISTER ICLR -------- //\n\n/**\n    Interrupt clear register. This register allows software to clear interrupts. Writing a 1 to a bit in this register will clear the event and the corresponding RIS bit also gets cleared. If the corresponding IMASK bit is set, then the corresponding MIS register bit also gets cleared.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_ICLR_RESERVED2: any = '30'\nexport const RTC_ICLR_RESERVED2_M: any = '30'\nexport const RTC_ICLR_RESERVED2_S: any = '30'\n/**\nClears channel 1 event interrupt.*/\nexport const RTC_ICLR_EV1: any = '1'\nexport const RTC_ICLR_EV1_M: any = '1'\nexport const RTC_ICLR_EV1_S: any = '1'\n/**\nClear Interrupt*/\nexport const RTC_ICLR_EV1_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const RTC_ICLR_EV1_NO_EFF: any = '0'\n\n/**\nClears channel 0 event interrupt.*/\nexport const RTC_ICLR_EV0: any = '1'\nexport const RTC_ICLR_EV0_M: any = '1'\nexport const RTC_ICLR_EV0_S: any = '1'\n/**\nClear Interrupt.*/\nexport const RTC_ICLR_EV0_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const RTC_ICLR_EV0_NO_EFF: any = '0'\n\n\n// -------- REGISTER IMSET -------- //\n\n/**\nInterrupt mask set register. Writing a 1 to a bit in this register will set the corresponding IMASK bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_IMSET_RESERVED2: any = '30'\nexport const RTC_IMSET_RESERVED2_M: any = '30'\nexport const RTC_IMSET_RESERVED2_S: any = '30'\n/**\nSet channel 1 event interrupt mask.*/\nexport const RTC_IMSET_EV1: any = '1'\nexport const RTC_IMSET_EV1_M: any = '1'\nexport const RTC_IMSET_EV1_S: any = '1'\n/**\nSet interrupt mask*/\nexport const RTC_IMSET_EV1_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const RTC_IMSET_EV1_NO_EFF: any = '0'\n\n/**\nSet channel 0 event interrupt mask.*/\nexport const RTC_IMSET_EV0: any = '1'\nexport const RTC_IMSET_EV0_M: any = '1'\nexport const RTC_IMSET_EV0_S: any = '1'\n/**\nSet interrupt mask*/\nexport const RTC_IMSET_EV0_SET: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const RTC_IMSET_EV0_NO_EFF: any = '0'\n\n\n// -------- REGISTER IMCLR -------- //\n\n/**\nInterrupt mask clear register. Writing a 1 to a bit in this register will clear the corresponding IMASK bit.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_IMCLR_RESERVED2: any = '30'\nexport const RTC_IMCLR_RESERVED2_M: any = '30'\nexport const RTC_IMCLR_RESERVED2_S: any = '30'\n/**\nClears Channel 1 event interrupt mask.*/\nexport const RTC_IMCLR_EV1: any = '1'\nexport const RTC_IMCLR_EV1_M: any = '1'\nexport const RTC_IMCLR_EV1_S: any = '1'\n/**\nClear Interrupt Mask*/\nexport const RTC_IMCLR_EV1_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const RTC_IMCLR_EV1_NO_EFF: any = '0'\n\n/**\nClears Channel 0 event interrupt mask.*/\nexport const RTC_IMCLR_EV0: any = '1'\nexport const RTC_IMCLR_EV0_M: any = '1'\nexport const RTC_IMCLR_EV0_S: any = '1'\n/**\nClear Interrupt Mask*/\nexport const RTC_IMCLR_EV0_CLR: any = '1'\n\n/**\nWriting 0 has no effect*/\nexport const RTC_IMCLR_EV0_NO_EFF: any = '0'\n\n\n// -------- REGISTER EMU -------- //\n\n/**\nEmulation control register. This register controls the behavior of the IP related to core halted input.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const RTC_EMU_RESERVED1: any = '31'\nexport const RTC_EMU_RESERVED1_M: any = '31'\nexport const RTC_EMU_RESERVED1_S: any = '31'\n/**\nHalt control.*/\nexport const RTC_EMU_HALT: any = '1'\nexport const RTC_EMU_HALT_M: any = '1'\nexport const RTC_EMU_HALT_S: any = '1'\n/**\nFreeze option. The IP freezes functionality when the core halted input is asserted, and resumes when it is deasserted. The freeze can either be immediate or after the IP has reached a boundary from where it can resume without corruption.*/\nexport const RTC_EMU_HALT_STOP: any = '1'\n\n/**\nFree run option. The IP ignores the state of the core halted input.*/\nexport const RTC_EMU_HALT_RUN: any = '0'\n\n\n// -------- MODULE UART -------- //\n\nexport interface UART_t {\n    DR: em.$Reg\n    RSR_ECR: em.$Reg\n    RESERVED0: em.$Reg\n    FR: em.$Reg\n    RESERVED2: em.$Reg\n    UARTILPR: em.$Reg\n    IBRD: em.$Reg\n    FBRD: em.$Reg\n    LCRH: em.$Reg\n    CTL: em.$Reg\n    IFLS: em.$Reg\n    IMSC: em.$Reg\n    RIS: em.$Reg\n    MIS: em.$Reg\n    ICR: em.$Reg\n    DMACTL: em.$Reg\n    RESERVED1: em.$Reg\n    RESERVED3: em.$Reg\n    RESERVED4: em.$Reg\n}\n\n// -------- REGISTER DR -------- //\n\n/**\nData\n\nFor words to be transmitted:\n  - if the FIFOs are enabled (LCRH.FEN = 1), data written to this location is pushed onto the transmit FIFO\n  - if the FIFOs are not enabled (LCRH.FEN = 0), data is stored in the transmitter holding register (the bottom word of the transmit FIFO).\nThe write operation initiates transmission from the UART. The data is prefixed with a start bit, appended with the appropriate parity bit (if parity is enabled), and a stop bit.\nThe resultant word is then transmitted.\nFor received words:\n  - if the FIFOs are enabled (LCRH.FEN = 1), the data byte and the 4-bit status (break, frame, parity, and overrun) is pushed onto the 12-bit wide receive FIFO \n  - if the FIFOs are not enabled (LCRH.FEN = 0), the data byte and status are stored in the receiving holding register (the bottom word of the receive FIFO).\nThe received data byte is read by performing reads from this register along with the corresponding status information. The status information can also be read by a read of the RSR_ECR register.*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_DR_RESERVED12: any = '20'\nexport const UART_DR_RESERVED12_M: any = '20'\nexport const UART_DR_RESERVED12_S: any = '20'\n/**\nUART Overrun Error:\n\nThis bit is set to 1 if data is received and the receive FIFO is already full. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten.\nThis is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.*/\nexport const UART_DR_OE: any = '1'\nexport const UART_DR_OE_M: any = '1'\nexport const UART_DR_OE_S: any = '1'\n/**\nUART Break Error:\n\nThis bit is set to 1 if a break condition was detected, indicating that the received data input (UARTRXD input pin) was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits).\nIn FIFO mode, this error is associated with the character at the top of the FIFO (i.e., the oldest received data character since last read). When a break occurs, a 0 character is loaded into the FIFO. The next character is enabled after the receive data input (UARTRXD input pin) goes to a 1 (marking state), and the next valid start bit is received.*/\nexport const UART_DR_BE: any = '1'\nexport const UART_DR_BE_M: any = '1'\nexport const UART_DR_BE_S: any = '1'\n/**\nUART Parity Error:\n\nWhen set to 1, it indicates that the parity of the received data character does not match the parity that the LCRH.EPS and LCRH.SPS select.\nIn FIFO mode, this error is associated with the character at the top of the FIFO (i.e., the oldest received data character since last read).*/\nexport const UART_DR_PE: any = '1'\nexport const UART_DR_PE_M: any = '1'\nexport const UART_DR_PE_S: any = '1'\n/**\nUART Framing Error:\n\nWhen set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1).\nIn FIFO mode, this error is associated with the character at the top of the FIFO (i.e., the oldest received data character since last read).*/\nexport const UART_DR_FE: any = '1'\nexport const UART_DR_FE_M: any = '1'\nexport const UART_DR_FE_S: any = '1'\n/**\nData transmitted or received:\n\nOn writes, the transmit data character is pushed into the FIFO.\nOn reads, the oldest received data character since the last read is returned.*/\nexport const UART_DR_DATA: any = '8'\nexport const UART_DR_DATA_M: any = '8'\nexport const UART_DR_DATA_S: any = '8'\n\n// -------- REGISTER RSR_ECR -------- //\n\n/**\nStatus\n\nThis register is mapped to the same address as ECR register.  Reads from this address are associated with RSR_ECR register and return the receive status. Writes to this address are associated with ECR register and clear the receive status flags (framing, parity, break, and overrun errors).\nIf the status is read from this register, then the status information for break, framing and parity corresponds to the data character read from the Data Register DR, prior to reading the RSR_ECR. The status information for overrun is set immediately when an overrun condition occurs.*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_RSR_ECR_RESERVED4: any = '28'\nexport const UART_RSR_ECR_RESERVED4_M: any = '28'\nexport const UART_RSR_ECR_RESERVED4_S: any = '28'\n/**\nUART Overrun Error:\n\nThis bit is set to 1 if data is received and the receive FIFO is already full. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten.\nThis is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.*/\nexport const UART_RSR_ECR_OE: any = '1'\nexport const UART_RSR_ECR_OE_M: any = '1'\nexport const UART_RSR_ECR_OE_S: any = '1'\n/**\nClears error flag if error is set. Write value is not important.*/\nexport const UART_RSR_ECR_OE_CLEAR_ERROR_1: any = '1'\n\n/**\nError flag is not set*/\nexport const UART_RSR_ECR_OE_ERROR_NOTSET: any = '0'\n\n/**\nUART Break Error:\n\nThis bit is set to 1 if a break condition was detected, indicating that the received data input (UARTRXD input pin) was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits).\nWhen a break occurs, a 0 character is loaded into the FIFO. The next character is enabled after the receive data input (UARTRXD input pin) goes to a 1 (marking state), and the next valid start bit is received.*/\nexport const UART_RSR_ECR_BE: any = '1'\nexport const UART_RSR_ECR_BE_M: any = '1'\nexport const UART_RSR_ECR_BE_S: any = '1'\n/**\nClears error flag if error is set. Write value is not important.*/\nexport const UART_RSR_ECR_BE_CLEAR_ERROR_1: any = '1'\n\n/**\nError flag is not set*/\nexport const UART_RSR_ECR_BE_ERROR_NOTSET: any = '0'\n\n/**\nUART Parity Error:\n\nWhen set to 1, it indicates that the parity of the received data character does not match the parity that the LCRH.EPS and LCRH.SPS select.*/\nexport const UART_RSR_ECR_PE: any = '1'\nexport const UART_RSR_ECR_PE_M: any = '1'\nexport const UART_RSR_ECR_PE_S: any = '1'\n/**\nClears error flag if error is set. Write value is not important.*/\nexport const UART_RSR_ECR_PE_CLEAR_ERROR_1: any = '1'\n\n/**\nError flag is not set*/\nexport const UART_RSR_ECR_PE_ERROR_NOTSET: any = '0'\n\n/**\nUART Framing Error:\n\nWhen set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1).*/\nexport const UART_RSR_ECR_FE: any = '1'\nexport const UART_RSR_ECR_FE_M: any = '1'\nexport const UART_RSR_ECR_FE_S: any = '1'\n/**\nClears error flag if error is set. Write value is not important.*/\nexport const UART_RSR_ECR_FE_CLEAR_ERROR_1: any = '1'\n\n/**\nError flag is not set*/\nexport const UART_RSR_ECR_FE_ERROR_NOTSET: any = '0'\n\n\n// -------- REGISTER RESERVED0 -------- //\n\n/**\nUART Reserved Area*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_RESERVED0_RESERVED: any = '32'\nexport const UART_RESERVED0_RESERVED_M: any = '32'\nexport const UART_RESERVED0_RESERVED_S: any = '32'\n\n// -------- REGISTER FR -------- //\n\n/**\nFlag\n\nReads from this register return the UART flags.*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_FR_RESERVED8: any = '24'\nexport const UART_FR_RESERVED8_M: any = '24'\nexport const UART_FR_RESERVED8_S: any = '24'\n/**\nUART Transmit FIFO Empty:\n\nThe meaning of this bit depends on the state of LCRH.FEN .\n  - If the FIFO is disabled, this bit is set when the transmit holding register is empty.\n  - If the FIFO is enabled, this bit is set when the transmit FIFO is empty.\nThis bit does not indicate if there is data in the transmit shift register.*/\nexport const UART_FR_TXFE: any = '1'\nexport const UART_FR_TXFE_M: any = '1'\nexport const UART_FR_TXFE_S: any = '1'\n/**\nUART Receive FIFO Full: \n\nThe meaning of this bit depends on the state of LCRH.FEN.\n  - If the FIFO is disabled, this bit is set when the receive holding register is full.\n  - If the FIFO is enabled, this bit is set when the receive FIFO is full.*/\nexport const UART_FR_RXFF: any = '1'\nexport const UART_FR_RXFF_M: any = '1'\nexport const UART_FR_RXFF_S: any = '1'\n/**\nUART Transmit FIFO Full:\n\nTransmit FIFO full. The meaning of this bit depends on the state of LCRH.FEN.\n  - If the FIFO is disabled, this bit is set when the transmit holding register is full.\n  - If the FIFO is enabled, this bit is set when the transmit FIFO is full.*/\nexport const UART_FR_TXFF: any = '1'\nexport const UART_FR_TXFF_M: any = '1'\nexport const UART_FR_TXFF_S: any = '1'\n/**\nUART Receive FIFO Empty:\n\nReceive FIFO empty. The meaning of this bit depends on the state of LCRH.FEN.\n  - If the FIFO is disabled, this bit is set when the receive holding register is empty.\n  - If the FIFO is enabled, this bit is set when the receive FIFO is empty.*/\nexport const UART_FR_RXFE: any = '1'\nexport const UART_FR_RXFE_M: any = '1'\nexport const UART_FR_RXFE_S: any = '1'\n/**\nUART Busy: \n\nIf this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register.\nThis bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.*/\nexport const UART_FR_BUSY: any = '1'\nexport const UART_FR_BUSY_M: any = '1'\nexport const UART_FR_BUSY_S: any = '1'\n/**\nReserved*/\nexport const UART_FR_RESERVED0: any = '2'\nexport const UART_FR_RESERVED0_M: any = '2'\nexport const UART_FR_RESERVED0_S: any = '2'\n/**\nClear To Send: \n\nThis bit is the complement of the active-low UART CTS input pin.\nThat is, the bit is 1 when CTS input pin is LOW.*/\nexport const UART_FR_CTS: any = '1'\nexport const UART_FR_CTS_M: any = '1'\nexport const UART_FR_CTS_S: any = '1'\n\n// -------- REGISTER RESERVED2 -------- //\n\n/**\nUART Reserved Area*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_RESERVED2_RESERVED: any = '32'\nexport const UART_RESERVED2_RESERVED_M: any = '32'\nexport const UART_RESERVED2_RESERVED_S: any = '32'\n\n// -------- REGISTER UARTILPR -------- //\n\n/**\nIrDA Low-Power Counter Register.\n\n\nThis is an 8-bit register that stores the low-power counter divisor value used to generate the IrLPBaud16 signal by dividing down of UARTCLK.*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_UARTILPR_RESERVED8: any = '24'\nexport const UART_UARTILPR_RESERVED8_M: any = '24'\nexport const UART_UARTILPR_RESERVED8_S: any = '24'\n/**\n8 bit low-power divisor value. In low-power IrDA mode the UART rejects random noise on the received serial data\n\ninput by ignoring SIRIN pulses that are less than 3 periods of IrLPBaud16.*/\nexport const UART_UARTILPR_ILPDVSR: any = '8'\nexport const UART_UARTILPR_ILPDVSR_M: any = '8'\nexport const UART_UARTILPR_ILPDVSR_S: any = '8'\n\n// -------- REGISTER IBRD -------- //\n\n/**\nInteger Baud-Rate Divisor\n\nIf this register is modified while trasmission or reception is on-going, the baudrate will not be updated until transmission or reception of the current character is complete.*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_IBRD_RESERVED16: any = '16'\nexport const UART_IBRD_RESERVED16_M: any = '16'\nexport const UART_IBRD_RESERVED16_S: any = '16'\n/**\nThe integer baud rate divisor:\n\nThe baud rate divisor is calculated using the formula below:\nBaud rate divisor = (UART reference clock frequency) / (16 * Baud rate)\nBaud rate divisor must be minimum 1 and maximum 65535. \nThat is, DIVINT=0 does not give a valid baud rate. \nSimilarly, if DIVINT=0xFFFF, any non-zero values in FBRD.DIVFRAC will be illegal.\nRefer to Section 19.1.5 for an example calculation.\nA valid value must be written to this field before the UART can be used for RX or TX operations.\n*/\nexport const UART_IBRD_DIVINT: any = '16'\nexport const UART_IBRD_DIVINT_M: any = '16'\nexport const UART_IBRD_DIVINT_S: any = '16'\n\n// -------- REGISTER FBRD -------- //\n\n/**\nFractional Baud-Rate Divisor\n\nIf this register is modified while trasmission or reception is on-going, the baudrate will not be updated until transmission or reception of the current character is complete.*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_FBRD_RESERVED6: any = '26'\nexport const UART_FBRD_RESERVED6_M: any = '26'\nexport const UART_FBRD_RESERVED6_S: any = '26'\n/**\nFractional Baud-Rate Divisor:\n\nThe baud rate divisor is calculated using the formula below:\nBaud rate divisor = (UART reference clock frequency) / (16 * Baud rate)\nBaud rate divisor must be minimum 1 and maximum 65535. \nThat is, IBRD.DIVINT=0 does not give a valid baud rate. \nSimilarly, if IBRD.DIVINT=0xFFFF, any non-zero values in DIVFRAC will be illegal.\nRefer to Section 19.1.5 for an example calculation.\nA valid value must be written to this field before the UART can be used for RX or TX operations.\n*/\nexport const UART_FBRD_DIVFRAC: any = '6'\nexport const UART_FBRD_DIVFRAC_M: any = '6'\nexport const UART_FBRD_DIVFRAC_S: any = '6'\n\n// -------- REGISTER LCRH -------- //\n\n/**\nLine Control*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_LCRH_RESERVED8: any = '24'\nexport const UART_LCRH_RESERVED8_M: any = '24'\nexport const UART_LCRH_RESERVED8_S: any = '24'\n/**\nUART Stick Parity Select:\n\n\n0: Stick parity is disabled\n1: The parity bit is transmitted and checked as invert of EPS field (i.e. the parity bit is transmitted and checked as 1 when EPS = 0).\n\nThis bit has no effect when PEN disables parity checking and generation.*/\nexport const UART_LCRH_SPS: any = '1'\nexport const UART_LCRH_SPS_M: any = '1'\nexport const UART_LCRH_SPS_S: any = '1'\n/**\nUART Word Length:\n\nThese bits indicate the number of data bits transmitted or received in a frame.*/\nexport const UART_LCRH_WLEN: any = '2'\nexport const UART_LCRH_WLEN_M: any = '2'\nexport const UART_LCRH_WLEN_S: any = '2'\n/**\nWord Length 8 bits*/\nexport const UART_LCRH_WLEN_BITL8: any = '3'\n\n/**\nWord Length 7 bits*/\nexport const UART_LCRH_WLEN_BITL7: any = '2'\n\n/**\nWord Length 6 bits*/\nexport const UART_LCRH_WLEN_BITL6: any = '1'\n\n/**\nWord Length 5 bits*/\nexport const UART_LCRH_WLEN_BITL5: any = '0'\n\n/**\nUART Enable FIFOs*/\nexport const UART_LCRH_FEN: any = '1'\nexport const UART_LCRH_FEN_M: any = '1'\nexport const UART_LCRH_FEN_S: any = '1'\n/**\nTransmit and receive FIFO buffers are enabled (FIFO mode)*/\nexport const UART_LCRH_FEN_EN: any = '1'\n\n/**\nFIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers.*/\nexport const UART_LCRH_FEN_DIS: any = '0'\n\n/**\nUART Two Stop Bits Select:\n\nIf this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.*/\nexport const UART_LCRH_STP2: any = '1'\nexport const UART_LCRH_STP2_M: any = '1'\nexport const UART_LCRH_STP2_S: any = '1'\n/**\nUART Even Parity Select*/\nexport const UART_LCRH_EPS: any = '1'\nexport const UART_LCRH_EPS_M: any = '1'\nexport const UART_LCRH_EPS_S: any = '1'\n/**\nEven parity: The UART generates or checks for an even number of 1s in the data and parity bits.*/\nexport const UART_LCRH_EPS_EVEN: any = '1'\n\n/**\nOdd parity: The UART generates or checks for an odd number of 1s in the data and parity bits.*/\nexport const UART_LCRH_EPS_ODD: any = '0'\n\n/**\nUART Parity Enable\n\nThis bit controls generation and checking of parity bit. \n*/\nexport const UART_LCRH_PEN: any = '1'\nexport const UART_LCRH_PEN_M: any = '1'\nexport const UART_LCRH_PEN_S: any = '1'\n/**\nParity checking and generation is enabled.*/\nexport const UART_LCRH_PEN_EN: any = '1'\n\n/**\nParity is disabled and no parity bit is added to the data frame*/\nexport const UART_LCRH_PEN_DIS: any = '0'\n\n/**\nUART Send Break\n\nIf this bit is set to 1, a low-level is continually output on the UARTTXD output pin, after completing transmission of the current character. For the proper execution of the break command, the\nsoftware must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.*/\nexport const UART_LCRH_BRK: any = '1'\nexport const UART_LCRH_BRK_M: any = '1'\nexport const UART_LCRH_BRK_S: any = '1'\n\n// -------- REGISTER CTL -------- //\n\n/**\nControl*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_CTL_RESERVED16: any = '16'\nexport const UART_CTL_RESERVED16_M: any = '16'\nexport const UART_CTL_RESERVED16_S: any = '16'\n/**\nCTS hardware flow control enable*/\nexport const UART_CTL_CTSEN: any = '1'\nexport const UART_CTL_CTSEN_M: any = '1'\nexport const UART_CTL_CTSEN_S: any = '1'\n/**\nCTS hardware flow control enabled*/\nexport const UART_CTL_CTSEN_EN: any = '1'\n\n/**\nCTS hardware flow control disabled*/\nexport const UART_CTL_CTSEN_DIS: any = '0'\n\n/**\nRTS hardware flow control enable*/\nexport const UART_CTL_RTSEN: any = '1'\nexport const UART_CTL_RTSEN_M: any = '1'\nexport const UART_CTL_RTSEN_S: any = '1'\n/**\nRTS hardware flow control enabled*/\nexport const UART_CTL_RTSEN_EN: any = '1'\n\n/**\nRTS hardware flow control disabled*/\nexport const UART_CTL_RTSEN_DIS: any = '0'\n\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_CTL_RESERVED12: any = '2'\nexport const UART_CTL_RESERVED12_M: any = '2'\nexport const UART_CTL_RESERVED12_S: any = '2'\n/**\nRequest to Send\n\nThis bit is the complement of the active-low UART RTS output. That is, when the bit is programmed to a 1 then RTS output on the pins is LOW.*/\nexport const UART_CTL_RTS: any = '1'\nexport const UART_CTL_RTS_M: any = '1'\nexport const UART_CTL_RTS_S: any = '1'\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_CTL_RESERVED10: any = '1'\nexport const UART_CTL_RESERVED10_M: any = '1'\nexport const UART_CTL_RESERVED10_S: any = '1'\n/**\nUART Receive Enable\n\nIf the UART is disabled in the middle of reception, it completes the current character before stopping.*/\nexport const UART_CTL_RXE: any = '1'\nexport const UART_CTL_RXE_M: any = '1'\nexport const UART_CTL_RXE_S: any = '1'\n/**\nUART Receive enabled*/\nexport const UART_CTL_RXE_EN: any = '1'\n\n/**\nUART Receive disabled*/\nexport const UART_CTL_RXE_DIS: any = '0'\n\n/**\nUART Transmit Enable\n\nIf the UART is disabled in the middle of transmission, it completes the current character before stopping.*/\nexport const UART_CTL_TXE: any = '1'\nexport const UART_CTL_TXE_M: any = '1'\nexport const UART_CTL_TXE_S: any = '1'\n/**\nUART Transmit enabled*/\nexport const UART_CTL_TXE_EN: any = '1'\n\n/**\nUART Transmit disabled*/\nexport const UART_CTL_TXE_DIS: any = '0'\n\n/**\nUART Loop Back Enable\n\nEnabling the loop-back mode connects the UARTTXD output from the UART to UARTRXD input of the UART.*/\nexport const UART_CTL_LBE: any = '1'\nexport const UART_CTL_LBE_M: any = '1'\nexport const UART_CTL_LBE_S: any = '1'\n/**\nLoop Back enabled*/\nexport const UART_CTL_LBE_EN: any = '1'\n\n/**\nLoop Back disabled*/\nexport const UART_CTL_LBE_DIS: any = '0'\n\n/**\nUART FIFO Concatenation Enable\n\nEnabling the FIFO concatenation in TX mode resulting in 16 TX buffers.*/\nexport const UART_CTL_FCEN: any = '1'\nexport const UART_CTL_FCEN_M: any = '1'\nexport const UART_CTL_FCEN_S: any = '1'\n/**\nUART FIFO Concatenation  enabled*/\nexport const UART_CTL_FCEN_EN: any = '1'\n\n/**\nUART FIFO Concatenation  disabled*/\nexport const UART_CTL_FCEN_DIS: any = '0'\n\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_CTL_RESERVED1: any = '3'\nexport const UART_CTL_RESERVED1_M: any = '3'\nexport const UART_CTL_RESERVED1_S: any = '3'\n/**\nSIR low power IrDA mode\n\nThis bit selects the IrDA encoding mode*/\nexport const UART_CTL_SIRLP: any = '1'\nexport const UART_CTL_SIRLP_M: any = '1'\nexport const UART_CTL_SIRLP_S: any = '1'\n/**\nLow-level bits are transmitted with a pulse width of 3 times the period of IrLPBaud16(which has a frequency of (UARTCLK frequency)/UARTILP.ILPDVSR), regardless of the selected bit rate.\n\nIn low-power IrDA mode the UART rejects random noise on the received serial data\ninput by ignoring SIRIN pulses that are less than 3 periods of IrLPBaud16.*/\nexport const UART_CTL_SIRLP_EN: any = '1'\n\n/**\nLow-level bits are transmitted as active high with a 3/16th period width,*/\nexport const UART_CTL_SIRLP_DIS: any = '0'\n\n/**\nSIR Enable\n\nThis bit has no effect if UARTEN bit disables the UART.*/\nexport const UART_CTL_SIREN: any = '1'\nexport const UART_CTL_SIREN_M: any = '1'\nexport const UART_CTL_SIREN_S: any = '1'\n/**\nIrDA SIR ENDEC is enabled. Data is transmitted and received via nSIROUT and SIRIN.*/\nexport const UART_CTL_SIREN_EN: any = '1'\n\n/**\nIrDA SIR ENDEC is disabled*/\nexport const UART_CTL_SIREN_DIS: any = '0'\n\n/**\nUART Enable*/\nexport const UART_CTL_UARTEN: any = '1'\nexport const UART_CTL_UARTEN_M: any = '1'\nexport const UART_CTL_UARTEN_S: any = '1'\n/**\nUART enabled*/\nexport const UART_CTL_UARTEN_EN: any = '1'\n\n/**\nUART disabled*/\nexport const UART_CTL_UARTEN_DIS: any = '0'\n\n\n// -------- REGISTER IFLS -------- //\n\n/**\nInterrupt FIFO Level Select*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_IFLS_RESERVED6: any = '26'\nexport const UART_IFLS_RESERVED6_M: any = '26'\nexport const UART_IFLS_RESERVED6_S: any = '26'\n/**\nReceive interrupt FIFO level select:\n\nThis field sets the trigger points for the receive interrupt. Values 0b101-0b111 are reserved.*/\nexport const UART_IFLS_RXSEL: any = '3'\nexport const UART_IFLS_RXSEL_M: any = '3'\nexport const UART_IFLS_RXSEL_S: any = '3'\n/**\nReceive FIFO becomes $gt;= 3/4 full*/\nexport const UART_IFLS_RXSEL_THREEQU: any = '3'\n\n/**\nReceive FIFO becomes $gt;= 1/2 full*/\nexport const UART_IFLS_RXSEL_HALF: any = '2'\n\n/**\nReceive FIFO becomes $gt;= 1/4 full*/\nexport const UART_IFLS_RXSEL_QUARTER: any = '1'\n\n/**\nTransmit interrupt FIFO level select:\n\nThis field sets the trigger points for the transmit interrupt. Values 0b101-0b111 are reserved.*/\nexport const UART_IFLS_TXSEL: any = '3'\nexport const UART_IFLS_TXSEL_M: any = '3'\nexport const UART_IFLS_TXSEL_S: any = '3'\n/**\nTransmit FIFO becomes $lt;= 3/4 full*/\nexport const UART_IFLS_TXSEL_THREEQU: any = '3'\n\n/**\nTransmit FIFO becomes $lt;= 1/2 full*/\nexport const UART_IFLS_TXSEL_HALF: any = '2'\n\n/**\nTransmit FIFO becomes $lt;= 1/4 full*/\nexport const UART_IFLS_TXSEL_QUARTER: any = '1'\n\n\n// -------- REGISTER IMSC -------- //\n\n/**\nInterrupt Mask Set/Clear*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_IMSC_RESERVED14: any = '18'\nexport const UART_IMSC_RESERVED14_M: any = '18'\nexport const UART_IMSC_RESERVED14_S: any = '18'\n/**\nRX DMA done interrupt mask. A read returns the current mask for UART's RXDMADONE interrupt. On a write of 1, the mask of the RXDMADONE interrupt is set which means the interrupt state will be reflected in MIS.RXDMADONE. A write of 0 clears the mask which means MIS.RXDMADONE will not reflect the interrupt.*/\nexport const UART_IMSC_RXDMADONE: any = '1'\nexport const UART_IMSC_RXDMADONE_M: any = '1'\nexport const UART_IMSC_RXDMADONE_S: any = '1'\n/**\nTX DMA done interrupt mask. A read returns the current mask for UART's TXDMADONE interrupt. On a write of 1, the mask of the TXDMADONE interrupt is set which means the interrupt state will be reflected in MIS.TXDMADONE. A write of 0 clears the mask which means MIS.TXDMADONE will not reflect the interrupt.*/\nexport const UART_IMSC_TXDMADONE: any = '1'\nexport const UART_IMSC_TXDMADONE_M: any = '1'\nexport const UART_IMSC_TXDMADONE_S: any = '1'\n/**\nEnd of Transmission interrupt mask. A read returns the current mask for UART's EoT interrupt. On a write of 1, the mask of the EoT interrupt is set which means the interrupt state will be reflected in MIS.EOT. A write of 0 clears the mask which means MIS.EOT will not reflect the interrupt.*/\nexport const UART_IMSC_EOT: any = '1'\nexport const UART_IMSC_EOT_M: any = '1'\nexport const UART_IMSC_EOT_S: any = '1'\n/**\nOverrun error interrupt mask. A read returns the current mask for UART's overrun error interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.OE. A write of 0 clears the mask which means MIS.OE will not reflect the interrupt. */\nexport const UART_IMSC_OE: any = '1'\nexport const UART_IMSC_OE_M: any = '1'\nexport const UART_IMSC_OE_S: any = '1'\n/**\nBreak error interrupt mask. A read returns the current mask for UART's break error interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.BE. A write of 0 clears the mask which means MIS.BE will not reflect the interrupt. */\nexport const UART_IMSC_BE: any = '1'\nexport const UART_IMSC_BE_M: any = '1'\nexport const UART_IMSC_BE_S: any = '1'\n/**\nParity error interrupt mask. A read returns the current mask for UART's parity error interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.PE. A write of 0 clears the mask which means MIS.PE will not reflect the interrupt. */\nexport const UART_IMSC_PE: any = '1'\nexport const UART_IMSC_PE_M: any = '1'\nexport const UART_IMSC_PE_S: any = '1'\n/**\nFraming error interrupt mask. A read returns the current mask for UART's framing error interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.FE. A write of 0 clears the mask which means MIS.FE will not reflect the interrupt. */\nexport const UART_IMSC_FE: any = '1'\nexport const UART_IMSC_FE_M: any = '1'\nexport const UART_IMSC_FE_S: any = '1'\n/**\nReceive timeout interrupt mask. A read returns the current mask for UART's receive timeout interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.RT. A write of 0 clears the mask which means this bitfield will not reflect the interrupt. \n\nThe raw interrupt for receive timeout RIS.RT cannot be set unless the mask is set (RT = 1). This is because the mask acts as an enable for power saving. That is, the same status can be read from MIS.RT and RIS.RT.*/\nexport const UART_IMSC_RT: any = '1'\nexport const UART_IMSC_RT_M: any = '1'\nexport const UART_IMSC_RT_S: any = '1'\n/**\nTransmit interrupt mask. A read returns the current mask for UART's transmit interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.TX. A write of 0 clears the mask which means MIS.TX will not reflect the interrupt. */\nexport const UART_IMSC_TX: any = '1'\nexport const UART_IMSC_TX_M: any = '1'\nexport const UART_IMSC_TX_S: any = '1'\n/**\nReceive interrupt mask. A read returns the current mask for UART's receive interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.RX. A write of 0 clears the mask which means MIS.RX will not reflect the interrupt. */\nexport const UART_IMSC_RX: any = '1'\nexport const UART_IMSC_RX_M: any = '1'\nexport const UART_IMSC_RX_S: any = '1'\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_IMSC_RESERVED2: any = '2'\nexport const UART_IMSC_RESERVED2_M: any = '2'\nexport const UART_IMSC_RESERVED2_S: any = '2'\n/**\nClear to Send (CTS) modem interrupt mask. A read returns the current mask for UART's clear to send interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.CTSM. A write of 0 clears the mask which means MIS.CTSM will not reflect the interrupt. */\nexport const UART_IMSC_CTSM: any = '1'\nexport const UART_IMSC_CTSM_M: any = '1'\nexport const UART_IMSC_CTSM_S: any = '1'\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_IMSC_RESERVED0: any = '1'\nexport const UART_IMSC_RESERVED0_M: any = '1'\nexport const UART_IMSC_RESERVED0_S: any = '1'\n\n// -------- REGISTER RIS -------- //\n\n/**\nRaw Interrupt Status*/\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_RIS_RESERVED14: any = '18'\nexport const UART_RIS_RESERVED14_M: any = '18'\nexport const UART_RIS_RESERVED14_S: any = '18'\n/**\nRX DMA done interrupt status:\n\nThis field returns the raw interrupt state of UART's RX DMA done interrupt. RX DMA done flag is set when you recieve RX DMA done status from dma module.*/\nexport const UART_RIS_RXDMADONE: any = '1'\nexport const UART_RIS_RXDMADONE_M: any = '1'\nexport const UART_RIS_RXDMADONE_S: any = '1'\n/**\nTX DMA done interrupt status:\n\nThis field returns the raw interrupt state of UART's TX DMA done interrupt. TX DMA done flag is set when you recieve TX DMA done status from dma module.*/\nexport const UART_RIS_TXDMADONE: any = '1'\nexport const UART_RIS_TXDMADONE_M: any = '1'\nexport const UART_RIS_TXDMADONE_S: any = '1'\n/**\nEnd of Transmission interrupt status:\n\nThis field returns the raw interrupt state of UART's end of transmission interrupt. End of transmission flag is set when all the Transmit data in the FIFO and on the TX Line is tranmitted.*/\nexport const UART_RIS_EOT: any = '1'\nexport const UART_RIS_EOT_M: any = '1'\nexport const UART_RIS_EOT_S: any = '1'\n/**\nOverrun error interrupt status: \n\nThis field returns the raw interrupt state of UART's overrun error interrupt. Overrun error occurs if data is received and the receive FIFO is full.*/\nexport const UART_RIS_OE: any = '1'\nexport const UART_RIS_OE_M: any = '1'\nexport const UART_RIS_OE_S: any = '1'\n/**\nBreak error interrupt status:\n\nThis field returns the raw interrupt state of UART's break error interrupt. Break error is set when a break condition is detected, indicating that the received data input (UARTRXD input pin) was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits).*/\nexport const UART_RIS_BE: any = '1'\nexport const UART_RIS_BE_M: any = '1'\nexport const UART_RIS_BE_S: any = '1'\n/**\nParity error interrupt status:\n\nThis field returns the raw interrupt state of UART's parity error interrupt. Parity error is set if the parity of the received data character does not match the parity that the LCRH.EPS and LCRH.SPS select.*/\nexport const UART_RIS_PE: any = '1'\nexport const UART_RIS_PE_M: any = '1'\nexport const UART_RIS_PE_S: any = '1'\n/**\nFraming error interrupt status:\n\nThis field returns the raw interrupt state of UART's framing error interrupt. Framing error is set if the received character does not have a valid stop bit (a valid stop bit is 1).*/\nexport const UART_RIS_FE: any = '1'\nexport const UART_RIS_FE_M: any = '1'\nexport const UART_RIS_FE_S: any = '1'\n/**\nReceive timeout interrupt status:\n\nThis field returns the raw interrupt state of UART's receive timeout interrupt. The receive timeout interrupt is asserted when the receive FIFO is not empty, and no more data is received during a 32-bit period. The receive timeout interrupt is cleared either when the FIFO becomes empty through reading all the data, or when a 1 is written to ICR.RT.\nThe raw interrupt for receive timeout cannot be set unless the mask is set (IMSC.RT = 1). This is because the mask acts as an enable for power saving. That is, the same status can be read from MIS.RT and RT.*/\nexport const UART_RIS_RT: any = '1'\nexport const UART_RIS_RT_M: any = '1'\nexport const UART_RIS_RT_S: any = '1'\n/**\nTransmit interrupt status: \n\nThis field returns the raw interrupt state of UART's transmit interrupt.\nWhen FIFOs are enabled (LCRH.FEN = 1), the transmit interrupt is asserted if the number of bytes in transmit FIFO is equal to or lower than the programmed trigger level (IFLS.TXSEL). The transmit interrupt is cleared by writing data to the transmit FIFO until it becomes greater than the trigger level, or by clearing the interrupt through ICR.TX.\nWhen FIFOs are disabled (LCRH.FEN = 0), that is they have a depth of one location, the transmit interrupt is asserted if there is no data present in the transmitters single location. It is cleared by performing a single write to the transmit FIFO, or by clearing the interrupt through ICR.TX.*/\nexport const UART_RIS_TX: any = '1'\nexport const UART_RIS_TX_M: any = '1'\nexport const UART_RIS_TX_S: any = '1'\n/**\nReceive interrupt status:\n\nThis field returns the raw interrupt state of UART's receive interrupt. \nWhen FIFOs are enabled (LCRH.FEN = 1), the receive interrupt is asserted if the receive FIFO reaches the programmed trigger\nlevel (IFLS.RXSEL). The receive interrupt is cleared by reading data from the receive FIFO until it becomes less than the trigger level, or by clearing the interrupt through ICR.RX.\nWhen FIFOs are disabled (LCRH.FEN = 0), that is they have a depth of one location, the receive interrupt is asserted if data is received\nthereby filling the location. The receive interrupt is cleared by performing a single read of the receive FIFO, or by clearing the interrupt through ICR.RX.*/\nexport const UART_RIS_RX: any = '1'\nexport const UART_RIS_RX_M: any = '1'\nexport const UART_RIS_RX_S: any = '1'\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_RIS_RESERVED2: any = '2'\nexport const UART_RIS_RESERVED2_M: any = '2'\nexport const UART_RIS_RESERVED2_S: any = '2'\n/**\nClear to Send (CTS) modem interrupt status: \n\nThis field returns the raw interrupt state of UART's clear to send interrupt.*/\nexport const UART_RIS_CTSM: any = '1'\nexport const UART_RIS_CTSM_M: any = '1'\nexport const UART_RIS_CTSM_S: any = '1'\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_RIS_RESERVED0: any = '1'\nexport const UART_RIS_RESERVED0_M: any = '1'\nexport const UART_RIS_RESERVED0_S: any = '1'\n\n// -------- REGISTER MIS -------- //\n\n/**\nMasked Interrupt Status*/\n/**\n    Reads to this field return zero, writes to this field are ignored. Read as zero, do not modify*/\nexport const UART_MIS_RESERVED14: any = '18'\nexport const UART_MIS_RESERVED14_M: any = '18'\nexport const UART_MIS_RESERVED14_S: any = '18'\n/**\nRX DMA done interrupt status:\n\nThis field returns the masked interrupt state of the RX DMA done interrupt which is the bitiwse AND product of raw interrupt state RIS.RXDMADONE and the mask setting IMSC.RXDMADONE.*/\nexport const UART_MIS_RXDMADONE: any = '1'\nexport const UART_MIS_RXDMADONE_M: any = '1'\nexport const UART_MIS_RXDMADONE_S: any = '1'\n/**\nTX DMA done interrupt status:\n\nThis field returns the masked interrupt state of the TX DMA done interrupt which is the bitwise AND product of raw interrupt state RIS.TXDMADONE and the mask setting IMSC.TXDMADONE.*/\nexport const UART_MIS_TXDMADONE: any = '1'\nexport const UART_MIS_TXDMADONE_M: any = '1'\nexport const UART_MIS_TXDMADONE_S: any = '1'\n/**\nEnd of Transmission interrupt status:\n\nThis field returns the masked interrupt state of the End of transmission interrupt which is the bitwise AND product of raw interrupt state RIS.EOT and the mask setting IMSC.EOT.*/\nexport const UART_MIS_EOT: any = '1'\nexport const UART_MIS_EOT_M: any = '1'\nexport const UART_MIS_EOT_S: any = '1'\n/**\nOverrun error masked interrupt status: \n\nThis field returns the masked interrupt state of the overrun interrupt which is the bitwise AND product of raw interrupt state RIS.OE and the mask setting IMSC.OE.*/\nexport const UART_MIS_OE: any = '1'\nexport const UART_MIS_OE_M: any = '1'\nexport const UART_MIS_OE_S: any = '1'\n/**\nBreak error masked interrupt status: \n\nThis field returns the masked interrupt state of the break error interrupt which is the bitiwse AND product of raw interrupt state RIS.BE and the mask setting IMSC.BE.*/\nexport const UART_MIS_BE: any = '1'\nexport const UART_MIS_BE_M: any = '1'\nexport const UART_MIS_BE_S: any = '1'\n/**\nParity error masked interrupt status:\n\nThis field returns the masked interrupt state of the parity error interrupt which is the bitiwise AND product of raw interrupt state RIS.PE and the mask setting IMSC.PE.*/\nexport const UART_MIS_PE: any = '1'\nexport const UART_MIS_PE_M: any = '1'\nexport const UART_MIS_PE_S: any = '1'\n/**\nFraming error masked interrupt status: Returns the masked interrupt state of the framing error interrupt which is the bitiwse AND product of raw interrupt state RIS.FE and the mask setting IMSC.FE.*/\nexport const UART_MIS_FE: any = '1'\nexport const UART_MIS_FE_M: any = '1'\nexport const UART_MIS_FE_S: any = '1'\n/**\nReceive timeout masked interrupt status: \n\nReturns the masked interrupt state of the receive timeout interrupt.\nThe raw interrupt for receive timeout cannot be set unless the mask is set (IMSC.RT = 1). This is because the mask acts as an enable for power saving. That is, the same status can be read from MIS.RT and RIS.RT.*/\nexport const UART_MIS_RT: any = '1'\nexport const UART_MIS_RT_M: any = '1'\nexport const UART_MIS_RT_S: any = '1'\n/**\nTransmit masked interrupt status: \n\nThis field returns the masked interrupt state of the transmit interrupt  which is the bitiwse AND product of raw interrupt state RIS.TX and the mask setting IMSC.TX.*/\nexport const UART_MIS_TX: any = '1'\nexport const UART_MIS_TX_M: any = '1'\nexport const UART_MIS_TX_S: any = '1'\n/**\nReceive masked interrupt status:\n\nThis field returns the masked interrupt state of the receive interrupt  which is the bitwise AND product of raw interrupt state RIS.RX and the mask setting IMSC.RX.*/\nexport const UART_MIS_RX: any = '1'\nexport const UART_MIS_RX_M: any = '1'\nexport const UART_MIS_RX_S: any = '1'\n/**\n    Reads to this field return zero, writes to this field are ignored.*/\nexport const UART_MIS_RESERVED2: any = '2'\nexport const UART_MIS_RESERVED2_M: any = '2'\nexport const UART_MIS_RESERVED2_S: any = '2'\n/**\nClear to Send (CTS) modem masked interrupt status:\n\nThis field returns the masked interrupt state of the clear to send interrupt which is the bitwise AND product of raw interrupt state RIS.CTS and the mask setting IMSC.CTS.*/\nexport const UART_MIS_CTSM: any = '1'\nexport const UART_MIS_CTSM_M: any = '1'\nexport const UART_MIS_CTSM_S: any = '1'\n/**\n    Reads to this field return zero, writes to this field are ignored. Write 0.*/\nexport const UART_MIS_RESERVED0: any = '1'\nexport const UART_MIS_RESERVED0_M: any = '1'\nexport const UART_MIS_RESERVED0_S: any = '1'\n\n// -------- REGISTER ICR -------- //\n\n/**\nInterrupt Clear\n\nOn a write of 1, the corresponding interrupt is cleared. A write of 0 has no effect.*/\n/**\n    Reads to this field return zero, writes to this field are ignored. Read as zero, do not modify*/\nexport const UART_ICR_RESERVED16: any = '18'\nexport const UART_ICR_RESERVED16_M: any = '18'\nexport const UART_ICR_RESERVED16_S: any = '18'\n/**\nRX DMA Done interrupt clear:\n\nWriting 1 to this field clears the RX DMA done interrupt (RIS.RXDMADONE). Writing 0 has no effect.*/\nexport const UART_ICR_RXDMADONE: any = '1'\nexport const UART_ICR_RXDMADONE_M: any = '1'\nexport const UART_ICR_RXDMADONE_S: any = '1'\n/**\nTX DMA Done interrupt clear:\n\nWriting 1 to this field clears the TX DMA done interrupt (RIS.TXDMADONE). Writing 0 has no effect.*/\nexport const UART_ICR_TXDMADONE: any = '1'\nexport const UART_ICR_TXDMADONE_M: any = '1'\nexport const UART_ICR_TXDMADONE_S: any = '1'\n/**\nEnd of Transmission interrupt clear:\n\nWriting 1 to this field clears the End of Transmission interrupt (RIS.EOT). Writing 0 has no effect.*/\nexport const UART_ICR_EOT: any = '1'\nexport const UART_ICR_EOT_M: any = '1'\nexport const UART_ICR_EOT_S: any = '1'\n/**\nOverrun error interrupt clear:\n\nWriting 1 to this field clears the overrun error interrupt (RIS.OE). Writing 0 has no effect.*/\nexport const UART_ICR_OE: any = '1'\nexport const UART_ICR_OE_M: any = '1'\nexport const UART_ICR_OE_S: any = '1'\n/**\nBreak error interrupt clear:\n\nWriting 1 to this field clears the break error interrupt (RIS.BE). Writing 0 has no effect.*/\nexport const UART_ICR_BE: any = '1'\nexport const UART_ICR_BE_M: any = '1'\nexport const UART_ICR_BE_S: any = '1'\n/**\nParity error interrupt clear:\n\nWriting 1 to this field clears the parity error interrupt (RIS.PE). Writing 0 has no effect.*/\nexport const UART_ICR_PE: any = '1'\nexport const UART_ICR_PE_M: any = '1'\nexport const UART_ICR_PE_S: any = '1'\n/**\nFraming error interrupt clear:\n\nWriting 1 to this field clears the framing error interrupt (RIS.FE). Writing 0 has no effect.*/\nexport const UART_ICR_FE: any = '1'\nexport const UART_ICR_FE_M: any = '1'\nexport const UART_ICR_FE_S: any = '1'\n/**\nReceive timeout interrupt clear:\n\nWriting 1 to this field clears the receive timeout interrupt (RIS.RT). Writing 0 has no effect.*/\nexport const UART_ICR_RT: any = '1'\nexport const UART_ICR_RT_M: any = '1'\nexport const UART_ICR_RT_S: any = '1'\n/**\nTransmit interrupt clear:\n\nWriting 1 to this field clears the transmit interrupt (RIS.TX). Writing 0 has no effect.*/\nexport const UART_ICR_TX: any = '1'\nexport const UART_ICR_TX_M: any = '1'\nexport const UART_ICR_TX_S: any = '1'\n/**\nReceive interrupt clear:\n\nWriting 1 to this field clears the receive interrupt (RIS.RX). Writing 0 has no effect.*/\nexport const UART_ICR_RX: any = '1'\nexport const UART_ICR_RX_M: any = '1'\nexport const UART_ICR_RX_S: any = '1'\n/**\n    Reads to this field return zero, writes to this field are ignored. Write 0*/\nexport const UART_ICR_RESERVED2: any = '2'\nexport const UART_ICR_RESERVED2_M: any = '2'\nexport const UART_ICR_RESERVED2_S: any = '2'\n/**\nClear to Send (CTS) modem interrupt clear:\n\nWriting 1 to this field clears the clear to send interrupt (RIS.CTS). Writing 0 has no effect.*/\nexport const UART_ICR_CTSM: any = '1'\nexport const UART_ICR_CTSM_M: any = '1'\nexport const UART_ICR_CTSM_S: any = '1'\n/**\n    Reads to this field return zero, writes to this field are ignored. Write 0.*/\nexport const UART_ICR_RESERVED0: any = '1'\nexport const UART_ICR_RESERVED0_M: any = '1'\nexport const UART_ICR_RESERVED0_S: any = '1'\n\n// -------- REGISTER DMACTL -------- //\n\n/**\nDMA Control*/\n/**\n    Reads to this field return zero, writes to this field are ignored. Read as zero, do not modify.*/\nexport const UART_DMACTL_RESERVED3: any = '29'\nexport const UART_DMACTL_RESERVED3_M: any = '29'\nexport const UART_DMACTL_RESERVED3_S: any = '29'\n/**\nDMA on error. If this bit is set to 1, the DMA receive request outputs (for  single and burst requests) are disabled when the UART error interrupt is asserted (more specifically if any of the error interrupts RIS.PERIS, RIS.BERIS, RIS.FERIS or RIS.OERIS are asserted).*/\nexport const UART_DMACTL_DMAONERR: any = '1'\nexport const UART_DMACTL_DMAONERR_M: any = '1'\nexport const UART_DMACTL_DMAONERR_S: any = '1'\n/**\nTransmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.*/\nexport const UART_DMACTL_TXDMAE: any = '1'\nexport const UART_DMACTL_TXDMAE_M: any = '1'\nexport const UART_DMACTL_TXDMAE_S: any = '1'\n/**\nReceive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.*/\nexport const UART_DMACTL_RXDMAE: any = '1'\nexport const UART_DMACTL_RXDMAE_M: any = '1'\nexport const UART_DMACTL_RXDMAE_S: any = '1'\n\n// -------- REGISTER RESERVED1 -------- //\n\n/**\nUART Reserved Area*/\n/**\n    Reads to this field return zero, writes to this field are ignored. Read as zero, do not modify.*/\nexport const UART_RESERVED1_RESERVED: any = '32'\nexport const UART_RESERVED1_RESERVED_M: any = '32'\nexport const UART_RESERVED1_RESERVED_S: any = '32'\n\n// -------- REGISTER RESERVED3 -------- //\n\n/**\nUART Reserved Area*/\n/**\n    Reads to this field return zero, writes to this field are ignored. */\nexport const UART_RESERVED3_RESERVED: any = '32'\nexport const UART_RESERVED3_RESERVED_M: any = '32'\nexport const UART_RESERVED3_RESERVED_S: any = '32'\n\n// -------- REGISTER RESERVED4 -------- //\n\n/**\nUART Reserved Area For Future ID Expansion*/\n/**\n    Reads to this field return zero, writes to this field are ignored. */\nexport const UART_RESERVED4_RESERVED: any = '32'\nexport const UART_RESERVED4_RESERVED_M: any = '32'\nexport const UART_RESERVED4_RESERVED_S: any = '32'\n\n// -------- MODULE VIMS -------- //\n\nexport interface VIMS_t {\n    DESC: em.$Reg\n    DESCEX: em.$Reg\n    FLWS1T: em.$Reg\n    FLWS2T: em.$Reg\n    PTRMC0: em.$Reg\n    B0TRMC1: em.$Reg\n    B0TRMC0: em.$Reg\n    FLBLCK: em.$Reg\n    CFG: em.$Reg\n    WEPRA: em.$Reg\n    WEPRB: em.$Reg\n    WEPRAUX: em.$Reg\n    FLBSTAT: em.$Reg\n    CCHCTRL: em.$Reg\n}\n\n// -------- REGISTER DESC -------- //\n\n/**\nDescription Register. This register provides IP module ID, revision information, instance index and standard MMR registers offset.*/\n/**\nModule identifier used to uniquely identify this IP.*/\nexport const VIMS_DESC_MODID: any = '16'\nexport const VIMS_DESC_MODID_M: any = '16'\nexport const VIMS_DESC_MODID_S: any = '16'\n/**\nStandard IP MMR block offset. Standard IP MMRs are the set of from aggregated IRQ registers till DTB.\n\n\n0: Standard IP MMRs do not exist\n\n0x1-0xF: Standard IP MMRs begin at offset of (64*STDIPOFF from the base IP address)*/\nexport const VIMS_DESC_STDIPOFF: any = '4'\nexport const VIMS_DESC_STDIPOFF_M: any = '4'\nexport const VIMS_DESC_STDIPOFF_S: any = '4'\n/**\nIP Instance ID number. If multiple instances of IP exist in the device, this field can identify the instance number (0-15).*/\nexport const VIMS_DESC_INSTIDX: any = '4'\nexport const VIMS_DESC_INSTIDX_M: any = '4'\nexport const VIMS_DESC_INSTIDX_S: any = '4'\n/**\nMajor revision of IP (0-15).*/\nexport const VIMS_DESC_MAJREV: any = '4'\nexport const VIMS_DESC_MAJREV_M: any = '4'\nexport const VIMS_DESC_MAJREV_S: any = '4'\n/**\nMinor revision of IP (0-15).*/\nexport const VIMS_DESC_MINREV: any = '4'\nexport const VIMS_DESC_MINREV_M: any = '4'\nexport const VIMS_DESC_MINREV_S: any = '4'\n\n// -------- REGISTER DESCEX -------- //\n\n/**\nExtended Description Register. This register provides configuration details of the IP to software drivers and end users.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const VIMS_DESCEX_RESERVED28: any = '4'\nexport const VIMS_DESCEX_RESERVED28_M: any = '4'\nexport const VIMS_DESCEX_RESERVED28_S: any = '4'\n/**\nProvides the FLASH Bank count*/\nexport const VIMS_DESCEX_NBANK: any = '1'\nexport const VIMS_DESCEX_NBANK_M: any = '1'\nexport const VIMS_DESCEX_NBANK_S: any = '1'\n/**\nThis provides the total FLASH size in Kilo Bytes. The total FLASH size is (FLSZ + 1)KB*/\nexport const VIMS_DESCEX_FLSZ: any = '12'\nexport const VIMS_DESCEX_FLSZ_M: any = '12'\nexport const VIMS_DESCEX_FLSZ_S: any = '12'\n/**\nProvides the size of ROM in Bytes.*/\nexport const VIMS_DESCEX_ROMSZ: any = '15'\nexport const VIMS_DESCEX_ROMSZ_M: any = '15'\nexport const VIMS_DESCEX_ROMSZ_S: any = '15'\n\n// -------- REGISTER FLWS1T -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS1T_RESERVED3: any = '29'\nexport const VIMS_FLWS1T_RESERVED3_M: any = '29'\nexport const VIMS_FLWS1T_RESERVED3_S: any = '29'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS1T_VAL: any = '3'\nexport const VIMS_FLWS1T_VAL_M: any = '3'\nexport const VIMS_FLWS1T_VAL_S: any = '3'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS1T_VAL_WS7: any = '7'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS1T_VAL_WS6: any = '6'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS1T_VAL_WS5: any = '5'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS1T_VAL_WS4: any = '4'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS1T_VAL_WS3: any = '3'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS1T_VAL_WS2: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS1T_VAL_WS1: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS1T_VAL_WS0: any = '0'\n\n\n// -------- REGISTER FLWS2T -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS2T_RESERVED3: any = '29'\nexport const VIMS_FLWS2T_RESERVED3_M: any = '29'\nexport const VIMS_FLWS2T_RESERVED3_S: any = '29'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS2T_VAL: any = '3'\nexport const VIMS_FLWS2T_VAL_M: any = '3'\nexport const VIMS_FLWS2T_VAL_S: any = '3'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS2T_VAL_WS7: any = '7'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS2T_VAL_WS6: any = '6'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS2T_VAL_WS5: any = '5'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS2T_VAL_WS4: any = '4'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS2T_VAL_WS3: any = '3'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS2T_VAL_WS2: any = '2'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS2T_VAL_WS1: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLWS2T_VAL_WS0: any = '0'\n\n\n// -------- REGISTER PTRMC0 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_PTRMC0_VAL: any = '32'\nexport const VIMS_PTRMC0_VAL_M: any = '32'\nexport const VIMS_PTRMC0_VAL_S: any = '32'\n\n// -------- REGISTER B0TRMC1 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_B0TRMC1_VAL: any = '32'\nexport const VIMS_B0TRMC1_VAL_M: any = '32'\nexport const VIMS_B0TRMC1_VAL_S: any = '32'\n\n// -------- REGISTER B0TRMC0 -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_B0TRMC0_VAL: any = '32'\nexport const VIMS_B0TRMC0_VAL_M: any = '32'\nexport const VIMS_B0TRMC0_VAL_S: any = '32'\n\n// -------- REGISTER FLBLCK -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLBLCK_RESERVED1: any = '31'\nexport const VIMS_FLBLCK_RESERVED1_M: any = '31'\nexport const VIMS_FLBLCK_RESERVED1_S: any = '31'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLBLCK_VAL: any = '1'\nexport const VIMS_FLBLCK_VAL_M: any = '1'\nexport const VIMS_FLBLCK_VAL_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLBLCK_VAL_BLOCK: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_FLBLCK_VAL_ALLOW: any = '0'\n\n\n// -------- REGISTER CFG -------- //\n\n/**\nInternal. Only to be used through TI provided API.*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const VIMS_CFG_RESERVED2: any = '30'\nexport const VIMS_CFG_RESERVED2_M: any = '30'\nexport const VIMS_CFG_RESERVED2_S: any = '30'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_CFG_TRMVLID: any = '1'\nexport const VIMS_CFG_TRMVLID_M: any = '1'\nexport const VIMS_CFG_TRMVLID_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_CFG_WEPRTRM: any = '1'\nexport const VIMS_CFG_WEPRTRM_M: any = '1'\nexport const VIMS_CFG_WEPRTRM_S: any = '1'\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_CFG_WEPRTRM_ALLOW: any = '1'\n\n/**\nInternal. Only to be used through TI provided API.*/\nexport const VIMS_CFG_WEPRTRM_RESTRICT: any = '0'\n\n\n// -------- REGISTER WEPRA -------- //\n\n/**\nFlash main region write/erase protection for first 32 sectors. Nth bit corresponds to the Nth sector. This register is sticky when written with value 0.\n\n*/\n/**\nFlash write/erase protection configuration value.*/\nexport const VIMS_WEPRA_VAL: any = '32'\nexport const VIMS_WEPRA_VAL_M: any = '32'\nexport const VIMS_WEPRA_VAL_S: any = '32'\n\n// -------- REGISTER WEPRB -------- //\n\n/**\nFlash main region write/erase protection for remaining sectors. Each bit corresponds to 8 sectors. Bit 0 corresponds to sector 32-39, bit 1 corresponds to sector 40-47 and so on. This register is sticky when written with value 0.\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const VIMS_WEPRB_RESERVED28: any = '4'\nexport const VIMS_WEPRB_RESERVED28_M: any = '4'\nexport const VIMS_WEPRB_RESERVED28_S: any = '4'\n/**\nFlash write/erase protection configuration value.*/\nexport const VIMS_WEPRB_VAL: any = '28'\nexport const VIMS_WEPRB_VAL_M: any = '28'\nexport const VIMS_WEPRB_VAL_S: any = '28'\n\n// -------- REGISTER WEPRAUX -------- //\n\n/**\nFlash Write/Erase  protection for Non-Main, TRIM and ENGR Regions. This register is sticky when written with value 0.\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const VIMS_WEPRAUX_RESERVED3: any = '29'\nexport const VIMS_WEPRAUX_RESERVED3_M: any = '29'\nexport const VIMS_WEPRAUX_RESERVED3_S: any = '29'\n/**\nFlash engr region write/erase protection configuration value.*/\nexport const VIMS_WEPRAUX_WEPREGR: any = '1'\nexport const VIMS_WEPRAUX_WEPREGR_M: any = '1'\nexport const VIMS_WEPRAUX_WEPREGR_S: any = '1'\n/**\nFlash trim region write/erase protection configuration value.*/\nexport const VIMS_WEPRAUX_WEPRTRM: any = '1'\nexport const VIMS_WEPRAUX_WEPRTRM_M: any = '1'\nexport const VIMS_WEPRAUX_WEPRTRM_S: any = '1'\n/**\nFlash non main region write/erase protection configuration value.*/\nexport const VIMS_WEPRAUX_WEPRNMN: any = '1'\nexport const VIMS_WEPRAUX_WEPRNMN_M: any = '1'\nexport const VIMS_WEPRAUX_WEPRNMN_S: any = '1'\n\n// -------- REGISTER FLBSTAT -------- //\n\n/**\nThis register is used to indicate status of flash. This register is not retained.\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const VIMS_FLBSTAT_RESERVED4: any = '28'\nexport const VIMS_FLBSTAT_RESERVED4_M: any = '28'\nexport const VIMS_FLBSTAT_RESERVED4_S: any = '28'\n/**\nThis bit indicates parity error on write/erase and read protection MMRs. This bit is sticky when set to 1 by hardware.*/\nexport const VIMS_FLBSTAT_PARERR: any = '1'\nexport const VIMS_FLBSTAT_PARERR_M: any = '1'\nexport const VIMS_FLBSTAT_PARERR_S: any = '1'\n/**\nError*/\nexport const VIMS_FLBSTAT_PARERR_ERROR: any = '1'\n\n/**\nNo Error*/\nexport const VIMS_FLBSTAT_PARERR_NOERROR: any = '0'\n\n/**\nThis bit indicates if flash is busy.*/\nexport const VIMS_FLBSTAT_B0BSY: any = '1'\nexport const VIMS_FLBSTAT_B0BSY_M: any = '1'\nexport const VIMS_FLBSTAT_B0BSY_S: any = '1'\n/**\nBusy*/\nexport const VIMS_FLBSTAT_B0BSY_BUSY: any = '1'\n\n/**\nIdle*/\nexport const VIMS_FLBSTAT_B0BSY_IDLE: any = '0'\n\n/**\nThis bit indicates if flash is ready in 2T mode.*/\nexport const VIMS_FLBSTAT_B2TRDY: any = '1'\nexport const VIMS_FLBSTAT_B2TRDY_M: any = '1'\nexport const VIMS_FLBSTAT_B2TRDY_S: any = '1'\n/**\nReady*/\nexport const VIMS_FLBSTAT_B2TRDY_READY: any = '1'\n\n/**\nNot Ready*/\nexport const VIMS_FLBSTAT_B2TRDY_NOTREADY: any = '0'\n\n/**\nThis bit indicates if flash is ready in 1T mode.*/\nexport const VIMS_FLBSTAT_B1TRDY: any = '1'\nexport const VIMS_FLBSTAT_B1TRDY_M: any = '1'\nexport const VIMS_FLBSTAT_B1TRDY_S: any = '1'\n/**\nReady*/\nexport const VIMS_FLBSTAT_B1TRDY_READY: any = '1'\n\n/**\nNot Ready*/\nexport const VIMS_FLBSTAT_B1TRDY_NOTREADY: any = '0'\n\n\n// -------- REGISTER CCHCTRL -------- //\n\n/**\nThis register is used for enabling cache, prefetch and micropredictor units.\n\n*/\n/**\nSoftware should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.*/\nexport const VIMS_CCHCTRL_RESERVED3: any = '29'\nexport const VIMS_CCHCTRL_RESERVED3_M: any = '29'\nexport const VIMS_CCHCTRL_RESERVED3_S: any = '29'\n/**\nThis bit is used to enable the micropredictor unit.*/\nexport const VIMS_CCHCTRL_CCHMPEN: any = '1'\nexport const VIMS_CCHCTRL_CCHMPEN_M: any = '1'\nexport const VIMS_CCHCTRL_CCHMPEN_S: any = '1'\n/**\nEnable*/\nexport const VIMS_CCHCTRL_CCHMPEN_EN: any = '1'\n\n/**\nDisable*/\nexport const VIMS_CCHCTRL_CCHMPEN_DIS: any = '0'\n\n/**\nThis bit is used to enable the prefetch unit.*/\nexport const VIMS_CCHCTRL_CCHPFEN: any = '1'\nexport const VIMS_CCHCTRL_CCHPFEN_M: any = '1'\nexport const VIMS_CCHCTRL_CCHPFEN_S: any = '1'\n/**\nEnable*/\nexport const VIMS_CCHCTRL_CCHPFEN_EN: any = '1'\n\n/**\nDisable*/\nexport const VIMS_CCHCTRL_CCHPFEN_DIS: any = '0'\n\n/**\nThis bit is used to enable the cache.*/\nexport const VIMS_CCHCTRL_CCHEN: any = '1'\nexport const VIMS_CCHCTRL_CCHEN_M: any = '1'\nexport const VIMS_CCHCTRL_CCHEN_S: any = '1'\n/**\nEnable*/\nexport const VIMS_CCHCTRL_CCHEN_EN: any = '1'\n\n/**\nDisable*/\nexport const VIMS_CCHCTRL_CCHEN_DIS: any = '0'\n\n\n// -------- INSTANCES -------- //\n\nexport const PMCTL = {} as PMCTL_t\nexport const CKMD = {} as CKMD_t\nexport const RTC = {} as RTC_t\nexport const IOC = {} as IOC_t\nexport const EVTULL = {} as EVTULL_t\nexport const CLKCTL = {} as CLKCTL_t\nexport const GPIO = {} as GPIO_t\nexport const VIMS = {} as VIMS_t\nexport const EVTSVT = {} as EVTSVT_t\nexport const UART0 = {} as UART_t\nexport const LGPT3 = {} as LGPT3_t\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.distro.cc23xx/StartupC/","title":"StartupC","text":"ti.distro.cc23xx/StartupC.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('COMPOSITE')\n\nexport function em$generate() {\n    let out = $outfile('ti.distro.cc23xx/startup.cpp')\n    out.addFrag(`\n        |-&gt; #include &lt;stdbool.h&gt;\n        |-&gt; #include &lt;stdint.h&gt;\n        |-&gt; \n        |-&gt; #include \"../em.arch.arm/intr.cpp\"\n        |-&gt; #include \"../em.arch.arm/startup.cpp\"\n        |-&gt; \n        |-&gt; extern void em_main();\n        |-&gt; \n        |-&gt; extern \"C\" bool __is_warm() {\n        |-&gt;     return false;\n        |-&gt; }\n        |-&gt; \n        |-&gt; extern const uint32_t __ccfg[] __attribute__((section(\".ccfg\"), used)) = {\n        |-&gt;     0xFFFFFFFF, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0xFFFFFFFF, 0xFFFFFFFF, 0xAAAAAAAA, 0x0000000F,\n        |-&gt;     0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        |-&gt;     0x0000A55A, 0x03020101, 0x150D0805, 0x36E4D76D,\n        |-&gt;     0xDF31F4EB, 0xEE15AE95, 0xE48EBA03, 0xD83FC6C4,\n        |-&gt;     0x5E673F45, 0x01C2D774, 0xE558902C, 0x00000000,\n        |-&gt; };\n    `)\n    out.close()\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/","title":"Index","text":""},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/#bundletimcucc23xx","title":"<code>bundle</code> <code>ti.mcu.cc23xx</code>","text":""},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/BusyWait/","title":"BusyWait","text":"ti.mcu.cc23xx/BusyWait.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nexport const scalar = $config&lt;u8&gt;(3)\n\nexport function wait(usecs: u32): void {\n    if (usecs == 0) return\n    var cnt = usecs * scalar.$$\n    var dummy: volatile_t&lt;u32&gt;\n    while (cnt--) dummy = 0\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/ConsoleUart0/","title":"ConsoleUart0","text":"ti.mcu.cc23xx/ConsoleUart0.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as GpioI from '@em.hal/GpioI.em'\nimport * as Idle from '@ti.mcu.cc23xx/Idle.em'\n\nexport const TxPin = $proxy&lt;GpioI.$I&gt;()\n\nexport namespace em$meta {\n\n    export function em$configure() {\n        Idle.em$meta.addSleepEnter($cb(sleepEnter))\n        Idle.em$meta.addSleepLeave($cb(sleepLeave))\n    }\n}\n\nexport function em$startup(): void {\n    sleepLeave()\n}\n\nexport function flush(): void {\n    while ($R.UART0.FR.$$ &amp; $R.UART_FR_BUSY) {}\n}\n\nexport function put(data: u8): void {\n    $R.UART0.DR.$$ = data\n    flush()\n}\n\nfunction sleepEnter() {\n    $R.CLKCTL.CLKENCLR0.$$ = $R.CLKCTL_CLKENCLR0_UART0\n    TxPin.$$.reset()\n}\n\nfunction sleepLeave() {\n    $R.CLKCTL.CLKENSET0.$$ = $R.CLKCTL_CLKENSET0_UART0\n    TxPin.$$.makeOutput()\n    TxPin.$$.set()\n    TxPin.$$.functionSelect(2)\n    $R.UART0.CTL.$$ &amp;= ~$R.UART_CTL_UARTEN\n    $R.UART0.IBRD.$$ = 26\n    $R.UART0.FBRD.$$ = 3\n    $R.UART0.LCRH.$$ = $R.UART_LCRH_WLEN_BITL8\n    $R.UART0.CTL.$$ |= $R.UART_CTL_UARTEN\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/EdgeAux/","title":"EdgeAux","text":"ti.mcu.cc23xx/EdgeAux.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as EdgeI from '@em.hal/EdgeI.em'\nimport * as IntrVec from '@em.arch.arm/IntrVec.em'\n\nexport class HandlerInfo extends $struct {\n    handler: EdgeI.Handler\n    mask: u32\n}\n\nlet handler_info_tab = $table&lt;HandlerInfo&gt;('ro')\n\nexport namespace em$meta {\n\n    export function em$construct() {\n        IntrVec.em$meta.useIntr('GPIO_COMB')\n    }\n\n    export function addHandlerInfo(hi: HandlerInfo) {\n        handler_info_tab.$add(hi)\n    }\n}\n\nexport function em$startup() {\n    IntrVec.NVIC_enable(e$`GPIO_COMB_IRQn`)\n}\n\nexport function GPIO_COMB_isr$$() {\n    let mis = $R.GPIO.MIS.$$\n    for (let i = 0; i &lt; handler_info_tab.$len; i++) {\n        let hi = $ref(handler_info_tab[i])\n        if ((mis &amp; hi.$$.mask) &amp;&amp; hi.$$.handler != $null) {\n            hi.$$.handler()\n        }\n    }\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/EdgeT/","title":"EdgeT","text":"ti.mcu.cc23xx/EdgeT.em<pre><code>import em from '@$$emscript'\nexport const $T = em.$declare('TEMPLATE')\n\nimport * as Aux from '@ti.mcu.cc23xx/EdgeAux.em'\nimport * as EdgeI from '@em.hal/EdgeI.em'\nimport * as GpioI from '@em.hal/GpioI.em'\n\nexport namespace em$template {\n\n    export const $U = em.$declare('MODULE')\n\n    export const Pin = $proxy&lt;GpioI.$I&gt;()\n    export const pin_num = $config&lt;i16&gt;()\n\n    export namespace em$meta {\n\n        export function setDetectHandler(h: EdgeI.Handler) {\n            let hi = Aux.HandlerInfo.$make()\n            hi.handler = h\n            hi.mask = 1 &lt;&lt; pin_num.$$\n            Aux.em$meta.addHandlerInfo(hi)\n        }\n    }\n\n    const pn = pin_num.$$\n    const mask = 1 &lt;&lt; pn\n\n    export function clearDetect(): void {\n        $R.GPIO.ICLR.$$ = mask\n    }\n\n    export function disableDetect(): void {\n        $R.GPIO.IMCLR.$$ = mask\n        $R.IOC.IOC0.$[pn].$$ &amp;= ~$R.IOC_IOC0_WUENSB\n    }\n\n    export function enableDetect(): void {\n        $R.GPIO.IMSET.$$ = mask\n        $R.IOC.IOC0.$[pn].$$ |= $R.IOC_IOC0_WUENSB\n    }\n\n    export function getState(): bool_t {\n        return Pin.$$.get()\n    }\n\n    export function init(pullup: bool_t) {\n        Pin.$$.makeInput()\n        Pin.$$.setInternalPullup(pullup)\n    }\n\n    export function setDetectFalling() {\n        $R.IOC.IOC0.$[pn].$$ &amp;= ~$R.IOC_IOC0_EDGEDET_M\n        $R.IOC.IOC0.$[pn].$$ |= $R.IOC_IOC0_EDGEDET_EDGE_NEG\n    }\n\n    export function setDetectRising() {\n        $R.IOC.IOC0.$[pn].$$ &amp;= ~$R.IOC_IOC0_EDGEDET_M\n        $R.IOC.IOC0.$[pn].$$ |= $R.IOC_IOC0_EDGEDET_EDGE_POS\n    }\n}\n\nexport function $clone() { return { $T, ...em$template } }\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/ExtFlashDisabler/","title":"ExtFlashDisabler","text":"ti.mcu.cc23xx/ExtFlashDisabler.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as BusyWait from '@ti.mcu.cc23xx/BusyWait.em'\nimport * as GpioI from '@em.hal/GpioI.em'\n\nexport const CS = $proxy&lt;GpioI.$I&gt;()\nexport const CLK = $proxy&lt;GpioI.$I&gt;()\nexport const PICO = $proxy&lt;GpioI.$I&gt;()\nexport const POCI = $proxy&lt;GpioI.$I&gt;()\n\nconst SD_CMD = &lt;u8&gt;0xB9\n\nexport function em$startup() {\n    em.$['%%c+']\n    CS.$$.makeOutput()\n    CLK.$$.makeOutput()\n    PICO.$$.makeOutput()\n    POCI.$$.makeInput()\n    // attention\n    CS.$$.set()\n    BusyWait.wait(1)\n    CS.$$.clear()\n    BusyWait.wait(1)\n    CS.$$.set()\n    BusyWait.wait(50)\n    // shutdown command\n    CS.$$.clear()\n    for (let i = 0; i &lt; 8; i++) {\n        CLK.$$.clear()\n        const bv = (SD_CMD &gt;&gt; (7 - i)) &amp; 0x01\n        if (bv == 0) {\n            PICO.$$.clear()\n        } else {\n            PICO.$$.set()\n        }\n        CLK.$$.set()\n        BusyWait.wait(1)\n    }\n    CLK.$$.clear()\n    CS.$$.set()\n    BusyWait.wait(50)\n    //\n    CS.$$.reset()\n    CLK.$$.reset()\n    PICO.$$.reset()\n    POCI.$$.reset()\n    em.$['%%c-']\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/GpioT/","title":"GpioT","text":"ti.mcu.cc23xx/GpioT.em<pre><code>import em from '@$$emscript'\nexport const $T = em.$declare('TEMPLATE')\n\nexport namespace em$template {\n\n    export const $U = em.$declare('MODULE')\n\n    export const pin_num = $config&lt;i16&gt;(-1)\n\n    export namespace em$meta {\n\n        export function pinId(): i16 {\n            return pin_num.$$\n        }\n    }\n\n    const pn = pin_num.$$\n    const mask = 1 &lt;&lt; pn\n\n    export function clear(): void {\n        $R.GPIO.DOUTCLR31_0.$$ = mask\n    }\n\n    export function functionSelect(select: u8): void {\n        $R.IOC.IOC0.$[pn].$$ = select\n    }\n\n    export function get(): bool_t {\n        return isInput() ? (($R.GPIO.DIN31_0.$$ &amp; mask) != 0) : (($R.GPIO.DOUT31_0.$$ &amp; mask) != 0)\n    }\n\n    export function isInput(): bool_t {\n        return ($R.GPIO.DOE31_0.$$ &amp; mask) == 0\n    }\n\n    export function isOutput(): bool_t {\n        return ($R.GPIO.DOE31_0.$$ &amp; mask) != 0\n    }\n\n    export function makeInput(): void {\n        $R.GPIO.DOECLR31_0.$$ = mask\n        $R.IOC.IOC0.$[pn].$$ |= $R.IOC_IOC0_INPEN\n\n    }\n\n    export function makeOutput(): void {\n        $R.GPIO.DOESET31_0.$$ = mask\n        $R.IOC.IOC0.$[pn].$$ &amp;= ~$R.IOC_IOC0_INPEN\n    }\n\n    export function pinId(): i16 {\n        return pn\n    }\n\n    export function reset(): void {\n        $R.GPIO.DOECLR31_0.$$ = mask\n        $R.IOC.IOC0.$[pn].$$ = 0\n    }\n\n    export function set(): void {\n        $R.GPIO.DOUTSET31_0.$$ = mask\n    }\n\n    export function setInternalPulldown(enable: bool_t): void {\n        if (enable) {\n            $R.IOC.IOC0.$[pn].$$ |= $R.IOC_IOC0_PULLCTL_PULL_DOWN\n        }\n        else {\n            $R.IOC.IOC0.$[pn].$$ &amp;= ~$R.IOC_IOC0_PULLCTL_PULL_DOWN\n        }\n    }\n\n    export function setInternalPullup(enable: bool_t): void {\n        if (enable) {\n            $R.IOC.IOC0.$[pn].$$ |= $R.IOC_IOC0_PULLCTL_PULL_UP\n        }\n        else {\n            $R.IOC.IOC0.$[pn].$$ &amp;= ~$R.IOC_IOC0_PULLCTL_PULL_UP\n        }\n    }\n\n    export function toggle(): void {\n        $R.GPIO.DOUTTGL31_0.$$ = mask\n    }\n}\n\nexport function $clone() { return { $T, ...em$template } }\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/Idle/","title":"Idle","text":"ti.mcu.cc23xx/Idle.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Debug from '@em.lang/Debug.em'\nimport * as IntrVec from '@em.arch.arm/IntrVec.em'\n\nexport type SleepCB = cb_t&lt;[]&gt;\n\nconst sleep_enter_tab = $table&lt;SleepCB&gt;('ro')\nconst sleep_leave_tab = $table&lt;SleepCB&gt;('ro')\n\nexport namespace em$meta {\n\n    export function addSleepEnter(cb: SleepCB) {\n        sleep_enter_tab.$add(cb)\n    }\n\n    export function addSleepLeave(cb: SleepCB) {\n        sleep_leave_tab.$add(cb)\n    }\n}\n\nvar cur_pause_only = false\n\nexport function em$startup() {\n    em.$['%%b+']\n    $R.PMCTL.VDDRCTL.$$ = $R.PMCTL_VDDRCTL_SELECT\n    $R.EVTULL.WKUPMASK.$$ = $R.EVTULL_WKUPMASK_AON_IOC_COMB | $R.EVTULL_WKUPMASK_AON_RTC_COMB\n}\n\nfunction doSleep() {\n    for (let i = 0; i &lt; sleep_enter_tab.$len; i++) {\n        const cb = sleep_enter_tab[i]\n        cb()\n    }\n    em.$['%%b:'](2)\n    em.$['%%b-']\n    Debug.reset()\n    $R.CKMD.LDOCTL.$$ = 0\n    IntrVec.PRIMASK_set(1)\n    e$`HapiEnterStandby(0)`\n    Debug.startup()\n    em.$['%%b+']\n    for (let i = 0; i &lt; sleep_leave_tab.$len; i++) {\n        const cb = sleep_leave_tab[i]\n        cb()\n    }\n    IntrVec.PRIMASK_set(0)\n}\n\nfunction doPause() {\n    em.$['%%b:'](1)\n    em.$['%%b-']\n    IntrVec.PRIMASK_set(1)\n    e$`asm volatile (\"wfi\")`\n    em.$['%%b+']\n    IntrVec.PRIMASK_set(0)\n}\n\nexport function setPauseOnly(pause_only: bool_t) {\n    cur_pause_only = pause_only\n}\n\nexport function exec() {\n    if (cur_pause_only) {\n        doPause()\n    }\n    else {\n        doSleep()\n    }\n}\n\nexport function wakeup() {\n\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/Mcu/","title":"Mcu","text":"ti.mcu.cc23xx/Mcu.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Debug from '@em.lang/Debug.em'\n\nconst use_sram = $config&lt;bool_t&gt;()\n\nexport namespace em$meta {\n\n    export function em$construct() {\n        use_sram.$$ = $property('em.lang.BootFlash', false)\n    }\n}\n\nexport function startup(): void {\n    Debug.startup()\n    em.$['%%a:'](2)\n    $R.CKMD.LFCLKSEL.$$ = e$`CKMD_LFCLKSEL_MAIN_LFXT`\n    $R.CKMD.LFXTCTL.$$ = $R.CKMD_LFXTCTL_EN\n    $R.CKMD.IMSET.$$ = $R.CKMD_IMSET_HFXTFAULT | $R.CKMD_IMSET_TRACKREFLOSS | $R.CKMD_IMSET_LFCLKGOOD\n    if (use_sram.$$) {\n        $R.CLKCTL.IDLECFG.$$ = 1\n        $R.VIMS.CCHCTRL.$$ = 0\n\n    }\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/OneShotGpt3/","title":"OneShotGpt3","text":"ti.mcu.cc23xx/OneShotGpt3.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Idle from '@ti.mcu.cc23xx/Idle.em'\nimport * as IntrVec from '@em.arch.arm/IntrVec.em'\nimport * as OneShotI from '@em.hal/OneShotI.em'\n\nexport type Handler = OneShotI.Handler\n\nexport namespace em$meta {\n    export function em$construct() {\n        IntrVec.em$meta.useIntr('LGPT3_COMB')\n    }\n}\n\nvar cur_arg: arg_t\nvar cur_fxn: Handler = $null\n\nexport function disable() {\n    cur_fxn = $null\n    Idle.setPauseOnly(false)\n    IntrVec.NVIC_disable(e$`LGPT3_COMB_IRQn`)\n    $R.LGPT3.ICLR.$$ = $R.LGPT_ICLR_TGT\n}\n\nexport function enable(msecs: u32, handler: OneShotI.Handler, arg: arg_t) {\n    ustart(msecs * 1000, handler, arg)\n}\n\nexport function uenable(usecs: u32, handler: OneShotI.Handler, arg: arg_t) {\n    ustart(usecs, handler, arg)\n}\n\nfunction ustart(usecs: u32, handler: OneShotI.Handler, arg: arg_t) {\n    cur_fxn = handler\n    cur_arg = arg\n    Idle.setPauseOnly(true)\n    IntrVec.NVIC_enable(e$`LGPT3_COMB_IRQn`)\n    $R.CLKCTL.CLKENSET0.$$ = $R.CLKCTL_CLKCFG0_LGPT3\n    $R.LGPT3.IMSET.$$ = $R.LGPT_IMSET_TGT\n    $R.LGPT3.PRECFG.$$ = 48 &lt;&lt; $R.LGPT_PRECFG_TICKDIV_S\n    $R.LGPT3.TGT.$$ = usecs\n    $R.LGPT3.CTL.$$ = $R.LGPT_CTL_MODE_UP_ONCE | $R.LGPT_CTL_C0RST_RST\n}\n\nexport function LGPT3_COMB_isr$$() {\n    let fxn = cur_fxn\n    disable()\n    fxn(cur_arg)\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/Rtc/","title":"Rtc","text":"ti.mcu.cc23xx/Rtc.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as IntrVec from '@em.arch.arm/IntrVec.em'\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\n\nexport namespace em$meta {\n    export function em$construct() {\n        IntrVec.em$meta.useIntr('CPUIRQ0')\n    }\n}\n\nexport type Handler = cb_t&lt;[]&gt;\n\nconst RES_BITS = &lt;u8&gt;20\n\nvar cur_hlr = &lt;Handler&gt;$null\n\nexport function em$startup() {\n    $R.CKMD.LFINCOVR.$$ = 0x8000_0000 + (1 &lt;&lt; RES_BITS)\n    $R.RTC.CTL.$$ = $R.RTC_CTL_RST\n    $R.EVTSVT.CPUIRQ0SEL.$$ = $R.EVTSVT_CPUIRQ0SEL_PUBID_AON_RTC_COMB\n    IntrVec.NVIC_enable(e$`CPUIRQ0_IRQn`)\n}\n\nexport function disable() {\n    cur_hlr = $null\n    $R.RTC.IMCLR.$$ = $R.RTC_IMCLR_EV0\n}\n\nexport function enable(thresh: u32, handler: Handler) {\n    cur_hlr = handler\n    $R.RTC.CH0CC8U.$$ = thresh\n    $R.RTC.IMSET.$$ = $R.RTC_IMSET_EV0\n}\n\nexport function getRawTime(): TimeTypes.RawTime {\n    let lo: u32\n    let hi: u32\n    while (true) {\n        lo = $R.RTC.TIME8U.$$\n        hi = $R.RTC.TIME524M.$$\n        if (lo == $R.RTC.TIME8U.$$) break\n    }\n    let res = TimeTypes.RawTime.$make()\n    res.secs = hi\n    res.subs = lo &lt;&lt; 16\n    return res\n}\n\nexport function toThresh(ticks: u32): u32 {\n    return $R.RTC.TIME8U.$$ + ticks\n}\n\nexport function CPUIRQ0_isr$$() {\n    $R.RTC.ICLR.$$ = $R.RTC_ICLR_EV0\n    if (cur_hlr != $null) cur_hlr()\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/UptimerRtc/","title":"UptimerRtc","text":"ti.mcu.cc23xx/UptimerRtc.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Rtc from '@ti.mcu.cc23xx/Rtc.em'\nimport * as TimeTypes from '@em.utils/TimeTypes.em'\n\nexport function read(): TimeTypes.RawTime {\n    return Rtc.getRawTime()\n}\n</code></pre>"},{"location":"shelf/ti.cc23xx/ti.mcu.cc23xx/WakeupTimerRtc/","title":"WakeupTimerRtc","text":"ti.mcu.cc23xx/WakeupTimerRtc.em<pre><code>import em from '@$$emscript'\nexport const $U = em.$declare('MODULE')\n\nimport * as Rtc from '@ti.mcu.cc23xx/Rtc.em'\nimport * as WakeupTimerI from '@em.hal/WakeupTimerI.em'\n\ntype Handler = WakeupTimerI.Handler\ntype Secs24p8 = WakeupTimerI.Secs24p8\ntype Thresh = WakeupTimerI.Thresh\n\nexport function disable() {\n    Rtc.disable()\n}\n\nexport function enable(secs256: Secs24p8, handler: Handler) {\n    Rtc.enable(secs256, handler)\n}\n\nexport function secsAligned(secs: Secs24p8): Secs24p8 {\n    let raw_time = Rtc.getRawTime()\n    let raw_secs = &lt;Secs24p8&gt;(raw_time.secs &lt;&lt; 8 | raw_time.subs &gt;&gt; 24)\n    let rem = raw_secs % secs\n    return secs - rem\n}\n\nexport function secsToThresh(secs: Secs24p8): Thresh {\n    return Rtc.toThresh(secs &lt;&lt; 8)\n}\n</code></pre>"},{"location":"tutorials/","title":"Learning about EM\u2022Script","text":"<p>under development \u2013 check back soon</p>"},{"location":"blog/archive/2025/","title":"2025","text":""}]}